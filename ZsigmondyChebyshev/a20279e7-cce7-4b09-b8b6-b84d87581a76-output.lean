/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a20279e7-cce7-4b09-b8b6-b84d87581a76
-/

/-
We prove the Chebyshev analogue of Zsigmondy's Theorem (Satz 2).
The main theorem `Satz_2` states that for integers $n > 0$ and $a$, a primitive prime divisor of $T_n(a)-1$ exists if and only if $(n, a)$ is not in a specific set of exceptional pairs.
The proof is split into cases based on the magnitude of $a$ and the value of $n$, utilizing the corollary `wniosek` which relates the existence of primitive divisors to the values of the cyclotomic polynomials $\Omega_n(a)$.
We handle small values of $n$ ($1, 2, 3, 4, 6$) and small values of $|a|$ ($\le 1$) separately, and show that for large $n$ and $|a| > 1$, a primitive divisor always exists.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 01ad815c-29ad-4889-8854-356452879b89

Sorry, Aristotle was unable to complete the task in time.

-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 270a858e-7ab8-42fa-b13c-22ee0a23abf3

Sorry, Aristotle was unable to complete the task in time.

-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f4c5aaee-41bb-40b4-8db5-56e64947fa72

Sorry, Aristotle was unable to complete the task in time.

-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 913ac2cc-0705-446f-a67b-e2893d36711d

Sorry, Aristotle was unable to complete the task in time.

-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8cd1c5b3-4846-4619-b36b-7f9c5f936de0

Sorry, Aristotle was unable to complete the task in time.

-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ee86725c-7da0-4c8b-90fd-9b98d6a00224

Sorry, Aristotle was unable to complete the task in time.

-/

/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

import Mathlib

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Polynomial.Chebyshev.T

open Polynomial
open scoped BigOperators


def is_primitive_prime_divisor_Chebyshev (a : ℤ) (n : ℕ) (p : ℕ) : Prop :=
  p.Prime ∧ (p : ℤ) ∣ (Chebyshev.T ℤ n).eval a - 1 ∧ ∀ d, 0 < d → d < n → ¬ (p : ℤ) ∣ (Chebyshev.T ℤ d).eval a - 1

def Che (p : ℕ) (a : ℤ) : ℕ :=
  sInf { m : ℕ | m > 0 ∧ (p : ℤ) ∣ (Chebyshev.T ℤ m).eval a - 1 }

def sigma (d : ℕ) : ℕ := if d = 1 ∨ d = 2 then 1 else 2

def Omega (n : ℕ) : Polynomial ℝ :=
  if n = 1 then X - 1
  else Finset.prod ((Finset.Ioc 0 (n / 2)).filter (fun k => n.Coprime k))
    (fun k => C 2 * (X - C (Real.cos (2 * k * Real.pi / n))))

theorem RivExer (a b : ℕ) (x : ℤ) :
  ((Chebyshev.T ℤ (a + b)).eval x - 1) * ((Chebyshev.T ℤ (Int.natAbs (a - b))).eval x - 1) =
  ((Chebyshev.T ℤ a).eval x - (Chebyshev.T ℤ b).eval x)^2 := by
    -- By definition of Chebyshev polynomials, we know that $T_n(\cos \theta) = \cos(n\theta)$.
    have h_trig : ∀ n : ℕ, ∀ θ : ℝ, ((Polynomial.Chebyshev.T ℝ n).eval (Real.cos θ)) = Real.cos (n * θ) := by
      aesop;
    -- By substituting $x = \cos \theta$, we can use the trigonometric identity for Chebyshev polynomials.
    have h_subst : ∀ θ : ℝ, ((Polynomial.Chebyshev.T ℝ (a + b)).eval (Real.cos θ) - 1) * ((Polynomial.Chebyshev.T ℝ (Int.natAbs (a - b))).eval (Real.cos θ) - 1) = ((Polynomial.Chebyshev.T ℝ a).eval (Real.cos θ) - (Polynomial.Chebyshev.T ℝ b).eval (Real.cos θ)) ^ 2 := by
      -- Using the trigonometric identity for Chebyshev polynomials, we can rewrite the left-hand side and right-hand side of the equation.
      intros θ
      simp [h_trig];
      rw [ abs_eq_max_neg, max_def ] ; ring;
      split_ifs <;> norm_num [ Real.cos_add, Real.cos_sub ] <;> ring;
      · norm_num [ Real.sin_add, Real.cos_add ] ; ring;
        rw [ Real.sin_sq, Real.sin_sq ] ; ring;
      · rw [ Real.cos_sub ] ; ring;
        simpa only [ Real.sin_sq ] using by ring;
    -- Since these equalities hold for all $x$, the polynomials must be equal.
    have h_poly_eq : (Polynomial.Chebyshev.T ℤ (a + b) - 1) * (Polynomial.Chebyshev.T ℤ (Int.natAbs (a - b)) - 1) = (Polynomial.Chebyshev.T ℤ a - Polynomial.Chebyshev.T ℤ b) ^ 2 := by
      -- Since the polynomials agree on an infinite set, they must be equal.
      have h_poly_eq : ∀ p q : Polynomial ℝ, (∀ θ : ℝ, p.eval (Real.cos θ) = q.eval (Real.cos θ)) → p = q := by
        intros p q h_eq
        have h_inf_agree : Set.Infinite {x : ℝ | p.eval x = q.eval x} := by
          exact Set.Infinite.mono ( fun x hx => by have := h_eq ( Real.arccos x ) ; rw [ Real.cos_arccos hx.1 hx.2 ] at this; aesop ) ( Set.Icc_infinite ( show -1 < 1 by norm_num ) );
        exact?;
      exact Polynomial.map_injective ( Int.castRingHom ℝ ) Int.cast_injective <| h_poly_eq _ _ fun θ => by simpa using h_subst θ;
    simpa using congr_arg ( Polynomial.eval x ) h_poly_eq


theorem LFT (p : ℕ) (hp : p.Prime) (x : ℤ) :
  (p = 2 → (Chebyshev.T ℤ 2).eval x ≡ 1 [ZMOD p]) ∧
  (p ≠ 2 → (Chebyshev.T ℤ (p - 1)).eval x ≡ 1 [ZMOD p] ∨ (Chebyshev.T ℤ (p + 1)).eval x ≡ 1 [ZMOD p]) := by
    bound;
    · -- By definition of Chebyshev polynomials, we know that $T_2(x) = 2x^2 - 1$.
      have hT2 : Polynomial.Chebyshev.T ℤ 2 = 2 * Polynomial.X ^ 2 - 1 := by
        exact?;
      norm_num [ Int.modEq_iff_dvd, ← even_iff_two_dvd, hT2, parity_simps ];
    · -- Using the identity from RivExer with a=p and b=1, we get (T_{p+1}(x) - 1)(T_{p-1}(x) - 1) = (T_p(x) - x)^2.
      have h_identity : ((Chebyshev.T ℤ (p + 1)).eval x - 1) * ((Chebyshev.T ℤ (p - 1)).eval x - 1) = ((Chebyshev.T ℤ p).eval x - x)^2 := by
        convert RivExer p 1 x using 1 <;> norm_num;
        exact Or.inl ( by rw [ abs_of_nonneg ( sub_nonneg_of_le ( mod_cast hp.pos ) ) ] );
      -- We know that $T_p(x) \equiv x^p \equiv x \pmod{p}$ by Fermat's Little Theorem.
      have h_fermat : ((Chebyshev.T ℤ p).eval x) ≡ x [ZMOD p] := by
        haveI := Fact.mk hp; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
        -- By definition of Chebyshev polynomials, we know that $T_p(x) = \cos(p \arccos x)$.
        have h_chebyshev_def : ∀ x : ℂ, Polynomial.eval x (Polynomial.Chebyshev.T ℂ p) = (x + (x^2 - 1)^(1/2 : ℂ))^p / 2 + (x - (x^2 - 1)^(1/2 : ℂ))^p / 2 := by
          intro x;
          -- By definition of Chebyshev polynomials, we know that $T_p(x) = \frac{(x + \sqrt{x^2 - 1})^p + (x - \sqrt{x^2 - 1})^p}{2}$.
          have h_chebyshev_def : ∀ x : ℂ, Polynomial.eval x (Polynomial.Chebyshev.T ℂ p) = ((x + (x^2 - 1)^(1/2 : ℂ))^p + (x - (x^2 - 1)^(1/2 : ℂ))^p) / 2 := by
            intro x
            have h_recurrence : ∀ n : ℕ, Polynomial.eval x (Polynomial.Chebyshev.T ℂ n) = ((x + (x^2 - 1)^(1/2 : ℂ))^n + (x - (x^2 - 1)^(1/2 : ℂ))^n) / 2 := by
              intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Polynomial.Chebyshev.T ] ; ring;
              have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; norm_num [ Polynomial.Chebyshev.T_add_two ] at * ; ring_nf at * ; aesop;
              erw [ show ( 2 + n : ℤ ) = 1 + n + 1 by ring, Polynomial.Chebyshev.T_add_one ] ; aesop ; ring
            exact h_recurrence p;
          linear_combination' h_chebyshev_def x;
        -- Let's simplify the expression using the fact that $(x + \sqrt{x^2 - 1})^p + (x - \sqrt{x^2 - 1})^p$ is an integer.
        have h_simplify : ∀ x : ℂ, (x + (x^2 - 1)^(1/2 : ℂ))^p + (x - (x^2 - 1)^(1/2 : ℂ))^p = 2 * ∑ k ∈ Finset.range (p / 2 + 1), Nat.choose p (2 * k) * x^(p - 2 * k) * (x^2 - 1)^k := by
          intro x; rw [ show ( x + ( x^2 - 1 ) ^ ( 1/2 : ℂ ) ) ^ p = ( ∑ k ∈ Finset.range ( p + 1 ), Nat.choose p k * x ^ ( p - k ) * ( ( x^2 - 1 ) ^ ( 1/2 : ℂ ) ) ^ k ) by rw [ add_comm, add_pow ] ; congr; ext; ring, show ( x - ( x^2 - 1 ) ^ ( 1/2 : ℂ ) ) ^ p = ( ∑ k ∈ Finset.range ( p + 1 ), Nat.choose p k * x ^ ( p - k ) * ( - ( x^2 - 1 ) ^ ( 1/2 : ℂ ) ) ^ k ) by rw [ sub_eq_add_neg, add_comm, add_pow ] ; congr; ext; ring ] ;
          -- Let's simplify the expression by separating the sums into even and odd terms.
          have h_split : ∑ k ∈ Finset.range (p + 1), Nat.choose p k * x^(p - k) * ((x^2 - 1)^(1/2 : ℂ))^k + ∑ k ∈ Finset.range (p + 1), Nat.choose p k * x^(p - k) * (-(x^2 - 1)^(1/2 : ℂ))^k = ∑ k ∈ Finset.filter (fun k => k % 2 = 0) (Finset.range (p + 1)), Nat.choose p k * x^(p - k) * (x^2 - 1)^(k / 2) * 2 := by
            rw [ ← Finset.sum_add_distrib ] ; rw [ Finset.sum_filter ] ; refine' Finset.sum_congr rfl fun k hk => _ ; rcases Nat.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> norm_num [ pow_add, pow_mul ] ; ring;
            norm_num [ pow_mul', ← Complex.cpow_nat_mul ];
          -- Let's simplify the expression by separating the sums into even and odd terms and then combining them.
          have h_filter : Finset.filter (fun k => k % 2 = 0) (Finset.range (p + 1)) = Finset.image (fun k => 2 * k) (Finset.range (p / 2 + 1)) := by
            ext ; aesop <;> try omega;
            exact ⟨ a_1 / 2, by omega, by linarith [ Nat.mod_add_div a_1 2 ] ⟩;
          simp_all +decide [ Finset.mul_sum _ _ _, mul_assoc, mul_comm, mul_left_comm ];
        -- Let's simplify the expression using the fact that $(x + \sqrt{x^2 - 1})^p + (x - \sqrt{x^2 - 1})^p$ is an integer and $p$ is odd.
        have h_simplify_mod : ∀ x : ℤ, (Polynomial.eval x (Polynomial.Chebyshev.T ℤ p)) = ∑ k ∈ Finset.range (p / 2 + 1), Nat.choose p (2 * k) * x^(p - 2 * k) * (x^2 - 1)^k := by
          intro x; specialize h_chebyshev_def x; specialize h_simplify x; norm_num [ ← @Int.cast_inj ℂ ] at *; aesop;
          convert h_chebyshev_def using 1;
          · have h_eval_eq : ∀ n : ℕ, Polynomial.eval (x : ℂ) (Polynomial.Chebyshev.T ℂ n) = Polynomial.eval x (Polynomial.Chebyshev.T ℤ n) := by
              intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Polynomial.Chebyshev.T ] ;
              have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; simp_all +decide [ Polynomial.Chebyshev.T ] ;
              erw [ Polynomial.Chebyshev.T ] ; aesop;
              erw [ Polynomial.Chebyshev.T ] ; aesop;
            exact h_eval_eq p ▸ rfl;
          · linear_combination' h_simplify.symm / 2;
        -- Since $p$ is odd, for $k > 0$, $\binom{p}{2k}$ is divisible by $p$, making each term in the sum zero modulo $p$.
        have h_zero_terms : ∀ k ∈ Finset.range (p / 2 + 1), k ≠ 0 → (Nat.choose p (2 * k) : ℤ) * x^(p - 2 * k) * (x^2 - 1)^k ≡ 0 [ZMOD p] := by
          intro k hk hk'; rw [ Int.modEq_zero_iff_dvd ] ; norm_cast; aesop;
          by_cases h₂ : 2 * k < p;
          · exact dvd_mul_of_dvd_left ( dvd_mul_of_dvd_left ( mod_cast hp.dvd_choose_self ( by linarith [ Nat.pos_of_ne_zero hk' ] ) ( by linarith ) ) _ ) _;
          · cases Nat.Prime.eq_two_or_odd hp <;> omega;
        simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
        rw [ Finset.sum_eq_single 0 ] <;> aesop;
      replace h_identity := congr_arg ( ( ↑ ) : ℤ → ZMod p ) h_identity ; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
      haveI := Fact.mk hp; simp_all +decide [ sub_eq_iff_eq_add ] ;
      tauto


theorem Che_exists (p : ℕ) (hp : p.Prime) (a : ℤ) :
  ∃ m > 0, (p : ℤ) ∣ (Chebyshev.T ℤ m).eval a - 1 := by
    cases hp.eq_two_or_odd';
    · subst p;
      -- For $p = 2$, we can choose $m = 2$. We have $T_2(a) = 2a^2 - 1$, and $2a^2 - 1 - 1 = 2a^2 - 2 = 2(a^2 - 1)$, which is even.
      use 2; norm_num;
      erw [ Polynomial.Chebyshev.T_two ] ; norm_num [ ← even_iff_two_dvd, parity_simps ];
    · have := LFT p hp a;
      rcases this.2 ( by rintro rfl; contradiction ) with h | h <;> [ exact ⟨ p - 1, by linarith [ hp.two_le ], by simpa using h.symm.dvd ⟩ ; exact ⟨ p + 1, by linarith [ hp.two_le ], by simpa using h.symm.dvd ⟩ ]


theorem Che_pos (p : ℕ) (hp : p.Prime) (a : ℤ) : Che p a > 0 := by
  -- Since S is non-empty, its infimum (Che p a) must be positive.
  have hinf_pos : ∃ m : ℕ, m > 0 ∧ (p : ℤ) ∣ (Chebyshev.T ℤ m).eval a - 1 := by
    -- By definition of Che_exists, there exists an m > 0 such that (p : ℤ) divides (Chebyshev.T ℤ m).eval a - 1.
    obtain ⟨m, hm_pos, hm_div⟩ := Che_exists p hp a;
    -- Since $m$ is positive, we can convert it to a natural number by taking its absolute value.
    use m.natAbs;
    aesop;
    rwa [ abs_of_pos hm_pos ];
  -- Since S is non-empty, its infimum (Che p a) must be positive. We can use the fact that the infimum of a non-empty set of positive integers is positive.
  have hinf_pos : ∃ m ∈ {m : ℕ | m > 0 ∧ (p : ℤ) ∣ (Chebyshev.T ℤ m).eval a - 1}, ∀ n ∈ {m : ℕ | m > 0 ∧ (p : ℤ) ∣ (Chebyshev.T ℤ m).eval a - 1}, m ≤ n := by
    exact ⟨ Nat.find hinf_pos, Nat.find_spec hinf_pos, fun n hn => Nat.find_min' hinf_pos hn ⟩;
  aesop;
  exact lt_of_lt_of_le left_1 ( le_csInf ⟨ w_1, left_1, right_2 ⟩ fun n hn => right_1 n hn.1 hn.2 )


theorem Che_spec (p : ℕ) (hp : p.Prime) (a : ℤ) :
  (p : ℤ) ∣ (Chebyshev.T ℤ (Che p a)).eval a - 1 := by
    have h_inf : ∃ m > 0, (p : ℤ) ∣ (Chebyshev.T ℤ m).eval a - 1 := Che_exists p hp a;
    -- By definition of Che, there exists an $m$ in the set such that $m \leq \text{Che}(p, a)$.
    obtain ⟨m, hm_set, hm_le⟩ : ∃ m ∈ {m : ℕ | m > 0 ∧ (p : ℤ) ∣ (Chebyshev.T ℤ m).eval a - 1}, m ≤ Che p a := by
      exact ⟨ _, Nat.sInf_mem ( show ∃ m : ℕ, m > 0 ∧ ( p : ℤ ) ∣ Polynomial.eval a ( Polynomial.Chebyshev.T ℤ ( m : ℤ ) ) - 1 from by rcases h_inf with ⟨ m, hm₁, hm₂ ⟩ ; exact ⟨ m.natAbs, by positivity, by simpa [ abs_of_pos hm₁ ] using hm₂ ⟩ ), le_rfl ⟩;
    exact le_antisymm hm_le ( Nat.sInf_le hm_set ) ▸ hm_set.2


theorem ChebOrd (p : ℕ) (hp : p.Prime) (x : ℤ) (n : ℕ) (hn : n > 0) :
  (p : ℤ) ∣ (Chebyshev.T ℤ n).eval x - 1 ↔ Che p x ∣ n := by
    bound;
    · -- Let $m = \text{Che}(p, x)$. Since $m$ is the smallest positive integer such that $T_m(x) \equiv 1 \pmod{p}$, we have $T_{km}(x) \equiv 1 \pmod{p}$ for any integer $k$.
      set m := Che p x with hm
      have h_div : ∀ k : ℕ, (p : ℤ) ∣ (Polynomial.Chebyshev.T ℤ (k * m)).eval x - 1 := by
        intro k;
        -- By definition of $m$, we know that $T_m(x) \equiv 1 \pmod{p}$.
        have h_Tm : (p : ℤ) ∣ (Polynomial.Chebyshev.T ℤ m).eval x - 1 := by
          convert Che_spec p hp x using 1;
        -- By definition of $T$, we know that $T_{km}(x) = T_k(T_m(x))$.
        have h_Tkm : (Polynomial.Chebyshev.T ℤ (k * m)).eval x = (Polynomial.Chebyshev.T ℤ k).eval ((Polynomial.Chebyshev.T ℤ m).eval x) := by
          have h_Tkm : ∀ k m : ℕ, (Polynomial.Chebyshev.T ℤ (k * m)).eval x = (Polynomial.Chebyshev.T ℤ k).eval ((Polynomial.Chebyshev.T ℤ m).eval x) := by
            intros k m; exact (by
            -- By definition of $T$, we know that $T_{km}(x) = T_k(T_m(x))$ for any integers $k$ and $m$.
            have h_Tkm : ∀ k m : ℕ, Polynomial.Chebyshev.T ℤ (k * m) = Polynomial.comp (Polynomial.Chebyshev.T ℤ k) (Polynomial.Chebyshev.T ℤ m) := by
              exact?;
            rw [ h_Tkm, Polynomial.eval_comp ]);
          exact h_Tkm k m;
        have h_Tk_mod : (Polynomial.Chebyshev.T ℤ k).eval ((Polynomial.Chebyshev.T ℤ m).eval x) ≡ (Polynomial.Chebyshev.T ℤ k).eval 1 [ZMOD p] := by
          -- Since $T_m(x) \equiv 1 \pmod{p}$, we can use the fact that polynomial evaluation preserves congruences modulo $p$.
          have h_poly_cong : ∀ (f : Polynomial ℤ), (f.eval ((Polynomial.Chebyshev.T ℤ m).eval x)) ≡ (f.eval 1) [ZMOD p] := by
            exact fun f => Int.ModEq.symm ( Int.modEq_of_dvd <| by simpa using h_Tm.trans <| Polynomial.sub_dvd_eval_sub _ _ _ );
          exact h_poly_cong _;
        simp_all +decide [ Int.ModEq, Int.emod_eq_emod_iff_emod_sub_eq_zero ];
      -- Let $n = km + r$ with $0 \le r < m$.
      obtain ⟨k, r, hr⟩ : ∃ k r : ℕ, n = k * m + r ∧ r < m := by
        exact ⟨ n / m, n % m, by rw [ Nat.div_add_mod' ], Nat.mod_lt _ <| Nat.pos_of_ne_zero <| by linarith [ Che_pos p hp x ] ⟩;
      -- By `RivExer`, we have $(T_n(x) - 1)(T_{|km-r|}(x) - 1) = (T_{km}(x) - T_r(x))^2$.
      have h_riv : ((Polynomial.Chebyshev.T ℤ (k * m + r)).eval x - 1) * ((Polynomial.Chebyshev.T ℤ (Int.natAbs (k * m - r))).eval x - 1) = ((Polynomial.Chebyshev.T ℤ (k * m)).eval x - (Polynomial.Chebyshev.T ℤ r).eval x)^2 := by
        -- Apply the RivExer lemma with $a = km$ and $b = r$.
        have := RivExer (k * m) r x; aesop;
      -- If $T_n(x) \equiv 1 \pmod{p}$, then $(T_r(x) - 1)^2 \equiv 0 \pmod{p}$, so $T_r(x) \equiv 1 \pmod{p}$.
      have h_tr : (p : ℤ) ∣ (Polynomial.Chebyshev.T ℤ r).eval x - 1 := by
        have h_tr : (p : ℤ) ∣ ((Polynomial.Chebyshev.T ℤ (k * m)).eval x - (Polynomial.Chebyshev.T ℤ r).eval x)^2 := by
          exact h_riv ▸ dvd_mul_of_dvd_left ( by simpa [ hr.1 ] using a ) _;
        haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
        linear_combination' -h_tr + h_div k;
      contrapose! hr;
      exact fun h => Nat.sInf_le ⟨ Nat.pos_of_ne_zero ( by aesop ), h_tr ⟩;
    · cases a ; aesop;
      -- By the properties of Chebyshev polynomials, we have $T_{mn}(x) = T_m(T_n(x))$.
      have h_chebyshev_mul : ∀ m n : ℕ, (Chebyshev.T ℤ (m * n)).eval x = (Chebyshev.T ℤ m).eval ((Chebyshev.T ℤ n).eval x) := by
        have h_chebyshev_mul : ∀ m n : ℕ, (Chebyshev.T ℤ (m * n)) = (Chebyshev.T ℤ m).comp (Chebyshev.T ℤ n) := by
          exact?;
        aesop;
      -- Since $p \mid T_{Che p x}(x) - 1$, we have $T_{Che p x}(x) \equiv 1 \pmod{p}$.
      have h_cong : (Chebyshev.T ℤ (Che p x)).eval x ≡ 1 [ZMOD p] := by
        exact Eq.symm <| Int.modEq_of_dvd <| by simpa using Che_spec p hp x;
      -- By the properties of Chebyshev polynomials, we have $T_{Che p x * w}(x) = T_w(T_{Che p x}(x))$.
      have h_chebyshev_mul_w : (Chebyshev.T ℤ (Che p x * w)).eval x = (Chebyshev.T ℤ w).eval ((Chebyshev.T ℤ (Che p x)).eval x) := by
        grind;
      simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, ← ZMod.intCast_eq_intCast_iff ];
      -- By the properties of Chebyshev polynomials, we have $T_w(1) = 1$.
      have h_chebyshev_w_one : ∀ w : ℕ, (Chebyshev.T ℤ w).eval 1 = 1 := by
        intro w; induction' w using Nat.strong_induction_on with w ih; rcases w with ( _ | _ | w ) <;> simp_all +decide [ Polynomial.Chebyshev.T ] ;
      simp_all +decide [ Polynomial.eval_eq_sum_range ];
      norm_cast ; aesop


theorem prop_Che (p : ℕ) (hp : p.Prime) (x : ℤ) :
  (p ≠ 2 → Che p x ∣ p - 1 ∨ Che p x ∣ p + 1) ∧
  (p ≠ 2 → Nat.Coprime (Che p x) p) ∧
  (p = 2 → (Odd x → Che 2 x = 1) ∧ (Even x → Che 2 x = 2)) := by
    -- For odd p, by LFT, T_{p-1}(x) ≡ 1 (mod p) or T_{p+1}(x) ≡ 1 (mod p).
    have h_odd : p ≠ 2 → (Che p x ∣ p - 1 ∨ Che p x ∣ p + 1) := by
      -- Assume p is odd. Then, by LFT, T_{p-1}(x) ≡ 1 (mod p) or T_{p+1}(x) ≡ 1 (mod p).
      intro hp_odd
      have h_cong : (p : ℤ) ∣ (Chebyshev.T ℤ (p - 1)).eval x - 1 ∨ (p : ℤ) ∣ (Chebyshev.T ℤ (p + 1)).eval x - 1 := by
        -- Apply the LFT to get the required congruence.
        have h_lft : (p : ℤ) ∣ (Chebyshev.T ℤ (p - 1)).eval x - 1 ∨ (p : ℤ) ∣ (Chebyshev.T ℤ (p + 1)).eval x - 1 := by
          have := LFT p hp x
          exact Or.imp ( fun h => h.symm.dvd ) ( fun h => h.symm.dvd ) ( this.2 hp_odd );
        exact h_lft;
      have := ChebOrd p hp x ( p - 1 ) ; have := ChebOrd p hp x ( p + 1 ) ; aesop;
      exact Or.inl <| this_1 hp.one_lt |>.1 <| by simpa [ hp.pos ] using h;
    -- For odd p, since Che(p, x) divides p-1 or p+1, and gcd(p-1, p) = 1 and gcd(p+1, p) = 1, it follows that Che(p, x) is coprime to p.
    have h_coprime : p ≠ 2 → Nat.Coprime (Che p x) p := by
      -- If Che p x divides p-1 or p+1, then their gcd with p must be 1.
      intros hp_ne_two
      have h_div : Che p x ∣ p - 1 ∨ Che p x ∣ p + 1 := h_odd hp_ne_two
      cases' h_div with h_div_p_minus_1 h_div_p_plus_1;
      · exact Nat.Coprime.coprime_dvd_left h_div_p_minus_1 ( by simp +decide [ hp.one_lt.le ] );
      · refine' Nat.Coprime.coprime_dvd_left h_div_p_plus_1 _;
        norm_num;
    aesop;
    · exact le_antisymm ( Nat.sInf_le ⟨ by norm_num, by obtain ⟨ k, rfl ⟩ := a; norm_num [ Polynomial.Chebyshev.T_add_two, ← even_iff_two_dvd, parity_simps ] ⟩ ) ( le_csInf ⟨ 1, by norm_num, by obtain ⟨ k, rfl ⟩ := a; norm_num [ Polynomial.Chebyshev.T_add_two, ← even_iff_two_dvd, parity_simps ] ⟩ fun m hm ↦ Nat.one_le_iff_ne_zero.mpr <| by aesop );
    · -- Since $x$ is even, we have $T_2(x) = 2x^2 - 1$. Therefore, $2 \mid (2x^2 - 1) - 1$.
      have h_m2 : (2 : ℤ) ∣ (Chebyshev.T ℤ 2).eval x - 1 := by
        erw [ Polynomial.Chebyshev.T_two ] ; norm_num [ ← even_iff_two_dvd, parity_simps ];
      refine' le_antisymm ( csInf_le _ _ ) ( le_csInf _ _ ) <;> norm_num;
      · exact h_m2;
      · exact ⟨ 2, by decide, h_m2 ⟩;
      · rintro ( _ | _ | b ) <;> simp_all +decide [ ← even_iff_two_dvd, parity_simps ]


theorem Omega_roots (n : ℕ) (hn : n > 0) :
  (Omega n).roots = if n = 1 then {1}
    else (Finset.Ioc 0 (n / 2)).filter (fun k => n.Coprime k)
      |>.val.map (fun k => Real.cos (2 * k * Real.pi / n)) := by
        -- By definition of Omega n, we can split into cases based on whether n is 1 or not.
        by_cases hn1 : n = 1;
        · -- When $n = 1$, $\Omega_1(x) = x - 1$, which has a single root at $x = 1$.
          simp [hn1, Omega];
          exact Polynomial.roots_X_sub_C _;
        · -- Omega n is defined as the product of linear factors corresponding to the roots.
          have h_omega_prod : Omega n = Finset.prod ((Finset.Ioc 0 (n / 2)).filter (fun k => n.Coprime k)) (fun k => Polynomial.C 2 * (Polynomial.X - Polynomial.C (Real.cos (2 * k * Real.pi / n)))) := by
            unfold Omega; aesop;
          rw [ h_omega_prod, Polynomial.roots_prod ];
          · aesop;
          · exact Finset.prod_ne_zero_iff.mpr fun x hx => mul_ne_zero ( Polynomial.C_ne_zero.mpr two_ne_zero ) ( Polynomial.X_sub_C_ne_zero _ )


theorem leading_coeff_Tn_sub_one (n : ℕ) (hn : n > 0) :
  (Chebyshev.T ℝ n - 1).leadingCoeff = 2 ^ (n - 1) := by
    erw [ Polynomial.leadingCoeff_sub_of_degree_lt ] <;> norm_num;
    · induction hn <;> aesop;
      erw [ Polynomial.Chebyshev.T_add_one ];
      rw [ Polynomial.leadingCoeff_sub_of_degree_lt ] <;> aesop;
      · erw [ Polynomial.leadingCoeff_C ] ; cases m <;> norm_num [ pow_succ' ] at *;
      · -- By definition of Chebyshev polynomials, we know that their degree is $m$.
        have h_deg_T : ∀ m : ℕ, Polynomial.degree (Polynomial.Chebyshev.T ℝ m) = m := by
          intro m; induction' m using Nat.strong_induction_on with m ih; rcases m with ( _ | _ | m ) <;> simp_all +decide [ Polynomial.Chebyshev.T ];
          erw [ Polynomial.Chebyshev.T ];
          erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> erw [ Polynomial.degree_mul, Polynomial.degree_C_mul_X ] <;> norm_num [ ih ];
          · erw [ ih _ <| Nat.lt_succ_self _ ] ; norm_cast ; ring;
          · erw [ ih m ( by linarith ), ih ( m + 1 ) ( by linarith ) ] ; norm_cast ; simp +arith +decide;
        rcases m with ( _ | m ) <;> aesop;
        erw [ Polynomial.degree_C ] <;> norm_num ; erw [ h_deg_T ] ; norm_cast ; linarith;
    · erw [ Polynomial.degree_eq_natDegree ] <;> norm_num;
      · -- By definition of Chebyshev polynomials, we know that their degree is $n$.
        have h_deg : ∀ n : ℕ, Polynomial.natDegree (Chebyshev.T ℝ n) = n := by
          intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Polynomial.Chebyshev.T ] ;
          erw [ Polynomial.Chebyshev.T ];
          erw [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> erw [ Polynomial.natDegree_mul' ] <;> aesop;
          · have := ih ( n + 1 ) ( by linarith ) ; norm_cast at * ; simp_all +arith +decide;
          · specialize ih ( n + 1 ) ; aesop;
          · have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; norm_num at * ; linarith;
          · specialize ih ( n + 1 ) ; aesop;
        aesop;
      · exact ne_of_apply_ne ( Polynomial.eval 1 ) ( by norm_num [ Polynomial.Chebyshev.T ] )


theorem Omega_degree (n : ℕ) (hn : n > 0) :
  (Omega n).natDegree = if n = 1 ∨ n = 2 then 1 else Nat.totient n / 2 := by
    -- For n > 2, Omega(n) is the product of linear factors, so its degree is the number of terms in the product.
    have h_deg : ∀ n > 2, (Omega n).natDegree = (Finset.filter (fun k => Nat.Coprime n k) (Finset.Ioc 0 (n / 2))).card := by
      unfold Omega;
      aesop;
      rw [ Polynomial.natDegree_prod ];
      · erw [ Finset.sum_congr rfl fun _ _ => Polynomial.natDegree_C_mul _ ] <;> norm_num;
      · exact fun i hi => mul_ne_zero ( Polynomial.C_ne_zero.mpr two_ne_zero ) ( Polynomial.X_sub_C_ne_zero _ );
    -- The cardinality of the set of integers in the range $1$ to $n/2$ that are coprime to $n$ is equal to $\phi(n)/2$.
    have h_card : ∀ n > 2, (Finset.filter (fun k => Nat.Coprime n k) (Finset.Ioc 0 (n / 2))).card = Nat.totient n / 2 := by
      intro n hn
      have h_card : Finset.card (Finset.filter (fun k => Nat.Coprime n k) (Finset.Ioc 0 (n / 2))) = Finset.card (Finset.filter (fun k => Nat.Coprime n k) (Finset.Icc 1 n)) / 2 := by
        -- By pairing each $k$ in the range $1$ to $n/2$ with $n-k$, we can show that the number of such $k$ is half the total number of integers coprime to $n$ in the range $1$ to $n$.
        have h_pairing : Finset.filter (fun k => Nat.Coprime n k) (Finset.Icc 1 n) = Finset.image (fun k => k) (Finset.filter (fun k => Nat.Coprime n k) (Finset.Ioc 0 (n / 2))) ∪ Finset.image (fun k => n - k) (Finset.filter (fun k => Nat.Coprime n k) (Finset.Ioc 0 (n / 2))) := by
          ext ; aesop <;> try omega;
          · by_cases ha : a ≤ n / 2 <;> [ exact Or.inl ⟨ ⟨ left, ha ⟩, right ⟩ ; exact Or.inr ⟨ n - a, ⟨ ⟨ Nat.sub_pos_of_lt ( lt_of_le_of_ne right_1 ( by aesop_cat ) ), Nat.sub_le_of_le_add <| by linarith [ Nat.div_add_mod n 2, Nat.mod_lt n two_pos ] ⟩, by simpa [ right_1 ] using right ⟩, Nat.sub_sub_self right_1 ⟩ ] ;
          · simpa [ show w ≤ n by linarith [ Nat.div_mul_le_self n 2 ] ] using right_1;
        rw [ h_pairing, Finset.card_union_of_disjoint ];
        · norm_num [ Finset.card_image_of_injOn ];
          rw [ Finset.card_image_of_injOn fun x hx y hy hxy => by rw [ tsub_right_inj ] at hxy <;> linarith [ Finset.mem_Ioc.mp ( Finset.mem_filter.mp hx |>.1 ), Finset.mem_Ioc.mp ( Finset.mem_filter.mp hy |>.1 ), Nat.div_mul_le_self n 2 ] ] ; simp +arith +decide;
        · rw [ Finset.disjoint_left ] ; aesop;
          cases Nat.even_or_odd' n ; aesop;
          · norm_num [ show x = w by linarith ] at *;
            simp_all +decide [ Nat.Coprime ];
          · omega;
      -- The cardinality of the set of numbers in the range 1 to n that are coprime to n is exactly φ(n).
      have h_card_totient : Finset.card (Finset.filter (fun k => Nat.Coprime n k) (Finset.Icc 1 n)) = Nat.totient n := by
        congr 1 with x ; simp +decide [ Nat.coprime_comm ];
        exact fun hx => ⟨ fun h => lt_of_le_of_ne h.2 ( by aesop_cat ), fun h => ⟨ Nat.pos_of_ne_zero ( by aesop_cat ), h.le ⟩ ⟩;
      rw [ h_card, h_card_totient ];
    -- We'll use the fact that for n=1 and n=2, the degree is 1, and for n>2, it's phi(n)/2.
    by_cases hn1 : n = 1 ∨ n = 2;
    · rcases hn1 with ( rfl | rfl ) <;> simp +decide [ Omega ];
      · erw [ Polynomial.natDegree_X_sub_C ];
      · erw [ Finset.prod_singleton, Polynomial.natDegree_C_mul, Polynomial.natDegree_X_sub_C ] ; norm_num;
    · grind +ring


theorem leading_coeff_Omega (n : ℕ) (hn : n > 0) :
  (Omega n).leadingCoeff = 2 ^ (if n = 1 then 0 else if n = 2 then 1 else Nat.totient n / 2) := by
    unfold Omega; aesop;
    · exact Polynomial.leadingCoeff_X_sub_C _;
    · norm_num [ Finset.prod_filter, mul_div_cancel_left₀ ];
      exact Polynomial.leadingCoeff_X_add_C _;
    · -- The leading coefficient of each term in the product is 2, and there are phi(n)/2 terms.
      have h_leading_coeff : ∀ k ∈ Finset.filter (fun k => Nat.Coprime n k) (Finset.Ioc 0 (n / 2)), Polynomial.leadingCoeff (Polynomial.C (2 : ℝ) * (Polynomial.X - Polynomial.C (Real.cos (2 * k * Real.pi / n)))) = 2 := by
        aesop;
      rw [ Polynomial.leadingCoeff_prod, Finset.prod_congr rfl h_leading_coeff ];
      norm_num [ Nat.totient ];
      -- Since these two sets are equal, their cardinalities are equal.
      have h_card_eq : Finset.card (Finset.filter (fun k => Nat.Coprime n k) (Finset.Ioc 0 (n / 2))) = Finset.card (Finset.filter (fun k => Nat.Coprime n k) (Finset.Ico (n / 2 + 1) n)) := by
        refine' Finset.card_bij ( fun x hx => n - x ) _ _ _ <;> aesop;
        · bound;
          cases lt_or_eq_of_le right_1 <;> aesop;
          · omega;
          · rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> simp_all +arith +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
            omega;
        · simpa [ show a ≤ n from right_1.trans ( Nat.div_le_self _ _ ) ] using right;
        · omega;
        · exact ⟨ n - b, ⟨ ⟨ Nat.sub_pos_of_lt right_1, Nat.sub_le_of_le_add <| by omega ⟩, by simpa [ right_1.le ] using right ⟩, Nat.sub_sub_self right_1.le ⟩;
      have h_card_eq : Finset.card (Finset.filter (fun k => Nat.Coprime n k) (Finset.range n)) = Finset.card (Finset.filter (fun k => Nat.Coprime n k) (Finset.Ioc 0 (n / 2))) + Finset.card (Finset.filter (fun k => Nat.Coprime n k) (Finset.Ico (n / 2 + 1) n)) := by
        have h_card_eq : Finset.filter (fun k => Nat.Coprime n k) (Finset.range n) = Finset.filter (fun k => Nat.Coprime n k) (Finset.Ioc 0 (n / 2)) ∪ Finset.filter (fun k => Nat.Coprime n k) (Finset.Ico (n / 2 + 1) n) := by
          ext ( _ | k ) <;> aesop <;> omega;
        rw [ h_card_eq, Finset.card_union_of_disjoint ] ; exact Finset.disjoint_left.mpr fun x hx₁ hx₂ => by linarith [ Finset.mem_Ioc.mp ( Finset.mem_filter.mp hx₁ |>.1 ), Finset.mem_Ico.mp ( Finset.mem_filter.mp hx₂ |>.1 ) ] ;
      omega


theorem sum_degree_Omega_mul_sigma (n : ℕ) (hn : n > 0) :
  ∑ d ∈ n.divisors, (Omega d).natDegree * (sigma d) = n := by
    -- We compute the term (Omega d).natDegree * (sigma d) for each divisor d.
    have h_term (d : ℕ) (hd : d ∈ Nat.divisors n) : (Omega d).natDegree * (sigma d) = Nat.totient d := by
      -- We'll use the fact that the degree of Omega d is given by the if statement and sigma d is 1 if d is 1 or 2, and 2 otherwise.
      by_cases hd1 : d = 1 ∨ d = 2;
      · unfold Omega sigma; aesop;
        · erw [ Polynomial.natDegree_X_sub_C ];
        · norm_num [ Finset.prod_filter, Finset.prod_singleton, mul_div_right_comm ];
          erw [ Polynomial.natDegree_C_mul, Polynomial.natDegree_X_add_C ] ; norm_num;
      · -- For $d > 2$, the degree of $\Omega_d$ is $\frac{\varphi(d)}{2}$ and $\sigma(d) = 2$.
        have h_deg : (Omega d).natDegree = Nat.totient d / 2 := by
          rw [ Omega_degree ] ; aesop;
          exact Nat.pos_of_mem_divisors hd;
        -- Substitute the values of (Omega d).natDegree and sigma d into the equation.
        rw [h_deg, show sigma d = 2 from by
                    exact if_neg ( by tauto )];
        rw [ Nat.div_mul_cancel ];
        exact even_iff_two_dvd.mp ( Nat.totient_even <| by contrapose! hd1; interval_cases d <;> aesop );
    rw [ Finset.sum_congr rfl h_term, Nat.sum_totient ]


theorem prod_leading_coeff_Omega (n : ℕ) (hn : n > 0) :
  ∏ d ∈ n.divisors, (Omega d).leadingCoeff ^ (sigma d) = 2 ^ (n - 1) := by
    -- We compute the product of the leading coefficients.
    have leading_coeff_product_computed : ∏ d ∈ n.divisors, (2 ^ (if d = 1 then 0 else if d = 2 then 1 else Nat.totient d / 2)) ^ (if d = 1 ∨ d = 2 then 1 else 2) = 2 ^ (∑ d ∈ n.divisors, (if d = 1 then 0 else if d = 2 then 1 else Nat.totient d / 2) * (if d = 1 ∨ d = 2 then 1 else 2)) := by
      rw [ ← Finset.prod_pow_eq_pow_sum ] ; exact Finset.prod_congr rfl fun x hx => by split_ifs <;> ring;
    -- We simplify the exponent using the properties of summation and totient function.
    have exponent_simplified : ∑ d ∈ n.divisors, (if d = 1 then 0 else if d = 2 then 1 else Nat.totient d / 2) * (if d = 1 ∨ d = 2 then 1 else 2) = n - 1 := by
      have exponent_simplified : ∑ d ∈ n.divisors, (if d = 1 then 0 else if d = 2 then 1 else Nat.totient d / 2) * (if d = 1 ∨ d = 2 then 1 else 2) = ∑ d ∈ n.divisors.erase 1, (Nat.totient d) := by
        rw [ ← Finset.sum_erase_add _ _ ( Nat.one_mem_divisors.mpr hn.ne' ), add_comm ];
        rw [ Finset.sum_congr rfl ] ; aesop;
        aesop;
        rw [ Nat.div_mul_cancel ( even_iff_two_dvd.mp ( Nat.totient_even <| Nat.le_of_not_lt fun contra => by interval_cases x <;> simp_all +decide ) ) ];
      convert congr_arg ( · - 1 ) ( Nat.sum_totient n ) using 1;
      rw [ exponent_simplified, ← Finset.sum_erase_add _ _ ( Nat.one_mem_divisors.mpr hn.ne' ), add_comm ] ; aesop;
    -- By definition of $Omega$, we know that its leading coefficient is $2^{if d=1 then 0 else if d=2 then 1 else Nat.totient d / 2}$.
    have h_leading_coeff_Omega : ∀ d ∈ n.divisors, Polynomial.leadingCoeff (Omega d) = 2 ^ (if d = 1 then 0 else if d = 2 then 1 else Nat.totient d / 2) := by
      intros d hd;
      convert leading_coeff_Omega d ( Nat.pos_of_mem_divisors hd ) using 1;
    have h_sigma : ∀ d ∈ Nat.divisors n, sigma d = if d = 1 ∨ d = 2 then 1 else 2 := by
      exact?;
    rw [ ← exponent_simplified ] ; rw [ Finset.prod_congr rfl fun x hx => by rw [ h_leading_coeff_Omega x hx, h_sigma x hx ] ] ; norm_cast;


theorem is_root_Tn_sub_one (n : ℕ) (hn : n > 0) (k : ℕ) :
  (Chebyshev.T ℝ n - 1).eval (Real.cos (2 * k * Real.pi / n)) = 0 := by
    simp_all +decide [ mul_div_cancel₀, ne_of_gt hn ];
    norm_num [ mul_assoc, mul_left_comm ]


theorem PrimitiveRoots_eq_sigma_mul_Omega_roots (d : ℕ) (hd : d > 0) :
  Multiset.map (fun j => Real.cos (2 * j * Real.pi / d)) ((Finset.range d).filter (fun j => j.Coprime d)).val =
  (sigma d) • (Omega d).roots := by
    unfold sigma Omega;
    -- For d > 2, the roots of Omega_d are the cosines of the primitive angles, each appearing twice.
    have h_roots : ∀ d > 2, (Finset.filter (fun j => Nat.Coprime j d) (Finset.range d)).val.map (fun j => Real.cos (2 * j * Real.pi / d)) = 2 • (Finset.filter (fun j => Nat.Coprime j d) (Finset.Ioc 0 (d / 2))).val.map (fun j => Real.cos (2 * j * Real.pi / d)) := by
      intro d hd
      have h_partition : (Finset.filter (fun j => Nat.Coprime j d) (Finset.range d)).val = (Finset.filter (fun j => Nat.Coprime j d) (Finset.Ioc 0 (d / 2))).val + (Finset.filter (fun j => Nat.Coprime j d) (Finset.Ioc (d / 2) (d - 1))).val := by
        ext j;
        by_cases hj : j < d <;> aesop;
        · by_cases hj' : j ≤ d / 2 <;> by_cases hj'' : j = 0 <;> simp_all +decide [ Multiset.count_filter ];
          · linarith;
          · rw [ Multiset.count_eq_one_of_mem ];
            · rw [ Multiset.count_eq_one_of_mem ];
              · exact Finset.nodup _;
              · exact Finset.mem_Ioc.mpr ⟨ Nat.pos_of_ne_zero hj'', hj' ⟩;
            · exact Multiset.nodup_range _;
            · exact Multiset.mem_range.mpr hj;
          · rw [ Multiset.count_eq_one_of_mem, Multiset.count_eq_one_of_mem ];
            · exact Finset.nodup _;
            · exact Finset.mem_Ioc.mpr ⟨ hj', Nat.le_pred_of_lt hj ⟩;
            · exact Multiset.nodup_range _;
            · exact Multiset.mem_range.mpr hj;
        · rw [ Multiset.count_eq_zero_of_notMem, Multiset.count_eq_zero_of_notMem ] <;> aesop ; omega;
          omega;
      -- Since $d > 2$, the map $j \mapsto d - j$ is a bijection on the set of coprimes in $(d/2, d-1)$.
      have h_bijection : (Finset.filter (fun j => Nat.Coprime j d) (Finset.Ioc (d / 2) (d - 1))).val.map (fun j => Real.cos (2 * j * Real.pi / d)) = (Finset.filter (fun j => Nat.Coprime j d) (Finset.Ioc 0 (d / 2))).val.map (fun j => Real.cos (2 * (d - j) * Real.pi / d)) := by
        have h_bijection : Finset.filter (fun j => Nat.Coprime j d) (Finset.Ioc (d / 2) (d - 1)) = Finset.image (fun j => d - j) (Finset.filter (fun j => Nat.Coprime j d) (Finset.Ioc 0 (d / 2))) := by
          ext ; aesop <;> try omega;
          · use d - a;
            exact ⟨ ⟨ ⟨ Nat.sub_pos_of_lt ( by omega ), Nat.sub_le_of_le_add <| by omega ⟩, by simpa [ show a ≤ d from right_1.trans ( Nat.pred_le _ ) ] using right ⟩, Nat.sub_sub_self <| by omega ⟩;
          · by_contra h_contra;
            norm_num [ show w = d / 2 by omega ] at *;
            rcases Nat.even_or_odd' d with ⟨ k, rfl | rfl ⟩ <;> simp_all +arith +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
            omega;
          · simpa [ show w ≤ d by linarith [ Nat.div_mul_le_self d 2 ] ] using right_1;
        aesop;
        rw [ Multiset.dedup_eq_self.mpr ];
        · norm_num [ Multiset.map_map ];
          exact Multiset.map_congr rfl fun x hx => by rw [ Nat.cast_sub ( by linarith [ Finset.mem_Ioc.mp ( Multiset.mem_filter.mp hx |>.1 ), Nat.div_mul_le_self d 2 ] ) ] ;
        · rw [ Multiset.nodup_map_iff_inj_on ];
          · aesop ; omega;
          · exact Multiset.Nodup.filter _ ( Finset.nodup _ );
      simp_all +decide [ two_smul ];
      exact Multiset.map_congr rfl fun x hx => by rw [ ← Real.cos_two_pi_sub ] ; rw [ sub_div' ] <;> ring ; positivity;
    aesop;
    · erw [ Polynomial.roots_X_sub_C ];
    · norm_num [ Finset.prod_filter, Multiset.filter_singleton ];
      rw [ show ( Polynomial.X + 1 : Polynomial ℝ ) = ( Polynomial.X - Polynomial.C ( -1 ) ) by norm_num, Polynomial.roots_X_sub_C ];
    · rw [ h_roots d ( lt_of_le_of_ne ( Nat.succ_le_of_lt ( lt_of_le_of_ne hd ( Ne.symm left ) ) ) ( Ne.symm right ) ), Polynomial.roots_prod ];
      · norm_num [ Finset.filter_congr, Nat.coprime_comm ];
      · exact Finset.prod_ne_zero_iff.mpr fun x hx => mul_ne_zero ( Polynomial.C_ne_zero.mpr two_ne_zero ) ( Polynomial.X_sub_C_ne_zero _ )


theorem multiset_cos_decomposition (n : ℕ) (hn : n > 0) :
  (Multiset.range n).map (fun k => Real.cos (2 * k * Real.pi / n)) =
  (n.divisors).sum (fun d => (Finset.filter (fun j => j.Coprime d) (Finset.range d)).val.map (fun j => Real.cos (2 * j * Real.pi / d))) := by
    -- By definition of $T_n$, the roots of $T_n(x) - 1$ are exactly the cosines of $2k\pi/n$ for $k$ from $0$ to $n-1$.
    have h_roots_Tn : Multiset.map (fun k : ℝ => Real.cos (2 * k * Real.pi / n)) (Multiset.range n) = Multiset.map (fun k : ℝ => Real.cos (2 * k * Real.pi / n)) (Multiset.map (fun k : ℕ => k : ℕ → ℝ) (Finset.range n).val) := by
      -- The two multisets are identical because the conversion from ℕ to ℝ doesn't change the elements, just their type.
      simp [Multiset.range];
    -- By definition of $T_n$, the roots of $T_n(x) - 1$ are exactly the cosines of $2k\pi/n$ for $k$ from $0$ to $n-1$. We can decompose this multiset into sums over primitive parts.
    have h_decomp : Multiset.map (fun k : ℝ => Real.cos (2 * k * Real.pi / n)) (Multiset.map (fun k : ℕ => k : ℕ → ℝ) (Finset.range n).val) = ∑ d ∈ Nat.divisors n, Multiset.map (fun j : ℝ => Real.cos (2 * j * Real.pi / n)) (Multiset.map (fun k : ℕ => k : ℕ → ℝ) (Finset.filter (fun k : ℕ => Nat.gcd k n = n / d) (Finset.range n)).val) := by
      norm_num [ Finset.sum_multiset_map_count ];
      have h_decomp : ∀ k ∈ Finset.range n, ∃! d ∈ Nat.divisors n, Nat.gcd k n = n / d := by
        intro k hk; use n / Nat.gcd k n; aesop;
        · exact Nat.div_dvd_of_dvd <| Nat.gcd_dvd_right _ _;
        · rw [ Nat.div_div_self ( Nat.gcd_dvd_right _ _ ) ( by linarith ) ];
        · rw [ Nat.div_div_self a a_1 ];
      have h_decomp : Multiset.range n = ∑ d ∈ Nat.divisors n, Multiset.filter (fun k : ℕ => Nat.gcd k n = n / d) (Multiset.range n) := by
        ext k;
        by_cases hk : k < n <;> simp_all +decide [ Multiset.count_filter ];
        obtain ⟨ d, hd₁, hd₂ ⟩ := h_decomp k hk;
        rw [ Finset.sum_eq_add_sum_diff_singleton ( Nat.mem_divisors.mpr ⟨ hd₁.1.1, hd₁.1.2 ⟩ ) ];
        rw [ Multiset.count_add, Multiset.count_filter ] ; aesop;
      conv_lhs => rw [ h_decomp ];
      induction' ( Nat.divisors n ) using Finset.induction <;> norm_num at *;
      simp_all +singlePass [ Finset.sum_insert ‹_› ];
    -- For each divisor $d$ of $n$, the set $\{k \in \{0, 1, \ldots, n-1\} \mid \gcd(k, n) = n/d\}$ is in bijection with $\{j \in \{0, 1, \ldots, d-1\} \mid \gcd(j, d) = 1\}$ via the map $k \mapsto k/(n/d) = j$.
    have h_bij : ∀ d ∈ Nat.divisors n, Multiset.map (fun k : ℕ => (k : ℝ)) (Finset.filter (fun k : ℕ => Nat.gcd k n = n / d) (Finset.range n)).val = Multiset.map (fun j : ℕ => j * (n / d) : ℕ → ℝ) (Finset.filter (fun j : ℕ => Nat.gcd j d = 1) (Finset.range d)).val := by
      intro d hd
      have h_bij : Finset.filter (fun k : ℕ => Nat.gcd k n = n / d) (Finset.range n) = Finset.image (fun j : ℕ => j * (n / d)) (Finset.filter (fun j : ℕ => Nat.gcd j d = 1) (Finset.range d)) := by
        ext ; aesop;
        · refine' ⟨ a / ( n / d ), ⟨ _, _ ⟩, _ ⟩;
          · exact Nat.div_lt_of_lt_mul <| by nlinarith [ Nat.div_mul_cancel left ] ;
          · cases left ; aesop;
            have := Nat.gcd_div ( Nat.gcd_dvd_left a ( d * w ) ) ( Nat.gcd_dvd_right a ( d * w ) ) ; aesop;
          · rw [ Nat.div_mul_cancel ( right_1 ▸ Nat.gcd_dvd_left _ _ ) ];
        · nlinarith [ Nat.div_mul_cancel left ];
        · cases left ; aesop;
          rw [ Nat.gcd_mul_right, right_2, one_mul ];
      rw [ h_bij, Finset.image_val ];
      rw [ Multiset.dedup_eq_self.mpr ] ; aesop;
      rw [ Multiset.nodup_map_iff_inj_on ] ; aesop;
      · exact absurd h_2 ( not_lt_of_ge ( Nat.le_of_dvd hn left ) );
      · exact Multiset.Nodup.filter _ ( Multiset.nodup_range _ );
    convert h_decomp using 2;
    rw [ h_bij _ ‹_› ] ; norm_num [ mul_div_mul_right, hn.ne' ] ;
    norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, hn.ne' ]


theorem multiplicity_ge_two_of_root_in_open_interval (n : ℕ) (hn : n > 0) (x : ℝ) (hx : x ∈ Set.Ioo (-1 : ℝ) 1) (hroot : (Chebyshev.T ℝ n - 1).eval x = 0) :
  Polynomial.rootMultiplicity x (Chebyshev.T ℝ n - 1) ≥ 2 := by
    -- Since $x$ is in $(-1, 1)$, we can write $x = \cos(\theta)$ for some $\theta \in (0, \pi)$.
    obtain ⟨θ, hθ⟩ : ∃ θ : ℝ, 0 < θ ∧ θ < Real.pi ∧ x = Real.cos θ := by
      -- Since $x \in (-1, 1)$, we can use the arccos function to find $\theta \in (0, \pi)$ such that $x = \cos(\theta)$.
      use Real.arccos x;
      aesop;
      · exact lt_of_le_of_ne ( Real.arccos_le_pi _ ) ( by rw [ Ne.eq_def, Real.arccos_eq_pi ] ; linarith );
      · -- By definition of arccos, we know that $\cos(\arccos(x)) = x$ for $x \in [-1, 1]$.
        rw [Real.cos_arccos] <;> linarith;
    -- Since $T_n(x) = 1$, we have $T_n'(x) = 0$.
    have h_deriv_zero : Polynomial.eval x (Polynomial.derivative (Polynomial.Chebyshev.T ℝ n)) = 0 := by
      -- Since $T_n(\cos(\theta)) = \cos(n\theta)$, we have $T_n'(\cos(\theta)) = n \sin(n\theta) / \sin(\theta)$.
      have h_deriv : Polynomial.eval (Real.cos θ) (Polynomial.derivative (Polynomial.Chebyshev.T ℝ n)) = n * Real.sin (n * θ) / Real.sin θ := by
        have h_deriv : Polynomial.eval (Real.cos θ) (Polynomial.derivative (Polynomial.Chebyshev.T ℝ n)) = deriv (fun θ => Real.cos (n * θ)) θ / deriv (fun θ => Real.cos θ) θ := by
          have h_deriv : deriv (fun θ => Polynomial.eval (Real.cos θ) (Polynomial.Chebyshev.T ℝ n)) θ = deriv (fun θ => Real.cos (n * θ)) θ := by
            norm_num +zetaDelta at *;
          rw [ ← h_deriv, eq_div_iff ];
          · rw [ show deriv ( fun θ => Polynomial.eval ( Real.cos θ ) ( Polynomial.Chebyshev.T ℝ n ) ) θ = deriv ( fun θ => Polynomial.eval θ ( Polynomial.Chebyshev.T ℝ n ) ) ( Real.cos θ ) * deriv ( fun θ => Real.cos θ ) θ by exact deriv_comp θ ( Polynomial.differentiableAt _ ) ( Real.differentiableAt_cos ) ] ; norm_num;
          · aesop;
            exact ne_of_gt ( Real.sin_pos_of_pos_of_lt_pi left_1 left_2 ) a;
        simp_all +decide [ mul_comm ];
      simp_all +decide [ sub_eq_iff_eq_add ];
      exact Or.inl <| Or.inr <| by rw [ Real.sin_eq_zero_iff_cos_eq ] ; aesop;
    -- Since $T_n(x) - 1$ has a root at $x$ with multiplicity at least 2, we can write $T_n(x) - 1 = (x - x)^2 Q(x)$ for some polynomial $Q(x)$.
    obtain ⟨Q, hQ⟩ : ∃ Q : Polynomial ℝ, Polynomial.Chebyshev.T ℝ n - 1 = (Polynomial.X - Polynomial.C x) ^ 2 * Q := by
      obtain ⟨ Q, hQ ⟩ := Polynomial.dvd_iff_isRoot.mpr hroot; aesop;
      replace hQ := congr_arg ( Polynomial.derivative ) hQ; aesop;
      exact ⟨ Q /ₘ ( Polynomial.X - Polynomial.C ( Real.cos θ ) ), by erw [ pow_two, mul_assoc, Polynomial.mul_divByMonic_eq_iff_isRoot.mpr h_deriv_zero ] ⟩;
    rw [ hQ, Polynomial.rootMultiplicity_mul ] <;> norm_num [ Polynomial.rootMultiplicity_eq_zero ] ; aesop;
    · rw [ Polynomial.rootMultiplicity_X_sub_C_pow ] ; norm_num;
    · refine' ⟨ Polynomial.X_sub_C_ne_zero x, _ ⟩ ; intro h ; simp_all +decide [ sub_eq_iff_eq_add ] ; aesop;
      replace hQ := congr_arg ( Polynomial.eval ( Real.cos ( Real.pi / ( 2 * n ) ) ) ) hQ ; norm_num [ Polynomial.Chebyshev.T ] at hQ ; ring_nf at hQ ; aesop;
      norm_num [ mul_div, mul_comm, hn.ne' ] at hQ


theorem root_multiplicity_one_Tn_sub_one (n : ℕ) (hn : n > 0) :
  Polynomial.rootMultiplicity 1 (Chebyshev.T ℝ n - 1) = 1 := by
    -- Next, we need to show that $T_n'(1) = n^2 \neq 0$.
    have h_Tn1_deriv : Polynomial.eval 1 (Polynomial.derivative (Polynomial.Chebyshev.T ℝ n)) = n^2 := by
      -- We'll use induction to prove that the derivative of $T_n(x)$ at $x=1$ is $n^2$.
      have h_deriv_induction : ∀ n : ℕ, Polynomial.eval 1 (Polynomial.derivative (Polynomial.Chebyshev.T ℝ n)) = n^2 := by
        -- We'll use induction on $n$ to prove that the derivative of $T_n(x)$ at $x=1$ is $n^2$.
        intro n
        induction' n using Nat.strong_induction_on with n ih;
        rcases n with ( _ | _ | n ) <;> norm_num [ Polynomial.Chebyshev.T ];
        have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; norm_num [ add_assoc, Polynomial.Chebyshev.T_add_two ] at * ; linarith;
      exact h_deriv_induction n;
    -- Since the derivative at 1 is non-zero, the multiplicity of 1 as a root of T_n(x) - 1 is exactly 1.
    have h_mult : ¬(Polynomial.X - 1)^2 ∣ (Polynomial.Chebyshev.T ℝ n - 1) := by
      -- If $(X - 1)^2$ divides $T_n(x) - 1$, then the derivative of $T_n(x) - 1$ at $x=1$ must be zero.
      by_contra h_contra
      have h_deriv_zero : Polynomial.eval 1 (Polynomial.derivative (Polynomial.Chebyshev.T ℝ n - 1)) = 0 := by
        obtain ⟨ q, hq ⟩ := h_contra; norm_num [ hq, Polynomial.derivative_pow ] ;
      aesop;
    exact le_antisymm ( Nat.le_of_not_lt fun h => h_mult <| dvd_trans ( pow_dvd_pow _ h ) ( Polynomial.pow_rootMultiplicity_dvd _ _ ) ) ( Nat.pos_of_ne_zero <| by aesop )


theorem root_multiplicity_neg_one_Tn_sub_one (n : ℕ) (hn : n > 0) :
  Polynomial.rootMultiplicity (-1) (Chebyshev.T ℝ n - 1) = if Even n then 1 else 0 := by
    -- If $n$ is even, then $T_n(-1) = 1$, so $-1$ is a root of $T_n(x) - 1$.
    by_cases h_even : Even n;
    · -- Since $T_n'(-1) = -n^2 \neq 0$ for even $n$, $-1$ is a simple root of $T_n(x) - 1$.
      have h_deriv : Polynomial.eval (-1 : ℝ) (Polynomial.derivative (Polynomial.Chebyshev.T ℝ n)) = -n^2 := by
        have h_deriv : ∀ n : ℕ, Polynomial.eval (-1 : ℝ) (Polynomial.derivative (Polynomial.Chebyshev.T ℝ n)) = (-1)^(n-1) * n^2 := by
          intro n;
          induction' n using Nat.strong_induction_on with n ih;
          rcases n with ( _ | _ | n ) <;> norm_num [ Polynomial.Chebyshev.T ];
          have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; norm_num [ Polynomial.Chebyshev.T ] at *;
          erw [ Polynomial.Chebyshev.T ] at * ; norm_num at *;
          cases n <;> simp_all +decide [ pow_succ' ] ; ring;
          norm_cast ; norm_num [ Int.negOnePow_add ] ; ring;
          norm_num [ Int.negOnePow ] ; ring;
        rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.even_add_one ];
        convert h_deriv ( n + 2 ) using 1 ; norm_cast ; simp_all +decide [ parity_simps ];
        ring;
      -- Apply the lemma that states if the derivative at a root is non-zero, then the root multiplicity is 1.
      have h_root_multiplicity : Polynomial.rootMultiplicity (-1 : ℝ) (Polynomial.Chebyshev.T ℝ n - 1) = 1 := by
        have h_eval : Polynomial.eval (-1 : ℝ) (Polynomial.Chebyshev.T ℝ n - 1) = 0 := by
          have h_T_neg1 : ∀ n : ℕ, Polynomial.eval (-1 : ℝ) (Polynomial.Chebyshev.T ℝ n) = (-1 : ℝ)^n := by
            intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ pow_succ, Polynomial.Chebyshev.T ] ;
            norm_num [ Int.negOnePow_add ];
            exact ih _ <| Nat.lt_succ_of_lt <| Nat.lt_succ_self _;
          aesop
        have h_deriv_ne_zero : Polynomial.eval (-1 : ℝ) (Polynomial.derivative (Polynomial.Chebyshev.T ℝ n - 1)) ≠ 0 := by
          aesop
        -- Apply the lemma that states if the derivative at a root is non-zero, then the root multiplicity is 1. This follows from the fact that if the derivative is non-zero, then the root is simple.
        have h_root_multiplicity : ∀ {p : Polynomial ℝ}, p.eval (-1) = 0 → p.derivative.eval (-1) ≠ 0 → Polynomial.rootMultiplicity (-1) p = 1 := by
          intros p hp hp'; exact (by
          exact le_antisymm ( Nat.le_of_not_lt fun h => hp' <| by simpa [ hp ] using Polynomial.isRoot_iterate_derivative_of_lt_rootMultiplicity h ) ( Nat.succ_le_of_lt <| Nat.pos_of_ne_zero <| by aesop ));
        exact h_root_multiplicity h_eval h_deriv_ne_zero;
      aesop;
    · aesop;
      · exact absurd h ( by simpa using h_even );
      · norm_cast at a;
        cases h_even ; simp_all +decide [ Polynomial.Chebyshev.T ]


theorem count_cos_eq_one (n : ℕ) (hn : n > 0) :
  Multiset.count 1 ((Multiset.range n).map (fun k => Real.cos (2 * k * Real.pi / n))) = 1 := by
    -- The cosine function equals 1 only when its argument is an integer multiple of $2\pi$. Therefore, for $k \neq 0$, $\cos(2k\pi/n) \neq 1$.
    have h_cos_ne_one : ∀ k ∈ Finset.range n, k ≠ 0 → Real.cos (2 * k * Real.pi / n) ≠ 1 := by
      norm_num [ Real.cos_eq_one_iff ];
      field_simp;
      intro k hk₁ hk₂ x hx; norm_cast at hx; exact hk₂ ( by nlinarith [ show x = 0 by nlinarith ] ) ;
    norm_num +zetaDelta at *;
    -- Since the only element in the multiset that is 1 is when k=0, and all other elements are not 1, the count of 1 is exactly 1.
    have h_count : Multiset.count 1 (Multiset.map (fun k : ℕ => Real.cos (2 * k * Real.pi / n)) (Multiset.range n)) = Multiset.count 1 (Multiset.map (fun k : ℕ => if k = 0 then 1 else 0) (Multiset.range n)) := by
      rw [ Multiset.count_map, Multiset.count_map ];
      congr 1 with x ; aesop;
      by_cases hx : x = 0 <;> specialize h_cos_ne_one x <;> aesop;
    rcases n with ( _ | _ | n ) <;> simp_all +decide [ Multiset.range ];
    simp_all +decide [ List.range_succ_eq_map ];
    rw [ List.count_eq_zero ] ; aesop


theorem count_cos_eq_neg_one (n : ℕ) (hn : n > 0) :
  Multiset.count (-1) ((Multiset.range n).map (fun k => Real.cos (2 * k * Real.pi / n))) = if Even n then 1 else 0 := by
    unfold Multiset.count; aesop;
    · obtain ⟨ k, rfl ⟩ := even_iff_two_dvd.mp h;
      -- Since $n = 2k$, the only $x$ in the range $0$ to $2k-1$ such that $\cos(2x\pi/(2k)) = -1$ is $x = k$.
      have h_unique : ∀ x ∈ Finset.range (2 * k), Real.cos (2 * x * Real.pi / (2 * k)) = -1 ↔ x = k := by
        -- We'll use the fact that $\cos(\theta) = -1$ if and only if $\theta = (2m + 1)\pi$ for some integer $m$.
        intro x hx
        constructor
        intro h_cos
        have h_eq : ∃ m : ℤ, x = k * (2 * m + 1) := by
          have h_eq : ∃ m : ℤ, 2 * x * Real.pi / (2 * k) = (2 * m + 1) * Real.pi := by
            rw [ ← Real.cos_pi, Real.cos_eq_cos_iff ] at h_cos;
            rcases h_cos with ⟨ m, hm | hm ⟩ <;> [ exact ⟨ -m, by push_cast; linarith ⟩ ; exact ⟨ m - 1, by push_cast; linarith ⟩ ];
          exact h_eq.imp fun m hm => by rw [ div_eq_iff ( by norm_cast; linarith ) ] at hm; rw [ ← @Int.cast_inj ℝ ] ; push_cast; nlinarith [ Real.pi_pos ] ;
        · aesop;
          nlinarith [ show w = 0 by nlinarith ];
        · aesop;
          norm_num [ mul_div_mul_left, hn.ne' ];
      rw [ Multiset.countP_map ];
      rw [ Multiset.card_eq_one ];
      use k; ext x; aesop;
      by_cases hx : x = k <;> specialize h_unique x <;> aesop;
      rw [ Multiset.count_eq_one_of_mem ];
      · exact Multiset.nodup_range _;
      · exact Multiset.mem_range.mpr ( by linarith );
    · rw [ Multiset.countP_eq_zero ] ; aesop;
      -- Since $\cos(2w\pi/n) = -1$, we have $2w\pi/n = (2k+1)\pi$ for some integer $k$.
      obtain ⟨k, hk⟩ : ∃ k : ℤ, 2 * w * Real.pi / n = (2 * k + 1) * Real.pi := by
        rw [ eq_comm, Real.cos_eq_neg_one_iff ] at a; obtain ⟨ k, hk ⟩ := a; exact ⟨ k, by linarith ⟩ ;
      -- Dividing both sides by $\pi$, we get $2w = (2k+1)n$.
      have h_div : 2 * w = (2 * k + 1) * n := by
        exact_mod_cast ( by nlinarith [ Real.pi_pos, mul_div_cancel₀ ( 2 * ( w : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] : ( 2 : ℝ ) * w = ( 2 * k + 1 ) * n );
      grind +ring


theorem cos_eq_iff_eq_or_eq_neg (n : ℕ) (hn : n > 0) (k j : ℕ) (hk : k < n) (hj : j < n) :
  Real.cos (2 * k * Real.pi / n) = Real.cos (2 * j * Real.pi / n) ↔ k = j ∨ k = n - j ∨ (k = 0 ∧ j = 0) := by
    -- By the properties of the cosine function, we know that $\cos(\theta) = \cos(\phi)$ if and only if $\theta = \phi + 2\pi m$ or $\theta = -\phi + 2\pi m$ for some integer $m$.
    have h_cos_eq : Real.cos (2 * k * Real.pi / n) = Real.cos (2 * j * Real.pi / n) ↔ ∃ m : ℤ, 2 * k * Real.pi / n = 2 * j * Real.pi / n + 2 * Real.pi * m ∨ 2 * k * Real.pi / n = -2 * j * Real.pi / n + 2 * Real.pi * m := by
      -- Apply the trigonometric identity for the equality of cosines.
      rw [Real.cos_eq_cos_iff];
      exact ⟨ fun ⟨ m, hm ⟩ => by rcases hm with ( hm | hm ) <;> [ exact ⟨ -m, Or.inl <| by push_cast; ring_nf at *; linarith ⟩ ; exact ⟨ m, Or.inr <| by ring_nf at *; linarith ⟩ ], fun ⟨ m, hm ⟩ => by rcases hm with ( hm | hm ) <;> [ exact ⟨ -m, Or.inl <| by push_cast; ring_nf at *; linarith ⟩ ; exact ⟨ m, Or.inr <| by ring_nf at *; linarith ⟩ ] ⟩;
    aesop;
    · -- By simplifying the equation $2k\pi/n = 2j\pi/n + 2\pi w$, we can divide both sides by $2\pi$ to get $k/n = j/n + w$. Multiplying both sides by $n$ gives $k = j + wn$.
      have h_simplified : k = j + w * n := by
        exact_mod_cast ( by nlinarith [ Real.pi_pos, mul_div_cancel₀ ( 2 * ( k : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( 2 * ( j : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] : ( k : ℝ ) = j + w * n );
      exact Or.inl ( by nlinarith [ show w = 0 by nlinarith ] );
    · -- By simplifying $2 * (↑k : ℝ) * π / (↑n : ℝ) = -(2 * (↑j : ℝ) * π) / (↑n : ℝ) + 2 * π * (↑w : ℝ)$, we get $k + j = w * n$.
      have h_simplified : k + j = w * n := by
        exact_mod_cast ( by nlinarith [ Real.pi_pos, mul_div_cancel₀ ( 2 * ( k : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( - ( 2 * ( j : ℝ ) * Real.pi ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] : ( k : ℝ ) + j = w * n );
      rcases lt_trichotomy w 1 with hw | rfl | hw;
      · exact Or.inr <| Or.inr ⟨ by nlinarith, by nlinarith ⟩;
      · exact Or.inr <| Or.inl <| eq_tsub_of_add_eq <| by linarith;
      · nlinarith;
    · -- In the second case, we can choose $m = 1$.
      use 1
      right
      field_simp
      ring;
      rw [ Nat.cast_sub ] <;> linarith


noncomputable def roots_Tn_sub_one_multiset (n : ℕ) : Multiset ℝ :=
  (Multiset.range n).map (fun k => Real.cos (2 * k * Real.pi / n))

theorem count_roots_Tn_sub_one_multiset (n : ℕ) (hn : n > 0) (x : ℝ) :
  (roots_Tn_sub_one_multiset n).count x =
  if x = 1 then 1
  else if x = -1 ∧ Even n then 1
  else if x ∈ Set.Ioo (-1 : ℝ) 1 ∧ x ∈ roots_Tn_sub_one_multiset n then 2
  else 0 := by
    split_ifs <;> simp_all +decide [ roots_Tn_sub_one_multiset ];
    · convert count_cos_eq_one n hn using 1;
      induction ( Multiset.range n ) using Multiset.induction <;> aesop;
    · convert count_cos_eq_neg_one n hn using 1;
      · induction ( Multiset.range n ) using Multiset.induction <;> aesop;
      · grind;
    · obtain ⟨ ⟨ hx₁, hx₂ ⟩, a, ha₁, ha₂ ⟩ := ‹_›; rw [ Multiset.count_map ] ; aesop;
      -- Since $a$ and $n - a$ are distinct and within the interval $[0, n)$, they are the only solutions.
      have h_solutions : ∀ w : ℕ, w < n → Real.cos (2 * a * Real.pi / n) = Real.cos (2 * w * Real.pi / n) → w = a ∨ w = n - a := by
        intros w hw hcos; rw [ Real.cos_eq_cos_iff ] at hcos; aesop;
        · -- By simplifying $h_3$, we get $w = w_2 * n + a$.
          have h_simplified : w = w_2 * n + a := by
            exact_mod_cast ( by nlinarith [ Real.pi_pos, mul_div_cancel₀ ( 2 * ( w : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( 2 * ( a : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] : ( w : ℝ ) = w_2 * n + a );
          exact Or.inl ( by nlinarith [ show w_2 = 0 by nlinarith ] );
        · -- By simplifying $2 * w * π / n = 2 * w_2 * π - 2 * a * π / n$, we get $w + a = w_2 * n$.
          have h_eq : w + a = w_2 * n := by
            exact_mod_cast ( by nlinarith [ Real.pi_pos, mul_div_cancel₀ ( 2 * ( w : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( 2 * ( a : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] : ( w : ℝ ) + a = w_2 * n );
          rcases lt_trichotomy w_2 1 with h | rfl | h <;> first | left; nlinarith | right; exact eq_tsub_of_add_eq <| by nlinarith;
      rw [ show Multiset.filter ( fun x : ℕ => Real.cos ( 2 * ( a : ℝ ) * Real.pi / n ) = Real.cos ( 2 * ( x : ℝ ) * Real.pi / n ) ) ( Multiset.range n ) = { a, n - a } from ?_ ] ; aesop;
      ext x; aesop;
      by_cases hx : x = a <;> by_cases hx' : x = n - a <;> specialize h_solutions x <;> aesop;
      · rw [ Nat.sub_eq_iff_eq_add ] at hx <;> first |linarith|aesop;
        ring_nf at *; norm_num [ hn.ne' ] at *;
      · rw [ Multiset.count_eq_one_of_mem ];
        · exact Multiset.nodup_range _;
        · aesop;
      · rw [ Multiset.count_filter ] ; aesop;
        · rw [ Multiset.count_eq_one_of_mem ];
          · exact Multiset.nodup_range _;
          · exact Multiset.mem_range.mpr ( Nat.sub_lt hn ( Nat.pos_of_ne_zero ( by aesop_cat ) ) );
        · simp_all +decide [ Nat.cast_sub ha₁.le ];
          exact h_2 ( by rw [ ← Real.cos_two_pi_sub ] ; rw [ sub_div' ] <;> ring_nf ; norm_num [ hn.ne' ] );
    · bound;
      contrapose! h_2; aesop;
      · refine' lt_of_le_of_ne ( Real.neg_one_le_cos _ ) _ ; aesop;
        rw [ eq_comm, Real.cos_eq_neg_one_iff ] at a_1 ; aesop;
        -- Simplify the equation $π + w * (2 * π) = 2 * x_1 * π / n$ to get $n + 2 * w * n = 2 * x_1$.
        have h_simplified : n + 2 * w * n = 2 * x_1 := by
          exact_mod_cast ( by rw [ eq_div_iff ( by positivity ) ] at h_2; nlinarith [ Real.pi_pos ] : ( n : ℝ ) + 2 * w * n = 2 * x_1 );
        exact absurd ( congr_arg Even h_simplified ) ( by norm_num [ h_1, parity_simps ] );
      · exact lt_of_le_of_ne ( Real.cos_le_one _ ) h;
      · use x_1


theorem count_cos_in_open_interval (n : ℕ) (hn : n > 0) (x : ℝ) (hx : x ∈ Set.Ioo (-1 : ℝ) 1) (hk : ∃ k : ℕ, x = Real.cos (2 * k * Real.pi / n)) :
  Multiset.count x ((Multiset.range n).map (fun k => Real.cos (2 * k * Real.pi / n))) = 2 := by
    -- Since $x \in (-1, 1)$, there are exactly two indices $k$ and $n-k$ such that $\cos(2k\pi/n) = x$.
    obtain ⟨k, hk⟩ := hk
    have h_distinct : k ≠ n - k := by
      -- If $k = n - k$, then $2k = n$, implying $n$ is even. However, if $n$ is even, then $k = n/2$, and $\cos(2k\pi/n) = \cos(\pi) = -1$, which contradicts $x \in (-1, 1)$.
      by_contra h_eq
      have h_even : Even n := by
        exact even_iff_two_dvd.mpr ⟨ k, by omega ⟩;
      -- Since $n$ is even, we can write $n = 2m$ for some $m$.
      obtain ⟨m, rfl⟩ : ∃ m, n = 2 * m := even_iff_two_dvd.mp h_even;
      norm_num [ show k = m by omega ] at *;
      norm_num [ mul_div_mul_left, hn.ne' ] at hk ; linarith;
    -- Applying the lemma `count_roots_Tn_sub_one_multiset` to conclude the proof.
    have := @count_roots_Tn_sub_one_multiset n;
    aesop;
    -- Apply the hypothesis this with the conditions that x is in (-1, 1) and in the multiset.
    have := this (Real.cos (2 * k * Real.pi / n));
    aesop;
    -- Since $x$ is in the multiset and in $(-1, 1)$, we can apply the hypothesis `this_1`.
    have h_in_multiset : Real.cos (2 * k * Real.pi / n) ∈ Multiset.map (fun x : ℕ => Real.cos (2 * x * Real.pi / n)) (Multiset.range n) := by
      simp [Multiset.mem_map];
      refine' ⟨ k % n, Nat.mod_lt _ hn, _ ⟩;
      rw [ ← Nat.mod_add_div k n ] ; norm_num ; ring_nf ; norm_num [ mul_assoc, mul_comm Real.pi _, hn.ne' ] ;
    convert this_1 _ using 1;
    congr! 1;
    · unfold roots_Tn_sub_one_multiset; aesop;
    · unfold roots_Tn_sub_one_multiset; aesop;


theorem card_filter_cos_eq (n : ℕ) (hn : n > 0) (k : ℕ) (hk_lower : 0 < k) (hk_upper : k < n) (hk_ne_half : 2 * k ≠ n) :
  (Finset.filter (fun j => Real.cos (2 * j * Real.pi / n) = Real.cos (2 * k * Real.pi / n)) (Finset.range n)).card = 2 := by
    -- By the properties of the cosine function, we know that $\cos(2j\pi/n) = \cos(2k\pi/n)$ if and only if $j = k + mn$ or $j = n - k + mn$ for some integer $m$.
    have h_cos_eq : ∀ j : ℕ, j < n → (Real.cos (2 * j * Real.pi / n) = Real.cos (2 * k * Real.pi / n)) → (j = k ∨ j = n - k) := by
      -- By the properties of the cosine function, if $\cos(2j\pi/n) = \cos(2k\pi/n)$, then $2j\pi/n = 2k\pi/n + 2\pi m$ or $2j\pi/n = -2k\pi/n + 2\pi m$ for some integer $m$.
      intros j hj hcos
      have h_eq : ∃ m : ℤ, 2 * j * Real.pi / n = 2 * k * Real.pi / n + 2 * Real.pi * m ∨ 2 * j * Real.pi / n = -2 * k * Real.pi / n + 2 * Real.pi * m := by
        obtain ⟨ m, hm ⟩ := Real.cos_eq_cos_iff.mp hcos.symm; use m; ring_nf at hm ⊢; aesop;
      -- By simplifying the equations from h_eq, we can see that j must be either k or n - k.
      obtain ⟨m, hm⟩ := h_eq
      have h_cases : j = k + m * n ∨ j = -k + m * n := by
        rcases hm with ( hm | hm ) <;> [ left; right ] <;> push_cast [ ← @Int.cast_inj ℝ ] <;> nlinarith [ Real.pi_pos, mul_div_cancel₀ ( 2 * ( j : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( 2 * ( k : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( -2 * ( k : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
      exact Or.imp ( fun h => by nlinarith [ show m = 0 by nlinarith ] ) ( fun h => eq_tsub_of_add_eq <| by nlinarith [ show m = 1 by nlinarith ] ) h_cases;
    rw [ Finset.card_eq_two ];
    refine' ⟨ k, n - k, _, _ ⟩ <;> norm_num;
    · exact fun h => hk_ne_half <| by rw [ ← @Nat.cast_inj ℝ ] ; push_cast; linarith;
    · ext ; aesop;
      · cases h_cos_eq w left right <;> aesop;
        exact Or.inr ( Nat.cast_sub hk_upper.le );
      · exact ⟨ n - k, Nat.sub_lt hn hk_lower, by rw [ Nat.cast_sub hk_upper.le ] ⟩;
      · rw [ ← Real.cos_two_pi_sub ] ; ring_nf; norm_num [ hn.ne' ] ;


noncomputable def roots_Tn_sub_one_multiset' (n : ℕ) : Multiset ℝ :=
  (Multiset.range n).map (fun k => Real.cos (2 * k * Real.pi / n))

theorem count_roots_Tn_sub_one_multiset' (n : ℕ) (hn : n > 0) (x : ℝ) :
  (roots_Tn_sub_one_multiset' n).count x =
  if x = 1 then 1
  else if x = -1 ∧ Even n then 1
  else if x ∈ Set.Ioo (-1 : ℝ) 1 ∧ x ∈ roots_Tn_sub_one_multiset' n then 2
  else 0 := by
    convert count_roots_Tn_sub_one_multiset n hn x using 1


theorem roots_Tn_sub_one (n : ℕ) (hn : n > 0) :
  (Chebyshev.T ℝ n - 1).roots = (Multiset.range n).map (fun k => Real.cos (2 * k * Real.pi / n)) := by
    -- Let $M$ be the multiset of roots of $T_n(x) - 1$.
    set M := roots_Tn_sub_one_multiset' n;
    -- By definition of $M$, we know that $M$ is the multiset of roots of $T_n(x) - 1$.
    have hM : ∀ x, Multiset.count x (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)) ≥ Multiset.count x M := by
      intro x;
      by_cases hx : x = 1 ∨ x = -1 ∧ Even n ∨ x ∈ Set.Ioo (-1 : ℝ) 1 ∧ x ∈ M;
      · aesop;
        · rw [ root_multiplicity_one_Tn_sub_one ];
          · rw [ count_roots_Tn_sub_one_multiset' ] ; aesop;
            linarith;
          · linarith;
        · have := count_roots_Tn_sub_one_multiset' n hn (-1) ; aesop;
          have := root_multiplicity_neg_one_Tn_sub_one n hn; aesop;
        · have h_mult_ge_two : Polynomial.rootMultiplicity x (Polynomial.Chebyshev.T ℝ n - 1) ≥ 2 := by
            apply multiplicity_ge_two_of_root_in_open_interval n hn x ⟨left, right_1⟩;
            unfold roots_Tn_sub_one_multiset' at right; aesop;
            rw [ mul_div_cancel₀ _ ( by positivity ), mul_comm ];
            norm_num [ show Real.cos ( Real.pi * ( 2 * w ) ) = 1 by convert Real.cos_nat_mul_two_pi w using 2; ring ];
          have := count_roots_Tn_sub_one_multiset' n hn x; aesop;
      · rw [ count_roots_Tn_sub_one_multiset' ] ; aesop;
        · exact absurd right ( by simpa using left_1 );
        · linarith;
    have h_sum_roots : Multiset.card (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)) = n := by
      have h_sum_roots : Multiset.card (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)) ≤ n := by
        refine' le_trans ( Polynomial.card_roots' _ ) _;
        erw [ Polynomial.natDegree_sub_C ];
        -- By definition of Chebyshev polynomials, we know that their degree is n.
        have h_deg : ∀ n : ℕ, Polynomial.natDegree (Polynomial.Chebyshev.T ℝ n) = n := by
          intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Polynomial.Chebyshev.T ];
          erw [ Polynomial.Chebyshev.T ];
          erw [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> erw [ Polynomial.natDegree_mul' ] <;> norm_num [ ih ];
          · have := ih ( n + 1 ) ( by linarith ) ; norm_num at * ; linarith;
          · specialize ih ( n + 1 ) ; aesop;
          · have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; norm_num at * ; linarith;
          · specialize ih ( n + 1 ) ; aesop;
        rw [ h_deg ];
      have h_sum_roots : Multiset.card (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)) ≥ Multiset.card M := by
        have h_sum_roots : ∀ {m : Multiset ℝ}, (∀ x, Multiset.count x m ≤ Multiset.count x (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1))) → Multiset.card m ≤ Multiset.card (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)) := by
          intros m hm; exact (by
          have h_sum_roots : m ≤ (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)) := by
            exact?;
          exact Multiset.card_le_card h_sum_roots);
        exact h_sum_roots hM;
      aesop;
      exact le_antisymm h_sum_roots_1 ( h_sum_roots.trans' ( by erw [ Multiset.card_map ] ; norm_num ) );
    have h_sum_roots_M : Multiset.card M = n := by
      simp +zetaDelta at *;
      unfold roots_Tn_sub_one_multiset'; simp +decide [ hn.ne' ] ;
    have h_eq_roots : ∀ x, Multiset.count x (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)) = Multiset.count x M := by
      intros x
      by_contra h_neq;
      have h_sum_roots_M : ∑ x ∈ (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)).toFinset ∪ M.toFinset, Multiset.count x (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)) > ∑ x ∈ (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)).toFinset ∪ M.toFinset, Multiset.count x M := by
        refine' Finset.sum_lt_sum _ _ <;> aesop;
        use x;
        aesop;
        · by_cases hx : x ∈ roots_Tn_sub_one_multiset' n <;> simp_all +decide [ sub_eq_iff_eq_add ];
        · exact lt_of_le_of_ne ( hM x ) ( Ne.symm h_neq );
      have h_sum_roots_M : ∑ x ∈ (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)).toFinset ∪ M.toFinset, Multiset.count x (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)) ≤ Multiset.card (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)) := by
        rw [ ← Multiset.toFinset_sum_count_eq ];
        rw [ ← Finset.sum_subset ( Finset.subset_union_left ) ] ; aesop;
      have h_sum_roots_M : ∑ x ∈ (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)).toFinset ∪ M.toFinset, Multiset.count x M ≥ Multiset.card M := by
        rw [ ← Multiset.toFinset_sum_count_eq ];
        exact Finset.sum_le_sum_of_subset_of_nonneg ( Finset.subset_union_right ) fun _ _ _ => Nat.zero_le _;
      linarith;
    exact?


theorem roots_prod_Omega_eq_cos_values (n : ℕ) (hn : n > 0) :
  (∏ d ∈ n.divisors, (Omega d) ^ (sigma d)).roots = (Multiset.range n).map (fun k => Real.cos (2 * k * Real.pi / n)) := by
    -- By definition of polynomial multiplication, the roots of the product of polynomials is the sum of the roots of each polynomial.
    have h_roots_product : (∏ d ∈ n.divisors, (Omega d) ^ (sigma d)).roots = ∑ d ∈ n.divisors, (sigma d) • (Omega d).roots := by
      rw [ Polynomial.roots_prod ];
      · induction n.divisors using Finset.induction <;> aesop;
      · -- Since each $\Omega_d$ is a product of non-zero linear factors, it is non-zero.
        have h_Omega_nonzero : ∀ d ∈ Nat.divisors n, Omega d ≠ 0 := by
          -- Since each term in the product is a cosine function, which is never zero, the product itself can't be zero. Therefore, Omega d is non-zero for any d in the divisors of n.
          intros d hd
          simp [Omega];
          split_ifs <;> norm_num [ Finset.prod_eq_zero_iff, Polynomial.X_sub_C_ne_zero ];
          exact Polynomial.X_sub_C_ne_zero _;
        exact Finset.prod_ne_zero_iff.mpr fun d hd => pow_ne_zero _ <| h_Omega_nonzero d hd;
    -- By definition of sigma, we know that sigma_d is 1 if d is 1 or 2, and 2 otherwise. Therefore, multiplying the roots of Omega_d by sigma_d scales the roots by 1 or 2.
    have h_sigma : ∀ d ∈ n.divisors, sigma d • (Omega d).roots = (Finset.filter (fun j => j.Coprime d) (Finset.range d)).val.map (fun j => Real.cos (2 * j * Real.pi / d)) := by
      intros d hd
      rw [PrimitiveRoots_eq_sigma_mul_Omega_roots];
      exact Nat.pos_of_mem_divisors hd;
    rw [ h_roots_product, Finset.sum_congr rfl h_sigma ];
    exact?


theorem roots_Tn_sub_one' (n : ℕ) (hn : n > 0) :
  (Chebyshev.T ℝ n - 1).roots = (Multiset.range n).map (fun k => Real.cos (2 * k * Real.pi / n)) := by
    -- By definition of polynomial roots, if the roots of $T_n(x) - 1$ are exactly the values $\cos(2k\pi/n)$ for $k=0$ to $n-1$, then the polynomial $T_n(x) - 1$ can be factored as $\prod_{k=0}^{n-1} (x - \cos(2k\pi/n))$.
    apply roots_Tn_sub_one n hn


theorem inrtocyc (n : ℕ) (hn : n ≥ 1) :
  Chebyshev.T ℝ n - 1 = ∏ d ∈ n.divisors, (Omega d) ^ (sigma d) := by
    -- Since both polynomials have the same roots and the same leading coefficient, they must be equal.
    have h_eq : (Chebyshev.T ℝ n - 1).roots = (∏ d ∈ n.divisors, (Omega d) ^ (sigma d)).roots ∧ (Chebyshev.T ℝ n - 1).leadingCoeff = (∏ d ∈ n.divisors, (Omega d) ^ (sigma d)).leadingCoeff := by
      -- By combining the results from roots_prod_Omega_eq_cos_values and prod_leading_coeff_Omega, we can conclude the equality of the polynomials.
      apply And.intro;
      · rw [ roots_prod_Omega_eq_cos_values n hn ];
        exact?;
      · rw [ Polynomial.leadingCoeff_prod ];
        norm_num +zetaDelta at *;
        rw [ prod_leading_coeff_Omega ];
        · exact?;
        · linarith;
    -- Apply the fact that if two polynomials have the same roots and the same leading coefficient, then they are equal.
    apply Polynomial.ext_iff.mpr;
    have h_splits : Polynomial.Splits (algebraMap ℝ ℝ) (Chebyshev.T ℝ n - 1) ∧ Polynomial.Splits (algebraMap ℝ ℝ) (∏ d ∈ n.divisors, (Omega d) ^ (sigma d)) := by
      aesop;
      · rw [ Polynomial.splits_iff_card_roots ];
        have h_splits : Polynomial.natDegree (Chebyshev.T ℝ n - 1) = n := by
          erw [ Polynomial.natDegree_sub_C, Polynomial.natDegree_eq_of_degree_eq_some ];
          have h_deg : ∀ n : ℕ, Polynomial.degree (Polynomial.Chebyshev.T ℝ n) = n := by
            intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Polynomial.Chebyshev.T ];
            erw [ Polynomial.Chebyshev.T ];
            erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> erw [ Polynomial.degree_mul, Polynomial.degree_C_mul_X ] <;> norm_num [ ih ];
            · erw [ ih _ <| Nat.lt_succ_self _ ] ; norm_cast ; ring;
            · erw [ ih n ( by linarith ), ih ( n + 1 ) ( by linarith ) ] ; norm_cast ; simp +arith +decide;
          exact h_deg n;
        rw [ roots_Tn_sub_one' ] ; aesop;
        linarith;
      · -- Since each Omega polynomial is a product of linear factors, their product also splits.
        have h_splits : ∀ d ∈ n.divisors, Polynomial.Splits (RingHom.id ℝ) (Omega d) := by
          intro d hd; unfold Omega; aesop;
          · exact Polynomial.splits_X_sub_C _;
          · rw [ Polynomial.splits_iff_card_roots ];
            rw [ Polynomial.roots_prod, Polynomial.natDegree_prod ];
            · erw [ Finset.sum_congr rfl fun x hx => Polynomial.natDegree_C_mul _ ] <;> aesop;
            · exact fun i hi => mul_ne_zero ( Polynomial.C_ne_zero.mpr two_ne_zero ) ( Polynomial.X_sub_C_ne_zero _ );
            · exact Finset.prod_ne_zero_iff.mpr fun x hx => mul_ne_zero ( Polynomial.C_ne_zero.mpr two_ne_zero ) ( Polynomial.X_sub_C_ne_zero _ );
        simp_all +decide [ Polynomial.splits_prod ];
        rw [ Polynomial.splits_prod_iff ];
        · aesop;
          exact?;
        · aesop;
          unfold Omega at a_1 ; aesop;
          · exact absurd a_1 <| Polynomial.X_sub_C_ne_zero _;
          · exact absurd a_1 <| Finset.prod_ne_zero_iff.mpr fun x hx => mul_ne_zero ( Polynomial.C_ne_zero.mpr <| by norm_num ) <| Polynomial.X_sub_C_ne_zero _;
    have h_eq_poly : ∀ p q : Polynomial ℝ, Polynomial.Splits (algebraMap ℝ ℝ) p → Polynomial.Splits (algebraMap ℝ ℝ) q → p.roots = q.roots → p.leadingCoeff = q.leadingCoeff → p = q := by
      intros p q hp hq h_roots h_leadingCoeff;
      rw [ Polynomial.eq_prod_roots_of_splits_id hp, Polynomial.eq_prod_roots_of_splits_id hq, h_roots, h_leadingCoeff ];
    exact fun k => congr_arg ( fun p => p.coeff k ) ( h_eq_poly _ _ h_splits.1 h_splits.2 h_eq.1 h_eq.2 )


theorem Tn_sub_one_splits (n : ℕ) (hn : n > 0) :
  Polynomial.Splits (RingHom.id ℝ) (Chebyshev.T ℝ n - 1) := by
    -- Since the number of roots equals the degree, the polynomial splits.
    have h_splits : Polynomial.Splits (RingHom.id ℝ) (Polynomial.Chebyshev.T ℝ n - 1) ↔ Multiset.card (Polynomial.roots (Polynomial.Chebyshev.T ℝ n - 1)) = Polynomial.natDegree (Polynomial.Chebyshev.T ℝ n - 1) := by
      -- The polynomial $T_n(x) - 1$ splits into linear factors over the reals if and only if it has $n$ roots.
      apply Polynomial.splits_iff_card_roots;
    rw [ h_splits, roots_Tn_sub_one' ];
    · -- The cardinality of the multiset of roots is n, since there are n elements in the range n.
      simp [Multiset.card_map, Multiset.card_range];
      erw [ Polynomial.natDegree_sub_C, Polynomial.natDegree_eq_of_degree_eq_some ];
      have h_deg : ∀ n : ℕ, Polynomial.degree (Polynomial.Chebyshev.T ℝ n) = n := by
        intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Polynomial.Chebyshev.T ];
        -- By the recurrence relation, $T_{n+2}(x) = 2x T_{n+1}(x) - T_n(x)$.
        have h_recurrence : Polynomial.Chebyshev.T ℝ (n + 2) = 2 * Polynomial.X * Polynomial.Chebyshev.T ℝ (n + 1) - Polynomial.Chebyshev.T ℝ n := by
          exact?;
        erw [ h_recurrence, Polynomial.degree_sub_eq_left_of_degree_lt ] <;> erw [ Polynomial.degree_mul, Polynomial.degree_mul, Polynomial.degree_C, Polynomial.degree_X ] <;> norm_num [ ih ];
        · erw [ ih _ <| Nat.lt_succ_self _ ] ; norm_cast ; ring;
        · erw [ ih n ( by linarith ), ih ( n + 1 ) ( by linarith ) ] ; norm_cast ; simp +arith +decide;
      -- Apply the hypothesis `h_deg` to the specific case where `n` is a positive integer.
      apply h_deg;
    · assumption


theorem omega_odd (n : ℕ) (hn : Odd n) :
  (Omega n).eval 0 = 1 ∨ (Omega n).eval 0 = -1 := by
    induction' n using Nat.strong_induction_on with n ih;
    by_cases h₁ : n = 1 ∨ n = 2;
    · cases h₁ <;> simp_all +decide [ Omega ];
    · -- For odd $n$, we can use the fact that $\prod_{d|n} (\Omega_d(0))^{\sigma(d)} = -1$.
      have h_prod_odd : (∏ d ∈ Nat.divisors n, (Polynomial.eval 0 (Omega d)) ^ (sigma d)) = -1 := by
        have h_prod_odd : (Polynomial.eval 0 (Chebyshev.T ℝ n - 1)) = -1 := by
          have h_Tn_zero : ∀ m : ℕ, Polynomial.eval 0 (Polynomial.Chebyshev.T ℝ (2 * m + 1)) = 0 := by
            bound;
            induction' m with m ih <;> norm_num [ Nat.mul_succ, Polynomial.Chebyshev.T_add_two ] at *;
            erw [ Polynomial.Chebyshev.T ] ; norm_num [ ih ];
          cases hn ; aesop;
        convert h_prod_odd using 1;
        rw [ show ( Polynomial.Chebyshev.T ℝ n - 1 : Polynomial ℝ ) = ∏ d ∈ n.divisors, ( Omega d ) ^ sigma d from inrtocyc n ( Nat.pos_of_ne_zero hn.pos.ne' ) ] ; norm_num [ Polynomial.eval_prod ];
      -- Since $\sigma(d) = 2$ for all $d > 2$, we can simplify the product to $(\Omega_n(0))^2 \cdot \prod_{d|n, d>2} (\Omega_d(0))^2 = -1$.
      have h_prod_simplified : (Polynomial.eval 0 (Omega n)) ^ (sigma n) * (∏ d ∈ Nat.divisors n \ {n}, (Polynomial.eval 0 (Omega d)) ^ (sigma d)) = -1 := by
        rw [ ← h_prod_odd, Finset.prod_eq_mul_prod_diff_singleton <| Nat.mem_divisors_self _ <| by aesop ];
      -- Since $\sigma(d) = 2$ for all $d > 2$, we can simplify the product to $(\Omega_n(0))^2 \cdot \prod_{d|n, d>2} (\Omega_d(0))^2 = -1$. Therefore, $(\Omega_n(0))^2 = 1$.
      have h_Omega_n_sq : (Polynomial.eval 0 (Omega n)) ^ (sigma n) = 1 ∨ (Polynomial.eval 0 (Omega n)) ^ (sigma n) = -1 := by
        have h_Omega_n_sq : (∏ d ∈ Nat.divisors n \ {n}, (Polynomial.eval 0 (Omega d)) ^ (sigma d)) = 1 ∨ (∏ d ∈ Nat.divisors n \ {n}, (Polynomial.eval 0 (Omega d)) ^ (sigma d)) = -1 := by
          have h_prod_simplified : ∀ d ∈ Nat.divisors n \ {n}, (Polynomial.eval 0 (Omega d)) ^ (sigma d) = 1 ∨ (Polynomial.eval 0 (Omega d)) ^ (sigma d) = -1 := by
            intros d hd; specialize ih d ( Nat.lt_of_le_of_ne ( Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop ) ) ( Nat.dvd_of_mem_divisors ( Finset.mem_sdiff.mp hd |>.1 ) ) ) ( by aesop ) ) ( hn.of_dvd_nat ( Nat.dvd_of_mem_divisors ( Finset.mem_sdiff.mp hd |>.1 ) ) ) ; aesop;
            exact?;
          exact eq_or_eq_neg_of_abs_eq ( by rw [ Finset.abs_prod ] ; exact Finset.prod_eq_one fun x hx => by cases h_prod_simplified x hx <;> simp +decide [ * ] );
        cases h_Omega_n_sq <;> simp_all +decide;
      cases h_Omega_n_sq <;> simp_all +decide [ sigma ];
      nlinarith


theorem Tn_zero_eq_zero_of_odd (n : ℕ) (hn : Odd n) :
  (Chebyshev.T ℝ n).eval 0 = 0 := by
    induction hn;
    aesop;
    induction w <;> simp_all +decide [ Int.negSucc_eq, mul_add, add_assoc, Polynomial.Chebyshev.T ];
    erw [ show ( 2 * ( _:ℕ ) + 3 : ℤ ) = ( 2 * ( _:ℕ ) + 1 ) + 2 by ring, Polynomial.Chebyshev.T_add_two ] ; aesop


theorem omegas_prop_b (m n : ℕ) (hm : m > 0) (hn : n > 0) :
  Omega (m * n) ∣ (Omega n).comp (Chebyshev.T ℝ m) ∧
  (n ≥ 3 → (∀ p : ℕ, p.Prime → p ∣ m → p ∣ n) → Omega (m * n) = (Omega n).comp (Chebyshev.T ℝ m)) := by
    -- Let's first show that Omega(mn) divides Omega(n)(T_m(x)).
    have h_div : Omega (m * n) ∣ (Omega n).comp (Polynomial.Chebyshev.T ℝ m) := by
      -- If $\alpha$ is a root of $\Omega_{mn}$, then $T_m(\alpha)$ is a root of $\Omega_n$.
      have h_root : ∀ α : ℝ, α ∈ (Omega (m * n)).roots → (Polynomial.eval α (Polynomial.comp (Omega n) (Polynomial.Chebyshev.T ℝ m))) = 0 := by
        unfold Omega;
        split_ifs <;> simp_all +decide [ Polynomial.eval_prod, Finset.prod_eq_zero_iff, sub_eq_iff_eq_add ];
        · exact fun α _ x hx₁ hx₂ hx₃ hx₄ => by rw [ mul_div_cancel₀ _ ( by positivity ) ] ; norm_num [ mul_assoc, mul_left_comm ] ;
        · field_simp;
          intro α hα x hx₁ hx₂ hx₃ hx₄; use if x % n ≤ n / 2 then x % n else n - x % n; aesop;
          any_goals omega;
          any_goals exact Nat.mod_lt _ hn;
          · contrapose! hα; aesop;
            have := Nat.dvd_gcd ( dvd_mul_left n m ) ( Nat.dvd_of_mod_eq_zero hα ) ; aesop;
          · rw [ Nat.Coprime, Nat.gcd_rec ] at *;
            simp_all +decide [ Nat.mod_eq_of_lt ( show x < m * n from hx₂.trans_lt ( Nat.div_lt_self ( by positivity ) ( by norm_num ) ) ) ];
            -- Since $x$ and $n$ are coprime, their greatest common divisor is 1.
            have h_coprime : Nat.gcd x n = 1 := by
              exact Nat.Coprime.coprime_dvd_right ( dvd_mul_left _ _ ) hx₃;
            rwa [ Nat.gcd_comm, Nat.gcd_rec ] at h_coprime;
          · rw [ ← Nat.mod_add_div x n ] ; norm_num ; ring;
            norm_num [ mul_assoc, mul_comm Real.pi _, hn.ne' ];
            norm_num [ mul_assoc, mul_left_comm, hn.ne' ];
          · simp_all +decide [ Nat.Coprime, Nat.gcd_comm ];
            -- Since $x$ is coprime with $n$, $x \% n$ is also coprime with $n$.
            have h_coprime : Nat.gcd (x % n) n = 1 := by
              rw [ ← Nat.gcd_rec, Nat.gcd_comm ];
              exact Nat.Coprime.coprime_dvd_right ( dvd_mul_left _ _ ) hx₃;
            simpa [ Nat.gcd_comm, show x % n ≤ n from Nat.le_of_lt <| Nat.mod_lt _ hn ] using h_coprime;
          · rw [ Nat.cast_sub ( Nat.le_of_lt ( Nat.mod_lt _ hn ) ) ] ; ring;
            rw [ Nat.mod_def ] ; ring_nf ; norm_num [ hn.ne' ] ;
            rw [ Nat.cast_sub ( by nlinarith [ Nat.div_mul_le_self x n ] ) ] ; push_cast ; ring;
            norm_num [ hn.ne', mul_assoc, mul_comm Real.pi ];
      -- Since $\Omega_{mn}$ has simple roots, it divides $\Omega_n(T_m(x))$.
      have h_div : Multiset.prod (Multiset.map (fun α => Polynomial.X - Polynomial.C α) (Omega (m * n)).roots) ∣ (Omega n).comp (Polynomial.Chebyshev.T ℝ m) := by
        have h_div : ∀ α ∈ (Omega (m * n)).roots, (Polynomial.X - Polynomial.C α) ∣ (Omega n).comp (Polynomial.Chebyshev.T ℝ m) := by
          exact fun α hα => Polynomial.dvd_iff_isRoot.mpr ( h_root α hα );
        have h_distinct_roots : Multiset.Nodup (Omega (m * n)).roots := by
          have h_distinct_roots : Multiset.Nodup (Multiset.map (fun k => Real.cos (2 * k * Real.pi / (m * n))) ((Finset.filter (fun k => Nat.Coprime (m * n) k) (Finset.Ioc 0 ((m * n) / 2))).val)) := by
            rw [ Multiset.nodup_map_iff_inj_on ] ; aesop;
            · have := Real.injOn_cos ⟨ by positivity, by rw [ div_le_iff₀ ( by positivity ) ] ; nlinarith [ Real.pi_pos, show ( w:ℝ ) ≤ m * n / 2 by exact le_div_iff₀' ( by positivity ) |>.2 <| by norm_cast; linarith [ Nat.div_mul_le_self ( m * n ) 2 ] ] ⟩ ⟨ by positivity, by rw [ div_le_iff₀ ( by positivity ) ] ; nlinarith [ Real.pi_pos, show ( w_1:ℝ ) ≤ m * n / 2 by exact le_div_iff₀' ( by positivity ) |>.2 <| by norm_cast; linarith [ Nat.div_mul_le_self ( m * n ) 2 ] ] ⟩ a_2 ; aesop;
              rw [ div_eq_div_iff ] at this <;> norm_num [ Real.pi_ne_zero, hm.ne', hn.ne' ] at * ; aesop;
            · simp +zetaDelta at *;
              rw [ Multiset.nodup_map_iff_inj_on ] ; aesop;
              exact Multiset.Nodup.filter _ ( Finset.nodup _ );
          unfold Omega; aesop;
          · erw [ Polynomial.roots_X_sub_C ] ; norm_num;
          · rw [ Polynomial.roots_prod ] <;> aesop;
            exact absurd a <| Finset.prod_ne_zero_iff.mpr fun x hx => mul_ne_zero ( Polynomial.C_ne_zero.mpr <| by norm_num ) <| Polynomial.X_sub_C_ne_zero _;
        have h_prod_div : ∀ {S : Multiset ℝ}, Multiset.Nodup S → (∀ α ∈ S, (Polynomial.X - Polynomial.C α) ∣ (Omega n).comp (Polynomial.Chebyshev.T ℝ m)) → Multiset.prod (Multiset.map (fun α => Polynomial.X - Polynomial.C α) S) ∣ (Omega n).comp (Polynomial.Chebyshev.T ℝ m) := by
          -- By induction on the size of the multiset S.
          intro S hS h_div
          induction' S using Multiset.induction with α S ih;
          · norm_num;
          · simp +zetaDelta at *;
            obtain ⟨ q, hq ⟩ := ih hS.2 h_div.2;
            rw [ hq, mul_comm ];
            refine' mul_dvd_mul_left _ _;
            erw [ Polynomial.dvd_iff_isRoot ] at * ; aesop;
            rw [ Polynomial.eval_multiset_prod ] at h ; aesop;
            exact False.elim <| left <| by rw [ sub_eq_zero ] at right_2; aesop;
        exact h_prod_div h_distinct_roots h_div;
      refine' dvd_trans _ h_div;
      have h_splits : Polynomial.Splits (RingHom.id ℝ) (Omega (m * n)) := by
        unfold Omega; aesop;
        · exact Polynomial.splits_X_sub_C _;
        · rw [ Polynomial.splits_iff_card_roots ];
          rw [ Polynomial.natDegree_prod, Polynomial.roots_prod ];
          · erw [ Finset.sum_congr rfl fun x hx => Polynomial.natDegree_C_mul _ ] <;> norm_num;
            rfl;
          · exact Finset.prod_ne_zero_iff.mpr fun x hx => mul_ne_zero ( Polynomial.C_ne_zero.mpr two_ne_zero ) ( Polynomial.X_sub_C_ne_zero _ );
          · exact fun i hi => mul_ne_zero ( Polynomial.C_ne_zero.mpr two_ne_zero ) ( Polynomial.X_sub_C_ne_zero _ );
      -- Since the polynomial is equal to the product of its roots multiplied by its leading coefficient, and the leading coefficient is 1, the polynomial is equal to the product of its roots.
      have h_poly_eq_prod_roots : Omega (m * n) = Polynomial.C (Polynomial.leadingCoeff (Omega (m * n))) * Multiset.prod (Multiset.map (fun α => Polynomial.X - Polynomial.C α) (Omega (m * n)).roots) := by
        exact?;
      rw [ h_poly_eq_prod_roots ];
      rw [ Polynomial.roots_C_mul ] <;> norm_num;
      · refine' ⟨ Polynomial.C ( Polynomial.leadingCoeff ( Omega ( m * n ) ) ) ⁻¹, _ ⟩;
        rw [ mul_right_comm, ← Polynomial.C_mul, mul_inv_cancel₀ ] <;> norm_num;
        unfold Omega; norm_num;
        split_ifs <;> norm_num [ Polynomial.X_sub_C_ne_zero, Finset.prod_eq_zero_iff ];
        exact Polynomial.X_sub_C_ne_zero _;
      · unfold Omega; norm_num;
        split_ifs <;> norm_num [ Polynomial.X_sub_C_ne_zero, Finset.prod_eq_zero_iff ];
        exact Polynomial.X_sub_C_ne_zero _;
    -- If $n \geq 3$ and $\forall p : ℕ, Nat.Prime p → p ∣ m → p ∣ n$, then $\phi(mn) = m \phi(n)$.
    have h_phi : n ≥ 3 → (∀ p : ℕ, Nat.Prime p → p ∣ m → p ∣ n) → Nat.totient (m * n) = m * Nat.totient n := by
      intro hn hmn;
      rw [ Nat.totient_eq_div_primeFactors_mul, Nat.totient_eq_div_primeFactors_mul ];
      rw [ Nat.primeFactors_mul ( by positivity ) ( by positivity ) ];
      rw [ show m.primeFactors ∪ n.primeFactors = n.primeFactors from ?_ ];
      · rw [ ← mul_assoc, Nat.mul_div_assoc _ ( Nat.prod_primeFactors_dvd _ ) ];
      · ext p; aesop;
    -- If $n \geq 3$ and $\forall p : ℕ, Nat.Prime p → p ∣ m → p ∣ n$, then $\Omega_{mn}$ and $\Omega_n(T_m(x))$ have the same degree and leading coefficient.
    have h_deg_leading_coeff : n ≥ 3 → (∀ p : ℕ, Nat.Prime p → p ∣ m → p ∣ n) → (Omega (m * n)).natDegree = ((Omega n).comp (Polynomial.Chebyshev.T ℝ m)).natDegree ∧ (Omega (m * n)).leadingCoeff = ((Omega n).comp (Polynomial.Chebyshev.T ℝ m)).leadingCoeff := by
      aesop;
      · -- The degree of $\Omega_{mn}$ is $\frac{\phi(mn)}{2}$, and the degree of $\Omega_n(T_m(x))$ is $\frac{\phi(n)}{2} \cdot m$.
        have h_deg : (Omega (m * n)).natDegree = (Nat.totient (m * n)) / 2 ∧ ((Omega n).comp (Polynomial.Chebyshev.T ℝ m)).natDegree = (Nat.totient n) / 2 * m := by
          bound;
          · convert Omega_degree ( m * n ) ( Nat.mul_pos hm hn ) using 1;
            rcases m with ( _ | _ | m ) <;> rcases n with ( _ | _ | n ) <;> norm_num at *;
            · aesop;
            · rintro h; nlinarith;
          · -- The degree of $T_m$ is $m$, and the degree of $\Omega_n$ is $\frac{\phi(n)}{2}$.
            have h_deg_Tm : Polynomial.natDegree (Polynomial.Chebyshev.T ℝ m) = m := by
              -- By definition of Chebyshev polynomials, we know that their degree is equal to their index.
              have h_deg_T : ∀ n : ℕ, (Polynomial.Chebyshev.T ℝ n).natDegree = n := by
                intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Polynomial.Chebyshev.T ] ;
                erw [ Polynomial.Chebyshev.T ];
                erw [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> erw [ Polynomial.natDegree_mul' ] <;> norm_num [ ih ];
                · have := ih ( n + 1 ) ( by linarith ) ; norm_num at * ; linarith!;
                · exact ne_of_apply_ne ( Polynomial.eval 1 ) ( by norm_num [ Polynomial.Chebyshev.T ] );
                · have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; norm_num [ Polynomial.Chebyshev.T ] at * ; linarith;
                · exact ne_of_apply_ne ( Polynomial.eval 1 ) ( by norm_num [ Polynomial.Chebyshev.T ] );
              exact h_deg_T m
            have h_deg_Omega_n : Polynomial.natDegree (Omega n) = (Nat.totient n) / 2 := by
              convert Omega_degree n hn using 1;
              rcases n with ( _ | _ | _ | n ) <;> simp_all +arith +decide;
            rw [ Polynomial.natDegree_comp, h_deg_Omega_n, h_deg_Tm, mul_comm ];
        rw [ h_deg.1, h_deg.2, h_phi, mul_comm ];
        rw [ Nat.div_eq_of_eq_mul_left ] <;> nlinarith [ Nat.div_mul_cancel ( show 2 ∣ Nat.totient n from even_iff_two_dvd.mp ( Nat.totient_even <| by linarith ) ) ];
      · rw [ Polynomial.leadingCoeff_comp ];
        · -- Substitute the known leading coefficients of Omega(n) and T_m(x).
          have h_leading_coeff : (Omega (m * n)).leadingCoeff = 2 ^ (Nat.totient (m * n) / 2) ∧ (Omega n).leadingCoeff = 2 ^ (Nat.totient n / 2) ∧ (Polynomial.Chebyshev.T ℝ m).leadingCoeff = 2 ^ (m - 1) := by
            aesop;
            · convert leading_coeff_Omega ( m * n ) ( Nat.mul_pos hm hn ) using 1;
              rcases m with ( _ | _ | m ) <;> rcases n with ( _ | _ | n ) <;> simp_all +decide [ Nat.totient_prime ];
              · linarith;
              · rintro h; nlinarith;
            · convert leading_coeff_Omega n hn using 1;
              rcases n with ( _ | _ | _ | n ) <;> trivial;
            · have h_leading_coeff_Tm : ∀ m : ℕ, m > 0 → Polynomial.leadingCoeff (Polynomial.Chebyshev.T ℝ m) = 2 ^ (m - 1) := by
                intro m hm; induction' m using Nat.strong_induction_on with m ih; rcases m with ( _ | _ | m ) <;> simp_all +decide [ Polynomial.Chebyshev.T ] ;
                -- For the inductive step, we use the recurrence relation for Chebyshev polynomials: $T_{m+2}(x) = 2xT_{m+1}(x) - T_m(x)$.
                have h_recurrence : Polynomial.Chebyshev.T ℝ (m + 2) = 2 * Polynomial.X * Polynomial.Chebyshev.T ℝ (m + 1) - Polynomial.Chebyshev.T ℝ m := by
                  exact?;
                erw [ h_recurrence, Polynomial.leadingCoeff_sub_of_degree_lt ] <;> norm_num [ ih ];
                · erw [ Polynomial.leadingCoeff_C, ih ] <;> norm_num [ pow_succ' ];
                · erw [ Polynomial.degree_C ] <;> norm_num;
                  -- By definition of Chebyshev polynomials, we know that their degree is m.
                  have h_deg : ∀ m : ℕ, Polynomial.degree (Polynomial.Chebyshev.T ℝ m) = m := by
                    intro m; induction' m using Nat.strong_induction_on with m ih; rcases m with ( _ | _ | m ) <;> simp_all +decide [ Polynomial.Chebyshev.T ] ;
                    erw [ Polynomial.Chebyshev.T ];
                    erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> erw [ Polynomial.degree_mul, Polynomial.degree_mul, Polynomial.degree_C, Polynomial.degree_X ] <;> norm_num;
                    · erw [ ih _ ( by linarith ) ] ; norm_cast ; ring;
                    · erw [ ih m ( by linarith ), ih ( m + 1 ) ( by linarith ) ] ; norm_cast ; simp +arith +decide;
                  erw [ h_deg, h_deg ] ; norm_cast ; simp +arith +decide;
              exact h_leading_coeff_Tm m hm;
          rw [ h_leading_coeff.1, h_leading_coeff.2.1, h_leading_coeff.2.2, Omega_degree ];
          · rcases m with ( _ | _ | m ) <;> simp_all +decide [ ← pow_mul ];
            rw [ if_neg ( by rintro ( rfl | rfl ) <;> contradiction ) ] ; rw [ ← pow_add ] ; rw [ Nat.div_eq_of_eq_mul_left zero_lt_two ] ; nlinarith [ Nat.div_mul_cancel ( show 2 ∣ n.totient from even_iff_two_dvd.mp <| Nat.totient_even <| by linarith ) ] ;
          · linarith;
        · -- The degree of $T_m(x)$ is $m$, which is positive since $m > 0$.
          have h_deg_Tm : (Polynomial.Chebyshev.T ℝ m).natDegree = m := by
            have h_deg_Tm : ∀ m : ℕ, (Polynomial.Chebyshev.T ℝ m).natDegree = m := by
              intro m; induction' m using Nat.strong_induction_on with m ih; rcases m with ( _ | _ | m ) <;> simp_all +decide [ Polynomial.Chebyshev.T ] ;
              erw [ Polynomial.Chebyshev.T ];
              erw [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> erw [ Polynomial.natDegree_mul' ] <;> norm_num [ ih ];
              · grind +ring;
              · specialize ih ( m + 1 ) ; aesop;
              · have := ih m ( by linarith ) ; have := ih ( m + 1 ) ( by linarith ) ; norm_num at * ; linarith;
              · specialize ih ( m + 1 ) ; aesop;
            exact h_deg_Tm m;
          linarith;
    obtain ⟨ q, hq ⟩ := h_div ; aesop;
    have hq_const : q.leadingCoeff = 1 := by
      by_cases h : Polynomial.leadingCoeff ( Omega ( m * n ) ) = 0 <;> aesop;
      unfold Omega at h; aesop;
      exact absurd h <| Finset.prod_ne_zero_iff.mpr fun x hx => mul_ne_zero ( Polynomial.C_ne_zero.mpr <| by norm_num ) <| Polynomial.X_sub_C_ne_zero _;
    rw [ Polynomial.natDegree_mul' ] at left <;> aesop;
    · rw [ Polynomial.eq_C_of_natDegree_eq_zero left ] at hq_const ⊢ ; aesop;
    · unfold Omega at a_2 ; aesop;
      exact absurd a_2 <| Finset.prod_ne_zero_iff.mpr fun x hx => mul_ne_zero ( Polynomial.C_ne_zero.mpr <| by norm_num ) <| Polynomial.X_sub_C_ne_zero _


theorem Omega_splits (n : ℕ) : Polynomial.Splits (RingHom.id ℝ) (Omega n) := by
  -- Since Omega(n) is a product of linear factors, it splits over the reals.
  have h_splits : ∀ n : ℕ, n > 0 → Polynomial.Splits (RingHom.id ℝ) (Omega n) := by
    -- Since Omega(n) is a product of linear factors, it splits over the reals. We can use the fact that the product of linear factors splits.
    intros n hn
    have h_linear_factors : ∀ k ∈ (Finset.Ioc 0 (n / 2)).filter (fun k => n.Coprime k), Polynomial.Splits (RingHom.id ℝ) (C 2 * (Polynomial.X - C (Real.cos (2 * k * Real.pi / n)))) := by
      -- Since $C 2$ is a constant polynomial and $(X - C (Real.cos (2 * k * Real.pi / n)))$ is a linear polynomial, their product splits over the reals.
      intros k hk
      simp [Polynomial.splits_mul, Polynomial.splits_X_sub_C];
    -- Apply the fact that the product of splitting polynomials splits.
    have h_prod_splits : ∀ {S : Finset ℕ}, (∀ k ∈ S, Polynomial.Splits (RingHom.id ℝ) (C 2 * (Polynomial.X - C (Real.cos (2 * k * Real.pi / n))))) → Polynomial.Splits (RingHom.id ℝ) (∏ k ∈ S, (C 2 * (Polynomial.X - C (Real.cos (2 * k * Real.pi / n))))) := by
      exact?;
    unfold Omega; aesop;
    · -- The polynomial $X - 1$ splits over the reals because it has a single root at $1$.
      apply Polynomial.splits_X_sub_C;
    · exact h_prod_splits fun k hk => h_linear_factors k ( Finset.mem_Ioc.mp ( Finset.mem_filter.mp hk |>.1 ) |>.1 ) ( Finset.mem_Ioc.mp ( Finset.mem_filter.mp hk |>.1 ) |>.2 ) ( Finset.mem_filter.mp hk |>.2 );
  cases n <;> aesop;
  exact Polynomial.splits_one _


theorem inrtocyc' (n : ℕ) (hn : n ≥ 1) :
  Chebyshev.T ℝ n - 1 = ∏ d ∈ n.divisors, (Omega d) ^ (sigma d) := by
    exact?


theorem inrtocyc_final (n : ℕ) (hn : n ≥ 1) :
  Chebyshev.T ℝ n - 1 = ∏ d ∈ n.divisors, (Omega d) ^ (sigma d) := by
    convert inrtocyc' n hn


theorem roots_Omega_two_n_eq_neg_roots_Omega_n (n : ℕ) (hn : Odd n) (hn3 : n ≥ 3) :
  (Omega (2 * n)).roots = (Omega n).roots.map (fun x => -x) := by
    unfold Omega;
    split_ifs <;> simp_all +decide [ Nat.Coprime ];
    have h_map : Finset.filter (fun x => Nat.gcd (2 * n) x = 1) (Finset.Ioc 0 n) = Finset.image (fun x => n - 2 * x) (Finset.filter (fun x => Nat.gcd n x = 1) (Finset.Ioc 0 (n / 2))) := by
      ext ; aesop;
      · use ( n - a ) / 2;
        cases le_iff_exists_add'.mp right_1 ; aesop;
        · rcases w with ( _ | _ | w ) <;> simp_all +arith +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
          exact absurd hn ( by simpa [ parity_simps ] using right );
        · omega;
        · cases Nat.even_or_odd' w ; aesop;
          · simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
            exact right.2.symm;
          · simp_all +decide [ Nat.add_div, Nat.mul_div_assoc, Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
            grind;
        · rcases Nat.even_or_odd' w with ⟨ k, rfl | rfl ⟩ <;> rcases Nat.even_or_odd' a with ⟨ l, rfl | rfl ⟩ <;> simp_all +arith +decide [ parity_simps ];
          norm_num [ Nat.gcd_mul_left, Nat.gcd_mul_right ] at right;
      · cases hn ; omega;
      · cases le_iff_exists_add'.mp ( show 2 * w ≤ n from by linarith [ Nat.div_mul_le_self n 2 ] ) ; aesop;
        simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right, Nat.Coprime, Nat.gcd_comm ];
        simpa [ parity_simps ] using hn;
    rw [ h_map, Finset.prod_image ];
    · rw [ Polynomial.roots_prod, Polynomial.roots_prod ];
      · norm_num [ Polynomial.roots_C_mul, Polynomial.roots_X_sub_C ];
        refine' Multiset.map_congr rfl fun x hx => _;
        rw [ Nat.cast_sub ( by linarith [ Finset.mem_Ioc.mp ( Multiset.mem_filter.mp hx |>.1 ), Nat.div_mul_le_self n 2 ] ) ] ; push_cast ; ring;
        norm_num [ mul_assoc, mul_comm Real.pi _, hn.pos.ne' ];
      · exact Finset.prod_ne_zero_iff.mpr fun x hx => mul_ne_zero ( Polynomial.C_ne_zero.mpr two_ne_zero ) ( Polynomial.X_sub_C_ne_zero _ );
      · exact Finset.prod_ne_zero_iff.mpr fun x hx => mul_ne_zero ( Polynomial.C_ne_zero.mpr two_ne_zero ) ( Polynomial.X_sub_C_ne_zero _ );
    · intro x hx y hy; aesop;
      omega


theorem omegas_prop_b_div (m n : ℕ) (hm : m > 0) (hn : n > 0) :
  Omega (m * n) ∣ (Omega n).comp (Chebyshev.T ℝ m) := by
    have := omegas_prop_b m n hm hn;
    exact this.1


theorem omegas_prop_b_eq (m n : ℕ) (hm : m > 0) (hn : n > 0) (hn3 : n ≥ 3) (h_prime_div : ∀ p : ℕ, p.Prime → p ∣ m → p ∣ n) :
  Omega (m * n) = (Omega n).comp (Chebyshev.T ℝ m) := by
    exact Classical.not_not.1 fun h => absurd ( omegas_prop_b m n hm hn ) ( by aesop )


theorem coeff_sq_odd_of_odd (Q : Polynomial ℤ) (j : ℕ)
    (hj_odd : Odd (Q.coeff j)) :
    Odd ((Q ^ 2).coeff (2 * j)) := by
      -- The coefficient of $x^{2j}$ in $Q^2$ is given by the sum of the products of coefficients of $Q$ where the exponents add up to $2j$.
      have h_coeff : (Q ^ 2).coeff (2 * j) = ∑ k ∈ Finset.range (2 * j + 1), Q.coeff k * Q.coeff (2 * j - k) := by
        rw [ pow_two, Polynomial.coeff_mul ];
        rw [ Finset.Nat.sum_antidiagonal_eq_sum_range_succ fun k l => Q.coeff k * Q.coeff l ];
      -- The term $Q_j^2$ is odd, and the sum of the products of coefficients where the exponents add up to $2j$ and $k \neq j$ is even.
      have h_even_sum : Even (∑ k ∈ Finset.range (2 * j + 1) \ {j}, Q.coeff k * Q.coeff (2 * j - k)) := by
        -- Since each term in the sum is paired with another term, the total sum is even.
        have h_even_sum : ∑ k ∈ Finset.range (2 * j + 1) \ {j}, Q.coeff k * Q.coeff (2 * j - k) = 2 * ∑ k ∈ Finset.range j, Q.coeff k * Q.coeff (2 * j - k) := by
          have h_even_sum : Finset.range (2 * j + 1) \ {j} = Finset.image (fun k => k) (Finset.range j) ∪ Finset.image (fun k => 2 * j - k) (Finset.range j) := by
            ext ; aesop <;> try omega;
            exact Classical.or_iff_not_imp_left.2 fun h => ⟨ 2 * j - a, by omega, by omega ⟩;
          rw [ h_even_sum, Finset.sum_union ] <;> norm_num;
          · rw [ Finset.sum_image ] <;> norm_num [ two_mul ];
            · exact Finset.sum_congr rfl fun x hx => by rw [ tsub_tsub_cancel_of_le ( by linarith [ Finset.mem_range.mp hx ] ) ] ; ring;
            · exact fun x hx y hy hxy => by rw [ tsub_right_inj ] at hxy <;> linarith [ Set.mem_Iio.mp hx, Set.mem_Iio.mp hy ] ;
          · rw [ Finset.disjoint_right ] ; aesop ; omega;
        exact h_even_sum.symm ▸ even_two_mul _;
      simp_all +decide [ Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_range.mpr ( show j < 2 * j + 1 from by linarith ) ) ];
      simp_all +decide [ two_mul, parity_simps ]


theorem poly_square_int (P : Polynomial ℚ) (hP0 : P.eval 0 = 1 ∨ P.eval 0 = -1) (hP2 : ∀ k, (P ^ 2).coeff k ∈ Set.range (Int.cast : ℤ → ℚ)) :
  ∀ k, P.coeff k ∈ Set.range (Int.cast : ℤ → ℚ) := by
    -- By induction on $k$, we can show that all coefficients of $P$ are in $\mathbb{Z}[1/2]$.
    have h_ind : ∀ k, ∃ y : ℤ, ∃ e : ℕ, e ≥ 0 ∧ P.coeff k = y / 2^e := by
      intro k; induction' k using Nat.strong_induction_on with k ih; rcases k with ( _ | k ) <;> norm_num at *; aesop;
      · exact ⟨ 1, 0, by norm_num [ Polynomial.coeff_zero_eq_eval_zero, h ] ⟩;
      · exact ⟨ -1, 0, by norm_num [ Polynomial.coeff_zero_eq_eval_zero, h_1 ] ⟩;
      · -- By definition of polynomial multiplication, we know that the coefficient of $x^{k+1}$ in $P^2$ is given by $\sum_{i=0}^{k+1} P_i P_{k+1-i}$.
        obtain ⟨y, hy⟩ : ∃ y : ℤ, (P ^ 2).coeff (k + 1) = y := by
          simpa only [ eq_comm ] using hP2 ( k + 1 )
        generalize_proofs at *;
        have h_coeff : 2 * P.coeff (k + 1) * P.coeff 0 + ∑ i ∈ Finset.Ico 1 (k + 1), P.coeff i * P.coeff (k + 1 - i) = y := by
          rw [ ← hy, sq, Polynomial.coeff_mul ] ; aesop;
          · rw [ Finset.Nat.sum_antidiagonal_eq_sum_range_succ fun i j => P.coeff i * P.coeff j ] ; simp +decide [ Finset.sum_Ico_eq_sub _ ] ; ring;
            simp +decide [ add_comm 1, add_comm 2, Finset.sum_range_succ ] ; ring!;
          · rw [ Finset.Nat.sum_antidiagonal_eq_sum_range_succ fun i j => P.coeff i * P.coeff j ] ; norm_num [ Finset.sum_Ico_eq_sub ] ; ring;
            rw [ add_comm 1 k, add_comm 2 k, Finset.sum_range_succ ] ; aesop;
            rw [ Finset.sum_range_succ, Finset.sum_range_succ ] ; norm_num ; ring!;
        generalize_proofs at *; (
        -- By the induction hypothesis, we know that $\sum_{i=1}^{k} P_i P_{k+1-i}$ is in $\mathbb{Z}[1/2]$.
        obtain ⟨z, e, hz⟩ : ∃ z : ℤ, ∃ e : ℕ, ∑ i ∈ Finset.Ico 1 (k + 1), P.coeff i * P.coeff (k + 1 - i) = z / 2^e := by
          have h_sum : ∀ i ∈ Finset.Ico 1 (k + 1), ∃ z : ℤ, ∃ e : ℕ, P.coeff i * P.coeff (k + 1 - i) = z / 2^e := by
            intro i hi; obtain ⟨ y, e, hy ⟩ := ih i ( by linarith [ Finset.mem_Ico.mp hi ] ) ; obtain ⟨ z, f, hz ⟩ := ih ( k + 1 - i ) ( by rw [ tsub_lt_iff_left ] <;> linarith [ Finset.mem_Ico.mp hi ] ) ; exact ⟨ y * z, e + f, by push_cast [ hy, hz ] ; ring ⟩ ;
          generalize_proofs at *; (
          norm_num +zetaDelta at *;
          choose! z e h using h_sum; exact ⟨ ∑ i ∈ Finset.Ico 1 ( k + 1 ), z i * 2 ^ ( ∑ i ∈ Finset.Ico 1 ( k + 1 ), e i - e i ), ∑ i ∈ Finset.Ico 1 ( k + 1 ), e i, by push_cast [ Finset.sum_div _ _ _ ] ; exact Finset.sum_congr rfl fun i hi => by rw [ h i ( Finset.mem_Ico.mp hi |>.1 ) ( Finset.mem_Ico.mp hi |>.2 ) ] ; rw [ div_eq_div_iff ] <;> first | positivity | simp +decide [ mul_assoc, ← pow_add, Nat.sub_add_cancel ( show e i ≤ ∑ i ∈ Finset.Ico 1 ( k + 1 ), e i from Finset.single_le_sum ( fun i _ => Nat.zero_le ( e i ) ) hi ) ] ⟩ ;)
        generalize_proofs at *; (
        rcases hP0 with h | h <;> simp_all +decide [ Polynomial.coeff_zero_eq_eval_zero ];
        · -- Rearrange h_coeff to solve for P.coeff (k + 1).
          have h_rearrange : P.coeff (k + 1) = (y * 2^e - z) / 2^(e + 1) := by
            field_simp at h_coeff ⊢
            ring_nf at h_coeff ⊢
            linarith
            skip
          generalize_proofs at *; (
          exact ⟨ y * 2 ^ e - z, e + 1, by simpa using h_rearrange ⟩);
        · -- Rearrange h_coeff to solve for P.coeff (k + 1).
          have h_rearrange : P.coeff (k + 1) = (z - y * 2^e) / (2 * 2^e) := by
            field_simp at h_coeff ⊢
            generalize_proofs at *; (
            linarith)
          generalize_proofs at *; (
          exact ⟨ z - y * 2 ^ e, e + 1, by push_cast [ h_rearrange ] ; ring ⟩)));
    -- Let $e$ be the minimal non-negative integer such that $2^e P$ has integer coefficients.
    obtain ⟨e, he⟩ : ∃ e : ℕ, (∀ k, ∃ y : ℤ, P.coeff k = y / 2^e) ∧ (∀ e' < e, ¬(∀ k, ∃ y : ℤ, P.coeff k = y / 2^e')) := by
      have h_exists_e : ∃ e : ℕ, (∀ k, ∃ y : ℤ, P.coeff k = y / 2^e) := by
        choose! y e he using h_ind; use ∑ k ∈ Finset.range (P.natDegree + 1), e k; intro k; by_cases hk : k ≤ P.natDegree; aesop;
        · use y k * 2 ^ (∑ k ∈ Finset.range (P.natDegree + 1), e k - e k);
          rw [ div_eq_div_iff ] <;> first | positivity | push_cast ; ring;
          rw [ mul_assoc, ← pow_add, Nat.sub_add_cancel ( show e k ≤ ∑ x ∈ Finset.range ( 1 + P.natDegree ), e x from Finset.single_le_sum ( fun x _ => Nat.zero_le ( e x ) ) ( Finset.mem_range.mpr ( by linarith ) ) ) ];
        · use y k * 2 ^ (∑ k ∈ Finset.range (P.natDegree + 1), e k - e k);
          field_simp;
          simp +decide [ mul_comm, mul_assoc, mul_left_comm, ← pow_add, add_tsub_cancel_of_le ( show e k ≤ ∑ k ∈ Finset.range ( P.natDegree + 1 ), e k from Finset.single_le_sum ( fun a _ => Nat.zero_le ( e a ) ) ( Finset.mem_range.mpr ( Nat.lt_succ_of_le hk ) ) ) ];
        · exact ⟨ 0, by rw [ Polynomial.coeff_eq_zero_of_natDegree_lt ( not_le.mp hk ) ] ; norm_num ⟩;
      exact ⟨ Nat.find h_exists_e, Nat.find_spec h_exists_e, fun e' he' => Nat.find_min h_exists_e he' ⟩;
    by_cases he0 : e = 0 ; simp_all +decide [ Polynomial.coeff_zero_eq_eval_zero ] ; aesop;
    · simpa only [ eq_comm ] using he k;
    · simpa only [ eq_comm ] using he k;
    · -- Let $j$ be the smallest index such that $2^e P.coeff j$ is odd.
      obtain ⟨j, hj⟩ : ∃ j : ℕ, (∃ y : ℤ, P.coeff j = y / 2^e ∧ Odd y) ∧ ∀ i < j, (∃ y : ℤ, P.coeff i = y / 2^e ∧ Even y) := by
        have h_exists_j : ∃ j : ℕ, (∃ y : ℤ, P.coeff j = y / 2^e ∧ Odd y) := by
          contrapose! he;
          intro h; use e - 1; rcases e with ( _ | e ) <;> simp_all +decide [ pow_succ, div_mul_eq_div_div ] ;
          intro k; obtain ⟨ y, hy ⟩ := h k; use y / 2; simp_all +decide [ div_div, pow_succ, mul_assoc ] ;
          rw [ Int.cast_div ( even_iff_two_dvd.mp ( he k y hy ) ) ] <;> norm_num ; ring;
        obtain ⟨j, hj⟩ : ∃ j : ℕ, (∃ y : ℤ, P.coeff j = y / 2^e ∧ Odd y) ∧ ∀ i < j, ¬(∃ y : ℤ, P.coeff i = y / 2^e ∧ Odd y) := by
          exact ⟨ Nat.find h_exists_j, Nat.find_spec h_exists_j, fun i hi => Nat.find_min h_exists_j hi ⟩;
        exact ⟨ j, hj.1, fun i hi => by obtain ⟨ y, hy ⟩ := he.1 i; exact ⟨ y, hy, by_contradiction fun hi' => hj.2 i hi ⟨ y, hy, by simpa using hi' ⟩ ⟩ ⟩;
      -- Consider the coefficient of $x^{2j}$ in $P^2$.
      have h_coeff_2j : ∃ y : ℤ, (P ^ 2).coeff (2 * j) = y / 2 ^ (2 * e) ∧ Odd y := by
        -- The coefficient of $x^{2j}$ in $P^2$ is given by $\sum_{i=0}^{2j} P.coeff i * P.coeff (2j - i)$.
        have h_coeff_2j_expanded : (P ^ 2).coeff (2 * j) = P.coeff j * P.coeff j + ∑ i ∈ Finset.range j, P.coeff i * P.coeff (2 * j - i) + ∑ i ∈ Finset.range j, P.coeff (2 * j - i) * P.coeff i := by
          rw [ sq, Polynomial.coeff_mul ];
          rw [ Finset.Nat.sum_antidiagonal_eq_sum_range_succ fun i j => P.coeff i * P.coeff j ];
          rw [ show Finset.range ( 2 * j + 1 ) = Finset.range j ∪ { j } ∪ Finset.image ( fun i => 2 * j - i ) ( Finset.range j ) from ?_, Finset.sum_union, Finset.sum_union ] <;> norm_num [ Finset.sum_image, two_mul ] ; ring;
          · rw [ Finset.sum_image ] <;> norm_num [ mul_comm ];
            · exact Finset.sum_congr rfl fun x hx => by rw [ Nat.sub_sub_self ( by linarith [ Finset.mem_range.mp hx ] ) ] ; ring;
            · exact fun x hx y hy hxy => by rw [ tsub_right_inj ] at hxy <;> linarith [ hx.out, hy.out ] ;
          · exact ⟨ fun x hx => by omega, Finset.disjoint_left.mpr fun x hx₁ hx₂ => by obtain ⟨ i, hi, rfl ⟩ := Finset.mem_image.mp hx₂; norm_num at *; omega ⟩;
          · ext ; aesop <;> try omega;
            · exact Classical.or_iff_not_imp_left.2 fun h => Classical.or_iff_not_imp_left.2 fun h' => ⟨ j + j - a, by omega, by omega ⟩;
            · exact Classical.or_iff_not_imp_left.2 fun h => Classical.or_iff_not_imp_left.2 fun h' => ⟨ j + j - a, by omega, by omega ⟩;
        -- Since $P.coeff i$ is even for $i < j$, the sums $\sum_{i=0}^{j-1} P.coeff i * P.coeff (2j - i)$ and $\sum_{i=0}^{j-1} P.coeff (2j - i) * P.coeff i$ are divisible by $2^{2e-1}$.
        have h_sums_div : ∃ y : ℤ, (∑ i ∈ Finset.range j, P.coeff i * P.coeff (2 * j - i) + ∑ i ∈ Finset.range j, P.coeff (2 * j - i) * P.coeff i) = y / 2 ^ (2 * e - 1) := by
          have h_sums_div : ∀ i < j, ∃ y : ℤ, P.coeff i * P.coeff (2 * j - i) + P.coeff (2 * j - i) * P.coeff i = y / 2 ^ (2 * e - 1) := by
            intro i hi
            obtain ⟨y_i, hy_i⟩ := hj.right i hi
            obtain ⟨y_2j_i, hy_2j_i⟩ := he.left (2 * j - i);
            rcases e with ( _ | e ) <;> simp_all +decide [ Nat.mul_succ, pow_succ' ] ; ring_nf ; aesop;
            · exact ⟨ y_i * y_2j_i, by push_cast; ring ⟩;
            · exact ⟨ y_i * y_2j_i, by push_cast; ring ⟩;
          choose! y hy using h_sums_div;
          exact ⟨ ∑ i ∈ Finset.range j, y i, by push_cast; rw [ ← Finset.sum_add_distrib, Finset.sum_congr rfl fun i hi => hy i ( Finset.mem_range.mp hi ) ] ; simp +decide [ Finset.sum_div _ _ _ ] ⟩;
        obtain ⟨ y, hy ⟩ := hj.1; obtain ⟨ z, hz ⟩ := h_sums_div; use y^2 + z * 2; simp_all +decide [ pow_succ, pow_mul', mul_assoc, mul_left_comm, mul_div_mul_left ] ; ring; aesop;
        · simp_all +decide [ mul_comm j, Nat.mul_two ] ; ring_nf at * ; aesop ( simp_config := { decide := true } ) ;
          rw [ show e * 2 = e * 2 - 1 + 1 by rw [ Nat.sub_add_cancel ( Nat.one_le_iff_ne_zero.mpr ( by positivity ) ) ] ] ; norm_num [ pow_add, pow_mul', mul_assoc, mul_comm, mul_left_comm ] at * ; linarith;
        · simp_all +decide [ parity_simps ];
        · simp_all +decide [ mul_assoc, mul_comm, mul_left_comm, pow_mul', Nat.mul_two, pow_add ] ; ring_nf at * ; aesop ( simp_config := { decide := true } ) ;
          rw [ show e * 2 = e * 2 - 1 + 1 by rw [ Nat.sub_add_cancel ( Nat.one_le_iff_ne_zero.mpr ( by positivity ) ) ] ] ; norm_num [ pow_add, pow_mul ] ; ring;
        · simp_all +decide [ parity_simps ];
      -- Since $2^{2e} (P^2 - 1)_{2j}$ is divisible by 4, we have a contradiction.
      obtain ⟨y, hy⟩ := h_coeff_2j;
      have h_div4 : 4 ∣ y := by
        obtain ⟨ z, hz ⟩ := hP2 ( 2 * j ) ; aesop;
        · rw [ eq_div_iff ] at hz <;> norm_cast at * <;> aesop;
          exact dvd_mul_of_dvd_right ( pow_dvd_pow _ ( Nat.mul_le_mul_left 2 ( Nat.pos_of_ne_zero he0 ) ) ) _;
        · rw [ eq_div_iff ( by positivity ) ] at hz ; norm_cast at hz ; aesop;
          exact dvd_mul_of_dvd_right ( pow_dvd_pow _ ( Nat.mul_le_mul_left 2 ( Nat.pos_of_ne_zero he0 ) ) ) _;
      exact absurd ( hy.2 ) ( by obtain ⟨ k, rfl ⟩ := h_div4; simp +decide [ parity_simps ] )


theorem poly_in_Z_half (P : Polynomial ℚ) (hP0 : P.eval 0 = 1 ∨ P.eval 0 = -1) (hP2 : ∀ k, (P ^ 2).coeff k ∈ Set.range (Int.cast : ℤ → ℚ)) :
  ∃ e : ℕ, ∀ k, ∃ y : ℤ, P.coeff k = y / 2^e := by
    -- By polynomial_square_int', each coefficient of P is in Z[1/2].
    have h_coeff_in_Z_half : ∀ k, ∃ y : ℤ, ∃ e : ℕ, y / 2 ^ e = P.coeff k := by
      -- By induction on $k$, we can show that each coefficient of $P$ is of the form $y / 2^e$ for some integer $y$ and natural number $e$.
      have h_ind : ∀ k, ∃ y : ℤ, ∃ e : ℕ, P.coeff k = y / 2 ^ e := by
        intro k
        have h_coeff : ∃ y : ℤ, ∃ e : ℕ, P.coeff k = y / 2 ^ e := by
          have h_sum : ∃ y : ℤ, ∃ e : ℕ, P.coeff k = y / 2 ^ e := by
            have h_sum_int : ∃ y : ℤ, P.coeff k = y / 2 ^ 0 := by
              have := poly_square_int P hP0 hP2 k; aesop;
              · exact ⟨ _, h.symm ⟩;
              · exact ⟨ _, h.symm ⟩
            exact ⟨ h_sum_int.choose, 0, h_sum_int.choose_spec ⟩
          exact h_sum
        exact h_coeff;
      exact fun k => by obtain ⟨ y, e, h ⟩ := h_ind k; exact ⟨ y, e, h.symm ⟩ ;
    choose! y e he using h_coeff_in_Z_half;
    use Finset.sup (P.support) (fun k => e k);
    intro k; specialize he k; by_cases hk : k ∈ P.support <;> aesop;
    · -- Let $y = y k * 2^{sup e - e k}$.
      use y k * 2 ^ (Finset.sup (P.support) (fun k => e k) - e k);
      rw [ ← he ] ; push_cast ; rw [ div_eq_div_iff ] <;> ring <;> norm_num;
      rw [ mul_assoc, ← pow_add, Nat.sub_add_cancel ( Finset.le_sup ( f := fun k => e k ) ( by aesop ) ) ];
    · use y k * 2 ^ (P.support.sup (fun k => e k) - e k);
      rw [ ← he ] ; push_cast ; rw [ div_eq_div_iff ] <;> ring <;> norm_num;
      -- By the properties of exponents, $2^{sup e k - e k} * 2^{e k} = 2^{sup e k}$.
      rw [mul_assoc, ← pow_add, Nat.sub_add_cancel (show e k ≤ Finset.sup (P.support) (fun k => e k) from Finset.le_sup (f := fun k => e k) (by aesop))];
    · -- If $y_k = 0$, then $0 = \frac{0}{2^e}$ for any $e$.
      use 0; simp [he];
    · exact ⟨ 0, by norm_num ⟩


def IsIntPoly (P : Polynomial ℝ) : Prop :=
  ∀ k, P.coeff k ∈ Set.range (Int.cast : ℤ → ℝ)

theorem IsIntPoly_of_mul (P Q : Polynomial ℝ) (hPQ : IsIntPoly (P * Q)) (hQ : IsIntPoly Q) (hQ0 : Q.eval 0 = 1 ∨ Q.eval 0 = -1) :
  IsIntPoly P := by
    -- We proceed by induction on $k$.
    intro k
    induction' k using Nat.strong_induction_on with k ih;
    -- By definition of polynomial multiplication, we know that the coefficient of $x^k$ in $PQ$ is given by $\sum_{i=0}^k P.coeff i \cdot Q.coeff (k-i)$.
    have h_coeff : (P * Q).coeff k = ∑ i ∈ Finset.range (k + 1), P.coeff i * Q.coeff (k - i) := by
      -- By definition of polynomial multiplication, the coefficient of $x^k$ in $PQ$ is given by $\sum_{i=0}^k P.coeff i \cdot Q.coeff (k-i)$.
      rw [Polynomial.coeff_mul];
      -- By definition of antidiagonal, we can rewrite the sum as a sum over the range from 0 to k.
      simp [Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk];
    simp_all +decide [ Finset.sum_range_succ ];
    cases' hPQ k with y hy ; cases' hQ 0 with z hz ; cases' hQ k with w hw ; aesop;
    · simp_all +decide [ Polynomial.coeff_zero_eq_eval_zero ];
      -- Since $Q$ has integer coefficients and $Q(0) = 1$, we know that $\sum_{i=0}^{k-1} P.coeff i \cdot Q.coeff (k-i)$ is an integer.
      have h_sum_int : ∃ y : ℤ, (∑ i ∈ Finset.range k, P.coeff i * Q.coeff (k - i)) = y := by
        choose! y hy using ih; choose! z hz using hQ; exact ⟨ ∑ i ∈ Finset.range k, y i * z ( k - i ), by push_cast; exact Finset.sum_congr rfl fun i hi => by rw [ hy i ( Finset.mem_range.mp hi ), hz ] ⟩ ;
      exact ⟨ y - h_sum_int.choose, by push_cast; linarith [ h_sum_int.choose_spec ] ⟩;
    · simp_all +decide [ Polynomial.coeff_zero_eq_eval_zero ];
      -- By definition of polynomial multiplication, we know that the coefficient of $x^k$ in $PQ$ is given by $\sum_{i=0}^k P.coeff i \cdot Q.coeff (k-i)$. Since $Q.coeff k$ is an integer, we can isolate $P.coeff k$.
      have h_isolate : ∃ y : ℤ, (y : ℝ) = ∑ i ∈ Finset.range k, P.coeff i * Q.coeff (k - i) := by
        choose! y hy using ih;
        choose! z hz using hQ; use ∑ i ∈ Finset.range k, y i * z ( k - i ) ; aesop;
        exact Finset.sum_congr rfl fun i hi => by rw [ hy i ( Finset.mem_range.mp hi ) ] ;
      exact ⟨ -y + h_isolate.choose, by push_cast; linarith [ h_isolate.choose_spec ] ⟩


theorem coeff_div_two_of_sq_div_four (Q : Polynomial ℤ) (hQ2 : ∀ k, 4 ∣ (Q ^ 2).coeff k) :
  ∀ k, 2 ∣ Q.coeff k := by
    -- Assume there exists a coefficient in Q that is not divisible by 2. Let j be the smallest index such that Q.coeff j is odd.
    by_contra h_contra
    obtain ⟨j, hj⟩ : ∃ j, ¬(2 ∣ Q.coeff j) ∧ ∀ k < j, 2 ∣ Q.coeff k := by
      exact ⟨ Nat.find ( not_forall.mp h_contra ), Nat.find_spec ( not_forall.mp h_contra ), fun k hk => by aesop ⟩;
    -- The coefficient of $x^{2j}$ in $Q^2$ is the sum of products of coefficients from $Q$ that add up to $2j$. Since $j$ is the smallest index where $Q.coeff j$ is odd, all other terms in this sum will be even. Therefore, the coefficient of $x^{2j}$ in $Q^2$ will be odd.
    have h_coeff_2j : ¬(2 ∣ (Q ^ 2).coeff (2 * j)) := by
      norm_num [ sq, Polynomial.coeff_mul ];
      rw [ Finset.Nat.sum_antidiagonal_eq_sum_range_succ fun i j => Q.coeff i * Q.coeff j ];
      rw [ Finset.sum_int_mod, Finset.sum_eq_single j ] <;> aesop;
      · norm_num [ two_mul, Int.mul_emod, left ];
      · by_cases hb : b < j;
        · exact dvd_mul_of_dvd_left ( right _ hb ) _;
        · exact dvd_mul_of_dvd_right ( right _ ( by omega ) ) _;
      · grind;
    exact h_coeff_2j ( dvd_trans ( by norm_num ) ( hQ2 _ ) )


theorem coeff_in_Q_of_sq_in_Q (P : Polynomial ℝ) (hP0 : P.eval 0 = 1 ∨ P.eval 0 = -1) (hP2 : ∀ k, (P ^ 2).coeff k ∈ Set.range (Rat.cast : ℚ → ℝ)) :
  ∀ k, P.coeff k ∈ Set.range (Rat.cast : ℚ → ℝ) := by
    -- We proceed by induction on $k$.
    intro k
    induction' k using Nat.strong_induction_on with k ih;
    rcases k with ( _ | k );
    · rcases hP0 with ( h | h ) <;> [ exact ⟨ 1, by norm_num [ Polynomial.coeff_zero_eq_eval_zero, h ] ⟩ ; exact ⟨ -1, by norm_num [ Polynomial.coeff_zero_eq_eval_zero, h ] ⟩ ];
    · -- By definition of polynomial multiplication, the coefficient of $x^{k+1}$ in $P^2$ is given by $\sum_{i=0}^{k+1} P_i P_{k+1-i}$.
      have h_coeff : ((P ^ 2).coeff (k + 1)) = 2 * (P.coeff (k + 1)) * (P.coeff 0) + ∑ i ∈ Finset.Ico 1 (k + 1), (P.coeff i) * (P.coeff (k + 1 - i)) := by
        rw [ sq, Polynomial.coeff_mul ];
        rw [ Finset.Nat.sum_antidiagonal_eq_sum_range_succ fun i j => P.coeff i * P.coeff j ];
        rw [ Finset.sum_range_succ, Finset.sum_Ico_eq_sub _ ] <;> norm_num ; ring;
      cases hP0 <;> simp_all +decide [ Polynomial.coeff_zero_eq_eval_zero ];
      · -- By the induction hypothesis, all coefficients of $P$ up to $k$ are rational.
        have h_ind_hyp : ∃ y : ℚ, (y : ℝ) = ∑ i ∈ Finset.Ico 1 (k + 1), (P.coeff i) * (P.coeff (k + 1 - i)) := by
          choose! y hy using ih;
          exact ⟨ ∑ i ∈ Finset.Ico 1 ( k + 1 ), y i * y ( k + 1 - i ), by push_cast; exact Finset.sum_congr rfl fun i hi => by rw [ hy i ( by linarith [ Finset.mem_Ico.mp hi ] ), hy ( k + 1 - i ) ( by rw [ tsub_lt_iff_left ] <;> linarith [ Finset.mem_Ico.mp hi ] ) ] ⟩;
        obtain ⟨ y, hy ⟩ := hP2 ( k + 1 ) ; obtain ⟨ z, hz ⟩ := h_ind_hyp; exact ⟨ ( y - z ) / 2, by push_cast; linarith ⟩ ;
      · -- By the induction hypothesis, the sum $\sum_{i=1}^{k} P_i P_{k+1-i}$ is rational.
        have h_sum_rational : ∃ y : ℚ, (y : ℝ) = ∑ i ∈ Finset.Ico 1 (k + 1), (P.coeff i) * (P.coeff (k + 1 - i)) := by
          choose! y hy using ih;
          exact ⟨ ∑ i ∈ Finset.Ico 1 ( k + 1 ), y i * y ( k + 1 - i ), by push_cast; exact Finset.sum_congr rfl fun i hi => by rw [ hy i ( by linarith [ Finset.mem_Ico.mp hi ] ), hy ( k + 1 - i ) ( by rw [ tsub_lt_iff_left ] <;> linarith [ Finset.mem_Ico.mp hi ] ) ] ⟩;
        obtain ⟨ y, hy ⟩ := hP2 ( k + 1 ) ; obtain ⟨ z, hz ⟩ := h_sum_rational; exact ⟨ ( -y + z ) / 2, by push_cast; linarith ⟩ ;



/-
Checking if IsIntPoly is already defined.
-/
#check IsIntPoly

/-
T_n - 1 has integer coefficients.
-/
lemma IsIntPoly_Tn (n : ℕ) : IsIntPoly (Chebyshev.T ℝ n - 1) := by
  -- The Chebyshev polynomials T_n have integer coefficients by definition.
  have h_T_int : ∀ n : ℕ, IsIntPoly (Chebyshev.T ℝ n) := by
    -- We can prove this by induction on $n$.
    intro n
    induction' n using Nat.strong_induction_on with n ih;
    rcases n with ( _ | _ | n ) <;> simp_all +decide [ Chebyshev.T ];
    · exact fun k => by erw [ Polynomial.coeff_one ] ; aesop;
    · exact fun k => by rw [ Polynomial.coeff_X ] ; aesop;
    · -- By the induction hypothesis, $T_{n+1}$ and $T_n$ have integer coefficients.
      have h_ind : IsIntPoly (Chebyshev.T ℝ (n + 1)) ∧ IsIntPoly (Chebyshev.T ℝ n) := by
        exact ⟨ ih _ <| Nat.lt_succ_self _, ih _ <| Nat.lt_succ_of_lt <| Nat.lt_succ_self _ ⟩;
      -- Since $2X$ is a polynomial with integer coefficients and $Chebyshev.T ℝ (n + 1)$ has integer coefficients, their product $2X * Chebyshev.T ℝ (n + 1)$ also has integer coefficients.
      have h_prod : IsIntPoly (2 * Polynomial.X * Chebyshev.T ℝ (n + 1)) := by
        intro k; specialize h_ind; aesop;
        rcases k with ( _ | k ) <;> simp_all +decide [ mul_assoc, Polynomial.coeff_eq_zero_of_natDegree_lt ];
        obtain ⟨ y, hy ⟩ := left k; exact ⟨ 2 * y, by push_cast; linarith ⟩ ;
      exact fun k => by simpa [ add_assoc ] using h_prod k |> fun ⟨ x, hx ⟩ => h_ind.2 k |> fun ⟨ y, hy ⟩ => ⟨ x - y, by simpa [ hx, hy, sub_mul ] ⟩ ;
  intro i; specialize h_T_int n i; aesop;
  exact ⟨ w - if i = 0 then 1 else 0, by erw [ Polynomial.coeff_one ] ; aesop ⟩

/-
Product of integer polynomials is an integer polynomial.
-/
lemma IsIntPoly_prod {ι : Type*} (s : Finset ι) (f : ι → Polynomial ℝ) (h : ∀ i ∈ s, IsIntPoly (f i)) : IsIntPoly (∏ i ∈ s, f i) := by
  induction' s using Finset.induction with i s hi ih;
  · exact fun k => ⟨ if k = 0 then 1 else 0, by erw [ Polynomial.coeff_one ] ; aesop ⟩;
  · -- The product of two integer polynomials is an integer polynomial.
    have h_prod_int : ∀ (P Q : Polynomial ℝ), IsIntPoly P → IsIntPoly Q → IsIntPoly (P * Q) := by
      intro P Q hP hQ k; rw [ Polynomial.coeff_mul ] ; aesop;
      choose! y hy using hP; choose! z hz using hQ; use ∑ x ∈ Finset.antidiagonal k, y x.1 * z x.2; aesop;
    simpa only [ Finset.prod_insert hi ] using h_prod_int _ _ ( h i ( Finset.mem_insert_self _ _ ) ) ( ih fun j hj => h j ( Finset.mem_insert_of_mem hj ) )

/-
Checking IsIntPoly_of_mul.
-/
#check IsIntPoly_of_mul

/-
Power of integer polynomial is integer polynomial.
-/
lemma IsIntPoly_pow (P : Polynomial ℝ) (n : ℕ) (h : IsIntPoly P) : IsIntPoly (P ^ n) := by
  induction' n with n ih;
  · -- For any k, the coefficient of 1 at position k is 1 if k=0 and 0 otherwise. Both 1 and 0 are integers.
    intro k
    use if k = 0 then 1 else 0
    simp [Polynomial.coeff_one];
  · exact IsIntPoly_prod { 0, 1 } ( fun i => if i = 0 then P ^ n else P ) ( by aesop ) |> fun h => by simpa [ pow_succ ] using h;

/-
Difference of integer polynomials is an integer polynomial.
-/
lemma IsIntPoly_sub (P Q : Polynomial ℝ) (hP : IsIntPoly P) (hQ : IsIntPoly Q) : IsIntPoly (P - Q) := by
  -- By definition of IsIntPoly, we know that every coefficient of P and Q is an integer.
  intro k
  simp [IsIntPoly] at *;
  obtain ⟨ y, hy ⟩ := hP k; obtain ⟨ z, hz ⟩ := hQ k; exact ⟨ y - z, by push_cast; linear_combination hy - hz ⟩ ;

/-
Monomial with integer coefficient is an integer polynomial.
-/
lemma IsIntPoly_C_mul_X_pow (z : ℤ) (n : ℕ) : IsIntPoly (Polynomial.C (z : ℝ) * Polynomial.X ^ n) := by
  intro k; by_cases h : n = k <;> aesop;

/-
Sum of integer polynomials is an integer polynomial.
-/
lemma IsIntPoly_add (P Q : Polynomial ℝ) (hP : IsIntPoly P) (hQ : IsIntPoly Q) : IsIntPoly (P + Q) := by
  -- By definition of IsIntPoly, we know that for any k, the coefficients of P and Q at k are integers.
  intro k
  obtain ⟨zP, hzP⟩ := hP k
  obtain ⟨zQ, hzQ⟩ := hQ k
  use zP + zQ
  simp [hzP, hzQ]

/-
If Q minus an integer monomial is an integer polynomial, then Q is an integer polynomial.
-/
lemma IsIntPoly_of_sub_int_monomial (Q : Polynomial ℝ) (z : ℤ) (n : ℕ) (h : IsIntPoly (Q - Polynomial.C (z : ℝ) * Polynomial.X ^ n)) : IsIntPoly Q := by
  -- Since $Q - C z * X^n$ is an integer polynomial and $C z * X^n$ is also an integer polynomial, their sum $Q$ must be an integer polynomial.
  have hQ : IsIntPoly (Q - Polynomial.C (z : ℝ) * Polynomial.X ^ n + Polynomial.C (z : ℝ) * Polynomial.X ^ n) := by
    -- Apply the lemma that the sum of two integer polynomials is an integer polynomial.
    apply IsIntPoly_add; assumption; exact IsIntPoly_C_mul_X_pow z n;
  -- Since $Q - C z * X^n + C z * X^n = Q$, we can conclude that $Q$ is an integer polynomial.
  convert hQ using 1
  simp

/-
Auxiliary polynomials C_n.
-/
noncomputable def C_poly (n : ℕ) : Polynomial ℝ :=
  2 * (Chebyshev.T ℝ n).comp (Polynomial.C (1/2) * Polynomial.X)

/-
Base case C_0 = 2.
-/
lemma C_poly_zero : C_poly 0 = 2 := by
  -- By definition of $C_poly$, we have $C_poly 0 = 2 * (Chebyshev.T ℝ 0).comp (Polynomial.C (1/2) * Polynomial.X)$.
  simp [C_poly]

/-
Base case C_1 = X.
-/
lemma C_poly_one : C_poly 1 = Polynomial.X := by
  -- By definition of $C_poly$, we have $C_poly 1 = 2 * (Chebyshev.T ℝ 1).comp (Polynomial.C (1/2) * Polynomial.X)$.
  simp [C_poly];
  exact Polynomial.funext fun x => by norm_num; ring;

/-
Recurrence for C_poly.
-/
lemma C_poly_recurrence (n : ℕ) : C_poly (n + 2) = Polynomial.X * C_poly (n + 1) - C_poly n := by
  -- By definition of $C_poly$, we know that $C_poly (n + 2) = 2 * T_{n + 2}((1/2) * X)$.
  have hC_poly_def : ∀ n, C_poly n = 2 * (Chebyshev.T ℝ n).comp (Polynomial.C (1/2) * Polynomial.X) := by
    exact?;
  norm_num [ hC_poly_def ];
  exact Polynomial.funext fun x => by norm_num; ring;

/-
C_n is monic for n >= 1.
-/
lemma C_poly_monic (n : ℕ) (hn : n ≥ 1) : (C_poly n).Monic := by
  induction' n using Nat.strong_induction_on with n ih;
  rcases n with ( _ | _ | n ) <;> simp_all +decide [ Polynomial.Monic ];
  · -- By definition, $C_1(x) = 2T_1(x/2) = 2(x/2) = x$, which is monic.
    simp [C_poly_one];
  · erw [ C_poly_recurrence, Polynomial.leadingCoeff_sub_of_degree_lt ] <;> norm_num [ ih ];
    -- By definition of $C_poly$, we know that its degree is $n$.
    have h_deg_C_poly : ∀ n, Polynomial.degree (C_poly n) = n := by
      intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Polynomial.degree_add_eq_left_of_degree_lt, Polynomial.degree_sub_eq_left_of_degree_lt ] ;
      · erw [ show C_poly 0 = 2 by exact C_poly_zero ] ; erw [ Polynomial.degree_C ] ; norm_num;
      · exact C_poly_one.symm ▸ Polynomial.degree_X;
      · erw [ show C_poly ( n + 2 ) = Polynomial.X * C_poly ( n + 1 ) - C_poly n from ?_, Polynomial.degree_sub_eq_left_of_degree_lt ] <;> norm_num [ ih ];
        · ring;
        · rw [ ih ] <;> norm_cast <;> linarith;
        · exact?;
    rw [ h_deg_C_poly, h_deg_C_poly ] ; norm_cast ; simp +arith +decide

/-
C_n has integer coefficients.
-/
lemma C_poly_int (n : ℕ) : IsIntPoly (C_poly n) := by
  induction' n using Nat.strong_induction_on with n ih;
  -- For the inductive step, if n is greater than 1, we can use the recurrence relation C_poly (n+2) = X * C_poly (n+1) - C_poly n.
  by_cases hn : n < 2;
  · -- For the base cases $n = 0$ and $n = 1$, we can verify directly that $C_poly n$ is an integer polynomial.
    interval_cases n <;> simp [C_poly_zero, C_poly_one];
    · exact fun k => ⟨ if k = 0 then 2 else 0, by erw [ Polynomial.coeff_C ] ; aesop ⟩;
    · intro k; erw [ Polynomial.coeff_X ] ; aesop;
  · -- For the inductive step, assume that C_poly (n-1) and C_poly (n-2) are integer polynomials.
    have h_ind : IsIntPoly (C_poly (n - 1)) ∧ IsIntPoly (C_poly (n - 2)) := by
      exact ⟨ ih _ ( Nat.sub_lt ( by linarith ) ( by linarith ) ), ih _ ( Nat.sub_lt ( by linarith ) ( by linarith ) ) ⟩;
    -- Using the recurrence relation, we can express C_poly n as X * C_poly (n-1) - C_poly (n-2).
    have h_recurrence : C_poly n = Polynomial.X * C_poly (n - 1) - C_poly (n - 2) := by
      rcases n with ( _ | _ | n ) <;> aesop;
      -- By the recurrence relation, we have C_poly (n + 2) = X * C_poly (n + 1) - C_poly n.
      apply C_poly_recurrence;
    rw [h_recurrence];
    exact IsIntPoly_sub _ _ ( by exact fun k => by rcases k with ( _ | k ) <;> aesop ) h_ind.2

/-
Relation between Omega and Psi for n >= 2.
-/
noncomputable def Psi (n : ℕ) : Polynomial ℝ :=
  Finset.prod ((Finset.Ioc 0 (n / 2)).filter (fun k => n.Coprime k))
    (fun k => X - C (2 * Real.cos (2 * k * Real.pi / n)))

lemma Omega_eq_Psi_comp (n : ℕ) (hn : n ≥ 2) : Omega n = (Psi n).comp (2 * X) := by
  unfold Omega Psi; aesop;
  induction Finset.filter ( fun k => n.Coprime k ) ( Finset.Ioc 0 ( n / 2 ) ) using Finset.induction <;> aesop;
  exact Or.inl <| Polynomial.funext fun x => by norm_num; ring;

/-
Psi n is monic.
-/
lemma Psi_monic (n : ℕ) (hn : n ≥ 1) : (Psi n).Monic := by
  exact Polynomial.monic_prod_of_monic _ _ fun x hx => Polynomial.monic_X_sub_C _

/-
Quotient of integer polynomial by monic integer polynomial is an integer polynomial.
-/
lemma IsIntPoly_div_by_monic (P Q : Polynomial ℝ) (hP : IsIntPoly P) (hQ : IsIntPoly Q) (hQ_monic : Q.Monic) (h_div : Q ∣ P) : IsIntPoly (P / Q) := by
  -- Let's express P and Q in terms of their integer coefficients.
  obtain ⟨P_int, hP_int⟩ : ∃ P_int : Polynomial ℤ, P = Polynomial.map (Int.castRingHom ℝ) P_int := by
    choose! f hf using hP;
    use ∑ k ∈ P.support, f k • Polynomial.X ^ k; ext k; aesop;
  obtain ⟨Q_int, hQ_int⟩ : ∃ Q_int : Polynomial ℤ, Q = Polynomial.map (Int.castRingHom ℝ) Q_int := by
    choose! f hf using hQ;
    use ∑ k ∈ Q.support, f k • Polynomial.X ^ k; aesop;
  -- Since $Q$ divides $P$, there exists a polynomial $S$ with integer coefficients such that $P = Q * S$.
  obtain ⟨S, hS⟩ : ∃ S : Polynomial ℤ, P_int = Q_int * S := by
    have h_div_int : Q_int ∣ P_int := by
      have h_div_int : map (Int.castRingHom ℝ) Q_int ∣ map (Int.castRingHom ℝ) P_int := by
        aesop
      rw [ ← Polynomial.map_dvd_map ( Int.castRingHom ℝ ) ] <;> aesop;
      · exact Int.cast_injective;
      · rw [ Polynomial.Monic, Polynomial.leadingCoeff_map_of_leadingCoeff_ne_zero ] at hQ_monic <;> aesop;
    exact h_div_int;
  cases eq_or_ne Q 0 <;> aesop;
  · rw [ eq_comm ] at hQ_int ; aesop;
  · intro k; specialize hP k; aesop;

/-
Correct definition of Psi_mod.
-/
noncomputable def Psi_mod (n : ℕ) : Polynomial ℝ :=
  if n = 1 then Polynomial.X - 2
  else Finset.prod ((Finset.Ioc 0 (n / 2)).filter (fun k => n.Coprime k))
    (fun k => Polynomial.X - Polynomial.C (2 * Real.cos (2 * k * Real.pi / n)))

/-
Psi_mod is monic.
-/
lemma Psi_mod_monic (n : ℕ) (hn : n ≥ 1) : (Psi_mod n).Monic := by
  unfold Psi_mod;
  rcases n with ( _ | _ | n ) <;> simp_all +decide [ Polynomial.Monic, Polynomial.leadingCoeff_prod ];
  · erw [ Polynomial.leadingCoeff_X_sub_C ];
  · rw [ Finset.prod_eq_one ] ; intros ; aesop;
    rw [ Polynomial.leadingCoeff_sub_of_degree_lt ] <;> norm_num;
    exact lt_of_le_of_lt Polynomial.degree_C_le ( by norm_num )

/-
Product formula for C_n - 2 using Psi_mod.
-/
lemma C_poly_sub_two_eq_prod_Psi_mod_pow_sigma (n : ℕ) (hn : n ≥ 1) :
    C_poly n - 2 = ∏ d ∈ n.divisors, (Psi_mod d) ^ (sigma d) := by
      -- By definition of $C_poly$, we know that $C_poly n - 2 = 2 * (T_n(X/2) - 1)$.
      have hC_poly : C_poly n - 2 = 2 * (Chebyshev.T ℝ n).comp (Polynomial.C (1/2) * Polynomial.X) - 2 := by
        bound;
      refine' Polynomial.funext fun x => _;
      have := @inrtocyc n hn;
      replace this := congr_arg ( Polynomial.eval ( x / 2 ) ) this ; aesop;
      convert congr_arg ( · * 2 ) this using 1 <;> ring;
      unfold Omega Psi_mod; norm_num [ Polynomial.eval_prod ] ; ring;
      rw [ Finset.prod_eq_prod_diff_singleton_mul <| Nat.one_mem_divisors.mpr <| by linarith ] ; norm_num ; ring;
      rw [ Finset.prod_eq_prod_diff_singleton_mul <| Nat.one_mem_divisors.mpr <| by linarith ] ; norm_num [ sigma ] ; ring;
      rw [ Finset.prod_congr rfl ] ; aesop ; ring;
      intro d hd; split_ifs <;> simp_all +decide [ Polynomial.eval_prod ] ;
      · field_simp;
      · exact congr_arg ( · ^ 2 ) ( Finset.prod_congr rfl fun _ _ => by ring )

/-
Product formula for C_n - 2 using Psi_mod.
-/
lemma C_poly_prod_formula (n : ℕ) (hn : n ≥ 1) :
    C_poly n - 2 = ∏ d ∈ n.divisors, (Psi_mod d) ^ (sigma d) := by
      exact?

/-
Product formula for C_n - 2 using Psi_mod.
-/
lemma C_poly_prod_formula' (n : ℕ) (hn : n ≥ 1) :
    C_poly n - 2 = ∏ d ∈ n.divisors, (Psi_mod d) ^ (sigma d) := by
      exact?

/-
Product formula for C_n - 2 using Psi_mod.
-/
lemma C_poly_prod_formula_Psi_mod (n : ℕ) (hn : n ≥ 1) :
    C_poly n - 2 = ∏ d ∈ n.divisors, (Psi_mod d) ^ (sigma d) := by
      exact?

/-
Product formula for C_n - 2 using Psi_mod.
-/
lemma C_poly_prod_formula_v2 (n : ℕ) (hn : n ≥ 1) :
    C_poly n - 2 = ∏ d ∈ n.divisors, (Psi_mod d) ^ (sigma d) := by
      exact?

/-
Relation between Omega composed with X/2 and Psi_mod.
-/
lemma Omega_comp_half_eq_Psi_mod (d : ℕ) (hd : d ≥ 1) :
    (Omega d).comp (Polynomial.C (1/2) * Polynomial.X) * (if d = 1 then Polynomial.C 2 else 1) = Psi_mod d := by
      unfold Omega Psi_mod; aesop;
      · exact Polynomial.funext fun x => by norm_num; ring;
      · induction ( Finset.filter ( fun k => Nat.Coprime d k ) ( Finset.Ioc 0 ( d / 2 ) ) : Finset ℕ ) using Finset.induction <;> aesop;
        exact Or.inl <| Polynomial.funext fun x => by norm_num; ring;

/-
Product formula for C_n - 2 using Psi_mod.
-/
lemma C_poly_prod_formula_v3 (n : ℕ) (hn : n ≥ 1) :
    C_poly n - 2 = ∏ d ∈ n.divisors, (Psi_mod d) ^ (sigma d) := by
      exact?

/-
Product formula for C_n - 2 using Psi_mod.
-/
lemma C_poly_prod_formula_v4 (n : ℕ) (hn : n ≥ 1) :
    C_poly n - 2 = ∏ d ∈ n.divisors, (Psi_mod d) ^ (sigma d) := by
      -- Apply the lemma C_poly_prod_formula_v3 to conclude the proof.
      apply C_poly_prod_formula_v3 n hn

/-
Product formula for C_n - 2 using Psi_mod.
-/
lemma C_poly_prod_formula_v5 (n : ℕ) (hn : n ≥ 1) :
    C_poly n - 2 = ∏ d ∈ n.divisors, (Psi_mod d) ^ (sigma d) := by
      exact?

/-
If P is monic and P^2 is rational, then P is rational.
-/
def IsRatPoly (P : Polynomial ℝ) : Prop :=
  ∀ k, P.coeff k ∈ Set.range (Rat.cast : ℚ → ℝ)

lemma IsRatPoly_of_sq_monic (P : Polynomial ℝ) (hP : P.Monic) (hP2 : IsRatPoly (P ^ 2)) : IsRatPoly P := by
  -- Assume that for some $k < \text{deg}(P)$, the coefficients $a_{\text{deg}(P)}, a_{\text{deg}(P)-1}, \ldots, a_{k+1}$ are all rational.
  have h_ind : ∀ k < P.natDegree, (∀ j > k, P.coeff j ∈ Set.range (Rat.cast : ℚ → ℝ)) → P.coeff k ∈ Set.range (Rat.cast : ℚ → ℝ) := by
    intros k hk h_ind_hyp
    have h_coeff : (P ^ 2).coeff (P.natDegree + k) = 2 * P.coeff (P.natDegree) * P.coeff k + ∑ j ∈ Finset.Ico (k + 1) (P.natDegree), P.coeff j * P.coeff (P.natDegree + k - j) := by
      have h_coeff : (P ^ 2).coeff (P.natDegree + k) = ∑ j ∈ Finset.range (P.natDegree + k + 1), P.coeff j * P.coeff (P.natDegree + k - j) := by
        rw [ sq, Polynomial.coeff_mul ];
        rw [ Finset.Nat.sum_antidiagonal_eq_sum_range_succ fun i j => P.coeff i * P.coeff j ];
      -- Split the sum into three parts: j < k, j = k, and j > k.
      have h_split : ∑ j ∈ Finset.range (P.natDegree + k + 1), P.coeff j * P.coeff (P.natDegree + k - j) = (∑ j ∈ Finset.range (k + 1), P.coeff j * P.coeff (P.natDegree + k - j)) + (∑ j ∈ Finset.Ico (k + 1) (P.natDegree), P.coeff j * P.coeff (P.natDegree + k - j)) + (∑ j ∈ Finset.Ico (P.natDegree) (P.natDegree + k + 1), P.coeff j * P.coeff (P.natDegree + k - j)) := by
        rw [ Finset.sum_range_add_sum_Ico, Finset.sum_range_add_sum_Ico ] <;> linarith;
      simp_all +decide [ Finset.sum_Ico_eq_sum_range, two_mul ];
      norm_num [ add_assoc, Nat.add_sub_assoc ( by linarith : k ≤ P.natDegree ) ];
      rw [ Finset.sum_eq_single k ] <;> norm_num;
      · simp +decide [ add_comm, add_left_comm, add_assoc, hP.leadingCoeff, Finset.sum_range_succ' ];
        exact Finset.sum_eq_zero fun i hi => by rw [ Polynomial.coeff_eq_zero_of_natDegree_lt ( by linarith [ Finset.mem_range.mp hi ] ) ] ; ring;
      · exact fun j hj₁ hj₂ => Or.inr <| Polynomial.coeff_eq_zero_of_natDegree_lt <| by omega;
    obtain ⟨ q, hq ⟩ := hP2 ( P.natDegree + k );
    -- Since the sum of rational numbers is rational, we can conclude that $2 * P.coeff k$ is rational.
    have h_sum_rational : ∃ r : ℚ, ∑ j ∈ Finset.Ico (k + 1) P.natDegree, P.coeff j * P.coeff (P.natDegree + k - j) = r := by
      choose! r hr using h_ind_hyp;
      use ∑ j ∈ Finset.Ico (k + 1) P.natDegree, r j * r (P.natDegree + k - j);
      push_cast;
      exact Finset.sum_congr rfl fun x hx => by rw [ hr x ( by linarith [ Finset.mem_Ico.mp hx ] ), hr ( P.natDegree + k - x ) ( by rw [ gt_iff_lt ] ; rw [ lt_tsub_iff_left ] ; linarith [ Finset.mem_Ico.mp hx ] ) ] ;
    aesop;
    exact ⟨ ( q - w ) / 2, by push_cast; linarith ⟩;
  intro k;
  -- Apply induction on the degree of $P$.
  induction' h : P.natDegree - k using Nat.strong_induction_on with k ih generalizing k;
  by_cases hk : k < P.natDegree;
  · exact h_ind k hk fun j hj => ih _ ( by omega ) _ rfl;
  · cases eq_or_lt_of_le ( le_of_not_gt hk ) <;> aesop;
    · exact ⟨ 1, by norm_num ⟩;
    · rw [ Polynomial.coeff_eq_zero_of_natDegree_lt h_1 ] ; exact ⟨ 0, by norm_num ⟩

/-
If a monic polynomial $P$ has the property that $P^2$ has integer coefficients, then $P$ has integer coefficients.
-/
lemma IsIntPoly_of_sq_monic (P : Polynomial ℝ) (hP : P.Monic) (hP2 : IsIntPoly (P ^ 2)) : IsIntPoly P := by
  -- Since P is monic, its leading coefficient is 1. Therefore, the leading coefficient of P^2 is 1^2 = 1, which is an integer.
  have h_leading_coeff : ∀ k, (P ^ 2).coeff k ∈ Set.range (Int.cast : ℤ → ℝ) := by
    exact?;
  -- Since P is monic, we can write P = Q / d where Q is a polynomial with integer coefficients and d is a positive integer.
  obtain ⟨Q, d, hQ, hd⟩ : ∃ Q : Polynomial ℤ, ∃ d : ℕ, d > 0 ∧ P = Polynomial.map (algebraMap ℤ ℝ) Q / Polynomial.C (d : ℝ) := by
    -- By definition of rational polynomials, we can write P as a ratio of two polynomials with integer coefficients.
    obtain ⟨Q, d, hd⟩ : ∃ Q : Polynomial ℤ, ∃ d : ℕ, d > 0 ∧ P = Polynomial.map (algebraMap ℤ ℝ) Q / Polynomial.C (d : ℝ) := by
      have h_rat : ∃ Q : Polynomial ℚ, P = Polynomial.map (algebraMap ℚ ℝ) Q := by
        have h_rational : ∀ k, P.coeff k ∈ Set.range (Rat.cast : ℚ → ℝ) := by
          have h_rational_coeffs : IsRatPoly P := by
            -- Since P is monic and P^2 has integer coefficients, each coefficient of P^2 is an integer. This implies that the coefficients of P must be rational because they are solutions to equations with integer coefficients.
            have hP_rational : ∀ k, (P ^ 2).coeff k ∈ Set.range (Rat.cast : ℚ → ℝ) := by
              exact fun k => by obtain ⟨ z, hz ⟩ := h_leading_coeff k; exact ⟨ z, by simpa using hz ⟩ ;
            exact?;
          exact h_rational_coeffs;
        choose! Q hQ using h_rational; use ∑ k ∈ P.support, Q k • Polynomial.X ^ k; aesop;
      obtain ⟨Q, hQ⟩ := h_rat
      obtain ⟨d, hd⟩ : ∃ d : ℕ, d > 0 ∧ ∀ k, Q.coeff k * d ∈ Set.range (Int.cast : ℤ → ℚ) := by
        -- Let $d$ be the least common multiple of the denominators of the coefficients of $Q$.
        obtain ⟨d, hd⟩ : ∃ d : ℕ, d > 0 ∧ ∀ k, (Q.coeff k).den ∣ d := by
          exact ⟨ ∏ k ∈ Q.support, ( Q.coeff k |> Rat.den ), Finset.prod_pos fun k hk => Nat.cast_pos.mpr ( Rat.pos _ ), fun k => if hk : k ∈ Q.support then Finset.dvd_prod_of_mem _ hk else by aesop ⟩;
        use d;
        aesop;
        have := right k; obtain ⟨ y, hy ⟩ := this; use y * ( Q.coeff k |> Rat.num ) ; simp +decide [ *, Rat.cast_def, mul_comm, mul_assoc, mul_left_comm ] ;
      choose! f hf using hd.2;
      refine' ⟨ ∑ k ∈ Q.support, f k • Polynomial.X ^ k, d, hd.1, _ ⟩ ; simp_all +decide [ Polynomial.div_def ];
      erw [ ← Polynomial.C_mul ] ; erw [ Polynomial.leadingCoeff_C ] ; by_cases hd : d = 0 <;> aesop;
      ext; simp +decide [ hf, Polynomial.coeff_sum, Polynomial.coeff_C_mul ] ; ring; aesop;
      rw [ inv_mul_eq_div, eq_div_iff ] <;> norm_cast at * ; aesop;
    use Q, d;
  -- Since P^2 has integer coefficients, d^2 divides Q^2.
  have h_div : Polynomial.C (d ^ 2 : ℤ) ∣ Q ^ 2 := by
    -- Since $P^2$ has integer coefficients, each coefficient of $Q^2 / d^2$ must be an integer. Therefore, $Q^2$ must be divisible by $d^2$.
    have h_div : ∀ k, (Q ^ 2).coeff k % (d ^ 2 : ℤ) = 0 := by
      intro k; specialize h_leading_coeff k; aesop;
      rw [ Polynomial.div_def ] at h;
      erw [ ← Polynomial.C_mul ] at h ; erw [ Polynomial.leadingCoeff_C ] at h ; by_cases hd : d = 0 <;> aesop;
      simp_all +decide [ sq, mul_assoc, Polynomial.coeff_mul ];
      simp_all +decide [ Polynomial.coeff_C, Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk ];
      field_simp at h;
      exact ⟨ w, by rw [ ← @Int.cast_inj ℝ ] ; push_cast; rw [ ← Finset.sum_div _ _ _ ] at *; rw [ eq_div_iff ( by positivity ) ] at *; linarith ⟩;
    rw [ Polynomial.C_dvd_iff_dvd_coeff ] ; aesop;
  -- Since $d^2$ divides $Q^2$, it follows that $d$ divides $Q$.
  have h_div_Q : Polynomial.C (d : ℤ) ∣ Q := by
    aesop;
  -- Since $C(d)$ divides $Q$, we can write $Q = C(d) * R$ for some polynomial $R$ with integer coefficients.
  obtain ⟨R, hR⟩ : ∃ R : Polynomial ℤ, Q = Polynomial.C (d : ℤ) * R := by
    exact h_div_Q;
  simp_all +decide [ sq, mul_assoc, Polynomial.div_def ];
  erw [ ← Polynomial.C_mul ] ; erw [ Polynomial.leadingCoeff_C ] ; by_cases hd : d = 0 <;> aesop;
  intro k; specialize h_leading_coeff k; aesop;

/-
The polynomial $\Psi_{mod}(n)$ has integer coefficients.
-/
lemma Psi_mod_integral (n : ℕ) (hn : n ≥ 1) : IsIntPoly (Psi_mod n) := by
  -- We use strong induction on $n$.
  induction' n using Nat.strong_induction_on with n ih;
  -- Let $P = C_n - 2$. $P$ is an integer polynomial (by `C_poly_int`).
  set P : Polynomial ℝ := C_poly n - 2
  have hP : IsIntPoly P := by
    apply_rules [ IsIntPoly_sub, C_poly_int ];
    exact fun k => ⟨ if k = 0 then 2 else 0, by erw [ Polynomial.coeff_C ] ; aesop ⟩;
  -- Let $Q = \prod_{d|n, d<n} \Psi_{mod}(d)^{\sigma(d)}$.
  set Q : Polynomial ℝ := ∏ d ∈ Nat.divisors n \ {n}, (Psi_mod d) ^ (sigma d);
  -- By induction hypothesis, for $d < n$, $\Psi_{mod}(d)$ is an integer polynomial.
  have hQ : IsIntPoly Q := by
    -- Since each $\Psi_{mod}(d)$ is an integer polynomial by the induction hypothesis, and the product of integer polynomials is an integer polynomial, $Q$ is an integer polynomial.
    have hQ_int : ∀ d ∈ Nat.divisors n \ {n}, IsIntPoly (Psi_mod d ^ (sigma d)) := by
      aesop;
      exact IsIntPoly_pow _ _ ( ih d ( lt_of_le_of_ne ( Nat.le_of_dvd hn left ) right ) ( Nat.pos_of_dvd_of_pos left hn ) );
    convert IsIntPoly_prod _ _ hQ_int using 1;
  -- Since $P = Q \cdot \Psi_{mod}(n)^{\sigma(n)}$ and $P$ and $Q$ are integer polynomials, $\Psi_{mod}(n)^{\sigma(n)}$ must also be an integer polynomial.
  have hPsi_mod_pow : IsIntPoly (Psi_mod n ^ (sigma n)) := by
    have hPsi_mod_pow : P = Q * (Psi_mod n) ^ (sigma n) := by
      have := C_poly_prod_formula_v5 n hn; aesop;
      rw [ Finset.prod_eq_prod_diff_singleton_mul <| Nat.mem_divisors_self _ <| by linarith ];
    -- Since $Q$ is monic and divides $P$, the quotient $R = \Psi_{mod}(n)^{\sigma(n)}$ is an integer polynomial.
    have hR : IsIntPoly (P / Q) := by
      apply IsIntPoly_div_by_monic;
      · exact hP;
      · assumption;
      · rw [ Polynomial.Monic, Polynomial.leadingCoeff_prod ];
        refine' Finset.prod_eq_one _;
        aesop;
        rw [ Psi_mod_monic x ( Nat.pos_of_dvd_of_pos left hn ) |> Polynomial.Monic.leadingCoeff, one_pow ];
      · exact hPsi_mod_pow.symm ▸ dvd_mul_right _ _;
    by_cases hQ : Q = 0 <;> aesop;
    rw [ Finset.prod_eq_zero_iff ] at hQ ; aesop;
    unfold Psi_mod at * ; aesop;
    · exact absurd ( congr_arg ( Polynomial.eval 0 ) left_1 ) ( by norm_num );
    · exact absurd left_1 <| Finset.prod_ne_zero_iff.mpr fun x hx => ne_of_apply_ne Polynomial.derivative <| by norm_num [ Polynomial.derivative_sub, Polynomial.derivative_mul, Polynomial.derivative_X, Polynomial.derivative_C ] ;
  -- Since $\Psi_{mod}(n)$ is monic and its square is an integer polynomial, $\Psi_{mod}(n)$ is an integer polynomial.
  have hPsi_mod_monic : (Psi_mod n).Monic := by
    exact?;
  rcases eq_or_ne ( sigma n ) 1 <;> aesop;
  -- Since $\sigma(n) = 2$, we have $\Psi_{mod}(n)^2$ is an integer polynomial.
  have hPsi_mod_sq : IsIntPoly (Psi_mod n ^ 2) := by
    rcases n with ( _ | _ | _ | n ) <;> simp_all +decide [ sigma ];
  exact?

/-
If $P$ is a polynomial with integer coefficients and $c$ is an integer, then $P(cX)$ has integer coefficients.
-/
lemma IsIntPoly_comp_int_mul_X (P : Polynomial ℝ) (c : ℤ) (hP : IsIntPoly P) : IsIntPoly (P.comp (Polynomial.C (c : ℝ) * Polynomial.X)) := by
  simp_all +decide [ Polynomial.comp, Polynomial.eval₂_eq_sum_range ];
  intro k; use ∑ x ∈ Finset.range ( P.natDegree + 1 ), ( hP x |> Classical.choose ) * ( c ^ x |> Int.cast ) * ( if x = k then 1 else 0 ) ; simp_all +decide [ mul_pow, Polynomial.coeff_X_pow ] ;
  rw [ Finset.sum_eq_single k ] <;> aesop;
  · rw [ Polynomial.coeff_mul, Finset.sum_eq_single ( 0, k ) ] <;> aesop;
    erw [ Polynomial.coeff_zero_eq_eval_zero ] ; have := Classical.choose_spec ( hP k ) ; aesop;
  · exact Or.inl <| Polynomial.coeff_eq_zero_of_natDegree_lt <| by linarith;
  · -- Since $b \neq k$, the coefficient of $X^k$ in $c^b * X^b$ is zero.
    right; exact (by
    rw [ Polynomial.coeff_mul, Finset.sum_eq_zero ] ; aesop;
    erw [ Polynomial.coeff_eq_zero_of_natDegree_lt ] ; aesop;
    positivity);
  · exact Or.inl <| Polynomial.coeff_eq_zero_of_natDegree_lt <| by linarith;

/-
The polynomial $\C_{n}$ has integer coefficients.
-/
lemma Omega_integral (n : ℕ) : IsIntPoly (Omega n) := by
  by_cases hn : n = 1 ∨ n = 2;
  · unfold Omega; aesop;
    · intro k; erw [ Polynomial.coeff_sub, Polynomial.coeff_X, Polynomial.coeff_one ] ; aesop;
      exact ⟨ -1, by norm_num ⟩;
    · norm_num [ Finset.prod_filter, Finset.prod_singleton, Real.cos_two_mul, mul_div_assoc ];
      intro k; norm_num [ Polynomial.coeff_one, Polynomial.coeff_X, Polynomial.coeff_C ] ; aesop;
  · -- Since $\Psi_{mod}(n)$ is an integer polynomial (by `Psi_mod_integral`), and $\Omega(n) = \Psi_{mod}(n)(2x)$, it follows that $\Omega(n)$ is an integer polynomial.
    have h_psi_mod : IsIntPoly (Psi_mod n) := by
      by_cases hn : n ≥ 1;
      · exact Psi_mod_integral n hn;
      · unfold Psi_mod; aesop;
        exact fun k => ⟨ if k = 0 then 1 else 0, by erw [ Polynomial.coeff_one ] ; aesop ⟩;
    have h_omega : IsIntPoly ((Psi_mod n).comp (2 * Polynomial.X)) := by
      exact IsIntPoly_comp_int_mul_X _ 2 h_psi_mod;
    convert h_omega using 1;
    unfold Omega Psi_mod; aesop;
    norm_num [ Polynomial.comp_assoc, Polynomial.prod_comp ];
    exact Finset.prod_congr rfl fun x hx => by exact Polynomial.funext fun y => by norm_num; ring;

/-
`OmegaZ` is the integer polynomial corresponding to `Omega`.
-/
noncomputable def OmegaZ (n : ℕ) : Polynomial ℤ :=
  ∑ i ∈ (Omega n).support, Polynomial.C (Classical.choose (Omega_integral n i)) * Polynomial.X ^ i

lemma Omega_eq_map_OmegaZ (n : ℕ) : Omega n = (OmegaZ n).map (algebraMap ℤ ℝ) := by
  -- By definition of OmegaZ, its coefficients are the same as those of Omega n when mapped to ℝ.
  have h_coeff : ∀ k, (Omega n).coeff k = (OmegaZ n).coeff k := by
    -- By definition of OmegaZ, its coefficients are the same as those of Omega n when mapped to ℝ. Therefore, for any k, the coefficient of Omega n at k is equal to the coefficient of OmegaZ n at k when mapped to ℝ.
    intros k
    simp [OmegaZ];
    split_ifs <;> simp_all +decide [ Classical.choose_spec ( Omega_integral n _ ) ];
  ext; aesop

/-
The value of $T_n(x) - 1$ is equal to the product of $\OmegaZ_d(x)^{\sigma_d}$ over all divisors $d$ of $n$.
-/
lemma Tn_sub_one_eq_prod_OmegaZ_eval (n : ℕ) (hn : n > 0) (x : ℤ) :
  (Chebyshev.T ℤ n).eval x - 1 = ∏ d ∈ n.divisors, (OmegaZ d).eval x ^ (sigma d) := by
    have h_main : (Chebyshev.T ℤ n - 1 : Polynomial ℤ) = (∏ d ∈ n.divisors, ((OmegaZ d) ^ (sigma d) : Polynomial ℤ)) := by
      have h_real : (Chebyshev.T ℝ n - 1 : Polynomial ℝ) = (∏ d ∈ n.divisors, ((OmegaZ d).map (algebraMap ℤ ℝ) ^ (sigma d) : Polynomial ℝ)) := by
        convert inrtocyc_final n hn.nat_succ_le;
        -- By definition of `OmegaZ`, we know that `Omega x✝` is equal to the map of `OmegaZ x✝`.
        rw [Omega_eq_map_OmegaZ]
      refine' Polynomial.map_injective ( algebraMap ℤ ℝ ) Int.cast_injective <| _;
      -- Apply the map to both sides of h_real to get the equality in the integers.
      convert h_real using 1;
      · norm_num [ Chebyshev.T ];
      · induction n.divisors using Finset.induction <;> aesop;
    -- Apply the evaluation to both sides of the polynomial equality h_main.
    have h_eval : (Chebyshev.T ℤ n - 1 : Polynomial ℤ).eval x = (∏ d ∈ n.divisors, ((OmegaZ d) ^ (sigma d) : Polynomial ℤ)).eval x := by
      rw [h_main];
    simpa [ Polynomial.eval_prod ] using h_eval

/-
The value $\OmegaZ_n(x)$ divides $T_n(x) - 1$.
-/
lemma OmegaZ_dvd_Tn_sub_one (n : ℕ) (hn : n > 0) (x : ℤ) :
  (OmegaZ n).eval x ∣ (Chebyshev.T ℤ n).eval x - 1 := by
    -- Since $\OmegaZ_n(x)$ is a factor in the product and $\sigma_n \geq 1$, it follows that $\OmegaZ_n(x)$ divides the product.
    have h_div : (OmegaZ n).eval x ∣ ∏ d ∈ n.divisors, (OmegaZ d).eval x ^ (sigma d) := by
      exact dvd_trans ( by exact dvd_pow_self _ ( by unfold sigma; aesop_cat ) ) ( Finset.dvd_prod_of_mem _ ( Nat.mem_divisors_self _ hn.ne' ) );
    exact h_div.trans ( by simp +decide [ ← Tn_sub_one_eq_prod_OmegaZ_eval n hn ] )

/-
If a prime $p$ divides $T_n(x)-1$, then $p$ divides $\OmegaZ_d(x)$ for some divisor $d$ of $n$.
-/
lemma exists_dvd_OmegaZ_of_dvd_Tn_sub_one (n : ℕ) (hn : n > 0) (x : ℤ) (p : ℕ) (hp : p.Prime) (h : (p : ℤ) ∣ (Chebyshev.T ℤ n).eval x - 1) :
  ∃ d ∈ n.divisors, (p : ℤ) ∣ (OmegaZ d).eval x := by
    -- By the properties of prime divisors, if $p$ divides the product $\prod_{d|n} \OmegaZ_d(x)^{\sigma_d}$, then $p$ must divide at least one of the factors $\OmegaZ_d(x)^{\sigma_d}$.
    have h_div_factor : (p : ℤ) ∣ ∏ d ∈ n.divisors, (OmegaZ d).eval x ^ (sigma d) := by
      convert h using 1;
      -- Apply the lemma that states the equality between the product and the evaluation.
      apply Eq.symm; exact Tn_sub_one_eq_prod_OmegaZ_eval n hn x;
    haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, Finset.prod_eq_zero_iff ] ;
    aesop

/-
If $p$ is a primitive prime divisor of $T_n(x)-1$ and $p$ divides $T_d(x)-1$ for some divisor $d$ of $n$, then $d=n$.
-/
lemma primitive_divisor_dvd_imp_eq (x : ℤ) (n : ℕ) (hn : n > 0) (p : ℕ) (hp : is_primitive_prime_divisor_Chebyshev x n p) (d : ℕ) (hd_dvd_n : d ∣ n) (hd_pos : d > 0) (h_dvd : (p : ℤ) ∣ (Chebyshev.T ℤ d).eval x - 1) : d = n := by
  by_contra h;
  exact hp.2.2 d hd_pos ( lt_of_le_of_ne ( Nat.le_of_dvd hn hd_dvd_n ) h ) h_dvd

/-
Every primitive prime divisor of $T_{n}(x)-1$ divides $\C_{n}(x)$.
-/
theorem if_T_then_Omega (x : ℤ) (n : ℕ) (hn : n > 0) (p : ℕ) (hp : is_primitive_prime_divisor_Chebyshev x n p) :
  (p : ℤ) ∣ (OmegaZ n).eval x := by
    -- By `exists_dvd_OmegaZ_of_dvd_Tn_sub_one`, there exists $d \mid n$ such that $p \mid \OmegaZ_d(x)$.
    obtain ⟨d, hd_dvd_n, hd_pos, hd_dvd⟩ : ∃ d ∈ n.divisors, (p : ℤ) ∣ (OmegaZ d).eval x := by
      convert exists_dvd_OmegaZ_of_dvd_Tn_sub_one n hn x p hp.1 hp.2.1 using 1;
    have := OmegaZ_dvd_Tn_sub_one d ( Nat.pos_of_mem_divisors hd_dvd_n ) x; aesop;
    -- By `primitive_divisor_dvd_imp_eq`, we must have $d = n$.
    have hd_eq_n : d = n := by
      apply primitive_divisor_dvd_imp_eq x n hn p hp d left ( Nat.pos_of_dvd_of_pos left hn ) ( dvd_trans ( dvd_mul_right _ _ ) this );
    aesop

/-
Definition of the exceptional cases for Zsigmondy's Theorem analogue.
-/
def is_exception (n : ℕ) (a : ℤ) : Prop :=
  (a = 1 ∧ n > 1) ∨
  (a = 0 ∧ n ≠ 2 ∧ n ≠ 4) ∨
  (a = -1 ∧ n > 2) ∨
  (n = 1 ∧ (a = 0 ∨ a = 2)) ∨
  (n = 2 ∧ ∃ k : ℕ, k > 0 ∧ (a = (2 : ℤ)^(k - 1) - 1 ∨ a = -(2 : ℤ)^(k - 1) - 1)) ∨
  (n = 3 ∧ ∃ k : ℕ, k > 0 ∧ (2 * a = (3 : ℤ)^k - 1 ∨ 2 * a = -(3 : ℤ)^k - 1)) ∨
  (n = 4 ∧ ∃ k : ℕ, k > 0 ∧ (a = (2 : ℤ)^(k - 1) ∨ a = -(2 : ℤ)^(k - 1))) ∨
  (n = 6 ∧ ∃ k : ℕ, k > 0 ∧ (2 * a = (3 : ℤ)^k + 1 ∨ 2 * a = -(3 : ℤ)^k + 1))

theorem is_exception_dummy : True := by
  norm_num +zetaDelta at *

/-
If $n \ge 3$ is odd, then $\C_{2n}(x) = \pm \C_n(-x)$.
-/
theorem omega_odd_2 (n : ℕ) (hn : Odd n) (hn3 : n ≥ 3) :
  Omega (2 * n) = (Omega n).comp (-Polynomial.X) ∨ Omega (2 * n) = - (Omega n).comp (-Polynomial.X) := by
    rw [ show Omega ( 2 * n ) = ( Psi_mod ( 2 * n ) |> Polynomial.comp <| 2 * Polynomial.X ) from _ ];
    · -- By definition of $Psi\_mod$, we know that $Psi\_mod(2n) = \pm \Psi\_mod(n)(-x)$.
      have h_psi_mod_2n : Psi_mod (2 * n) = (Psi_mod n).comp (-Polynomial.X) ∨ Psi_mod (2 * n) = -(Psi_mod n).comp (-Polynomial.X) := by
        have h_psi_mod_2n : (Psi_mod (2 * n)).roots = (Psi_mod n).roots.map (fun x => -x) := by
          have h_psi_mod_2n : (Psi_mod (2 * n)).roots = (Omega (2 * n)).roots.map (fun x => x * 2) := by
            unfold Psi_mod Omega; aesop;
            rw [ Polynomial.roots_prod, Polynomial.roots_prod ];
            · induction ( Finset.filter ( fun k => Nat.Coprime ( 2 * n ) k ) ( Finset.Ioc 0 n ) |> Finset.val ) using Multiset.induction <;> aesop;
              rw [ show ( X - C 2 * C ( Real.cos ( 2 * a * Real.pi / ( 2 * n ) ) ) ) = ( Polynomial.X - Polynomial.C ( Real.cos ( 2 * a * Real.pi / ( 2 * n ) ) * 2 ) ) by exact Polynomial.funext fun x => by norm_num; ring ] ; erw [ Polynomial.roots_X_sub_C ] ; norm_num;
            · exact Finset.prod_ne_zero_iff.mpr fun x hx => mul_ne_zero ( Polynomial.C_ne_zero.mpr two_ne_zero ) ( Polynomial.X_sub_C_ne_zero _ );
            · exact Finset.prod_ne_zero_iff.mpr fun x hx => ne_of_apply_ne Polynomial.derivative <| by norm_num [ Polynomial.derivative_sub, Polynomial.derivative_mul, Polynomial.derivative_X, Polynomial.derivative_C ] ;
          have h_psi_mod_n : (Psi_mod n).roots = (Omega n).roots.map (fun x => x * 2) := by
            unfold Omega Psi_mod; aesop;
            rw [ Polynomial.roots_prod, Polynomial.roots_prod ];
            · induction ( Finset.filter ( fun k => Nat.Coprime n k ) ( Finset.Ioc 0 ( n / 2 ) ) |> Finset.val ) using Multiset.induction <;> aesop;
              rw [ show ( X - C 2 * C ( Real.cos ( 2 * a * Real.pi / n ) ) ) = ( X - C ( 2 * Real.cos ( 2 * a * Real.pi / n ) ) ) by norm_num, Polynomial.roots_X_sub_C ] ; norm_num;
              ring;
            · exact Finset.prod_ne_zero_iff.mpr fun x hx => mul_ne_zero ( Polynomial.C_ne_zero.mpr two_ne_zero ) ( Polynomial.X_sub_C_ne_zero _ );
            · exact Finset.prod_ne_zero_iff.mpr fun x hx => ne_of_apply_ne Polynomial.derivative <| by norm_num [ Polynomial.derivative_sub, Polynomial.derivative_mul, Polynomial.derivative_X, Polynomial.derivative_C ] ;
          rw [ h_psi_mod_2n, h_psi_mod_n ];
          rw [ roots_Omega_two_n_eq_neg_roots_Omega_n ];
          · norm_num [ Function.comp ];
          · assumption;
          · grind;
        have h_psi_mod_2n_factor : Psi_mod (2 * n) = Polynomial.C (Psi_mod (2 * n)).leadingCoeff * Multiset.prod (Multiset.map (fun x => Polynomial.X - Polynomial.C x) (Psi_mod (2 * n)).roots) := by
          convert Polynomial.eq_prod_roots_of_splits_id _;
          refine' Polynomial.splits_iff_card_roots.mpr _;
          unfold Psi_mod; aesop;
          rw [ Polynomial.natDegree_prod, Polynomial.roots_prod ];
          · induction ( Finset.filter ( fun k => Nat.Coprime ( 2 * n ) k ) ( Finset.Ioc 0 n ) ) using Finset.induction <;> aesop;
            rw [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num;
            · rw [ show ( X - C 2 * C ( Real.cos ( 2 * a * Real.pi / ( 2 * n ) ) ) ) = ( Polynomial.X - Polynomial.C ( 2 * Real.cos ( 2 * a * Real.pi / ( 2 * n ) ) ) ) by norm_num, Polynomial.roots_X_sub_C ] ; norm_num;
            · rw [ Polynomial.natDegree_C_mul ] <;> norm_num;
          · exact Finset.prod_ne_zero_iff.mpr fun x hx => ne_of_apply_ne Polynomial.derivative <| by norm_num [ mul_assoc, mul_comm, mul_left_comm ] ;
          · exact fun i hi => ne_of_apply_ne Polynomial.derivative <| by norm_num [ mul_assoc, mul_comm, mul_left_comm ] ;
        have h_psi_mod_n_factor : Psi_mod n = Polynomial.C (Psi_mod n).leadingCoeff * Multiset.prod (Multiset.map (fun x => Polynomial.X - Polynomial.C x) (Psi_mod n).roots) := by
          convert Polynomial.eq_prod_roots_of_splits_id _;
          -- Since each factor in the product is linear, the product of these linear factors splits.
          have h_linear_factors : ∀ k ∈ (Finset.Ioc 0 (n / 2)).filter (fun k => n.Coprime k), Polynomial.Splits (RingHom.id ℝ) (Polynomial.X - Polynomial.C (2 * Real.cos (2 * k * Real.pi / n))) := by
            exact fun k hk => Polynomial.splits_X_sub_C _;
          have h_prod_splits : ∀ {S : Finset ℕ}, (∀ k ∈ S, Polynomial.Splits (RingHom.id ℝ) (Polynomial.X - Polynomial.C (2 * Real.cos (2 * k * Real.pi / n)))) → Polynomial.Splits (RingHom.id ℝ) (∏ k ∈ S, (Polynomial.X - Polynomial.C (2 * Real.cos (2 * k * Real.pi / n)))) := by
            exact?;
          convert h_prod_splits h_linear_factors using 1;
          unfold Psi_mod; simp +decide [ Finset.prod_filter ] ;
          grind;
        -- Since $\Psi_{mod}(2n)$ and $\Psi_{mod}(n)$ are monic, their leading coefficients are 1.
        have h_leading_coeff : (Psi_mod (2 * n)).leadingCoeff = 1 ∧ (Psi_mod n).leadingCoeff = 1 := by
          exact ⟨ Psi_mod_monic ( 2 * n ) ( by linarith ), Psi_mod_monic n ( by linarith ) ⟩;
        norm_num [ h_leading_coeff ] at *;
        rw [ h_psi_mod_2n_factor, h_psi_mod_n_factor, h_psi_mod_2n ];
        induction ( Psi_mod n |> Polynomial.roots ) using Multiset.induction <;> norm_num at *;
        grind;
      rw [ show Omega n = ( Psi_mod n |> Polynomial.comp <| 2 * Polynomial.X ) from _ ];
      · rcases h_psi_mod_2n with h | h <;> rw [ h ] <;> norm_num [ Polynomial.comp_assoc ];
      · have := Omega_eq_Psi_comp n ( by linarith );
        unfold Omega Psi_mod at * ; aesop;
        · unfold Psi; aesop;
        · unfold Psi; aesop;
    · unfold Omega Psi_mod; aesop;
      norm_num [ Polynomial.prod_comp, Polynomial.mul_comp ];
      exact Finset.prod_congr rfl fun x hx => by exact Polynomial.funext fun y => by norm_num; ring;

/-
$\Che(p, 1) = 1$ for any prime $p$.
-/
lemma Che_one (p : ℕ) (hp : p.Prime) : Che p 1 = 1 := by
  -- Since the set {m | m > 0 ∧ (p : ℤ) ∣ (Chebyshev.T ℤ m).eval 1 - 1} is equal to {m | m > 0}, its infimum is 1.
  have h_inf : sInf {m : ℕ | m > 0} = 1 := by
    exact le_antisymm ( csInf_le ⟨ 0, fun m hm => Nat.zero_le m ⟩ ( by norm_num ) ) ( le_csInf ⟨ 1, by norm_num ⟩ fun m hm => Nat.one_le_of_lt hm );
  unfold Che; aesop;

/-
The polynomial (T_n(x+1)-1)/x has integer coefficients.
-/
def max_prime_divisor (n : ℕ) : ℕ := n.primeFactors.max.getD 1

theorem T_on_x_plus_one_minus_one_by_x (n : ℕ) :
  IsIntPoly (((Chebyshev.T ℝ n).comp (Polynomial.X + Polynomial.C 1) - 1) / Polynomial.X) := by
    -- Since $T_n(x+1) - 1$ is divisible by $x$, we can write it as $x \cdot Q(x)$ for some polynomial $Q(x)$ with integer coefficients.
    obtain ⟨Q, hQ⟩ : ∃ Q : Polynomial ℤ, (Chebyshev.T ℤ n).comp (Polynomial.X + 1) - 1 = Polynomial.X * Q := by
      have h_div : Polynomial.eval 0 ((Chebyshev.T ℤ n).comp (Polynomial.X + 1) - 1) = 0 := by
        norm_num [ Chebyshev.T ];
      simpa using Polynomial.dvd_iff_isRoot.mpr h_div;
    -- Since $Q$ has integer coefficients, the polynomial $Q$ is also an integer polynomial.
    have hQ_int : IsIntPoly (Polynomial.map (Int.castRingHom ℝ) Q) := by
      -- Since Q is a polynomial with integer coefficients, its coefficients are integers. Therefore, when we map Q to ℝ, the coefficients remain integers.
      intro k
      simp [Polynomial.coeff_map];
    rw [ show ( ( Chebyshev.T ℝ n |> Polynomial.comp ) ( X + C 1 ) - 1 ) = X * Polynomial.map ( Int.castRingHom ℝ ) Q from _ ];
    · aesop;
    · convert congr_arg ( Polynomial.map ( Int.castRingHom ℝ ) ) hQ using 1 <;> norm_num [ Polynomial.map_comp ]

/-
The derivative of T_n evaluated at 1 is n^2.
-/
theorem lemma_T_derivative_eval_one (n : ℕ) :
  (Polynomial.derivative (Chebyshev.T ℤ n)).eval 1 = n ^ 2 := by
    induction' n using Nat.strong_induction_on with n ih;
    rcases n with ( _ | _ | n ) <;> aesop;
    have h_ind_step : Chebyshev.T ℤ (n + 2) = 2 * Polynomial.X * Chebyshev.T ℤ (n + 1) - Chebyshev.T ℤ n := by
      exact?;
    have := ih n ( by linarith ) ; ( have := ih ( n + 1 ) ( by linarith ) ; ( erw [ h_ind_step ] at *; norm_num at * ; linarith!; ) )

/-
T_n(x) - 1 can be factored as (x-1)Q(x) where Q(1) = n^2.
-/
theorem lemma_T_sub_one_factorization (n : ℕ) (hn : n > 0) :
  ∃ Q : Polynomial ℤ, Chebyshev.T ℤ n - 1 = (Polynomial.X - 1) * Q ∧ Q.eval 1 = (n : ℤ)^2 := by
    -- Since $T_n(1) = 1$, we have $T_n(x) - 1 = (x - 1)Q(x)$ for some polynomial $Q(x)$.
    obtain ⟨Q, hQ⟩ : ∃ Q : Polynomial ℤ, Chebyshev.T ℤ n - 1 = (Polynomial.X - 1) * Q := by
      exact Polynomial.dvd_iff_isRoot.mpr ( by simp +decide [ Chebyshev.T ] );
    refine' ⟨ Q, hQ, _ ⟩;
    replace hQ := congr_arg ( Polynomial.derivative ) hQ ; norm_num at hQ ; replace hQ := congr_arg ( Polynomial.eval 1 ) hQ ; aesop;
    exact hQ ▸ lemma_T_derivative_eval_one n

/-
If y = 1 mod p and p != q, then (T_q(y)-1)/(y-1) is not divisible by p.
-/
theorem lemma_T_sub_one_div_X_sub_one_eval_not_dvd_p (q : ℕ) (hq : q.Prime) (p : ℕ) (hp : p.Prime) (hpq : p ≠ q) (y : ℤ) (hy : y ≡ 1 [ZMOD p]) :
  ∃ Q : Polynomial ℤ, Chebyshev.T ℤ q - 1 = (Polynomial.X - 1) * Q ∧ ¬ (p : ℤ) ∣ Q.eval y := by
    have := lemma_T_sub_one_factorization q hq.pos;
    -- Since $y \equiv 1 \pmod{p}$, we have $Q(y) \equiv Q(1) \pmod{p}$.
    obtain ⟨Q, hQ⟩ := this;
    have hQ_mod : Q.eval y ≡ Q.eval 1 [ZMOD p] := by
      exact Int.ModEq.symm ( Int.modEq_of_dvd <| Int.dvd_trans ( Int.modEq_iff_dvd.mp hy.symm ) <| Polynomial.sub_dvd_eval_sub _ _ _ );
    -- Since $p$ is a prime and $p \ne q$, $p$ does not divide $q^2$.
    have hq_sq_not_div_p : ¬(p : ℤ) ∣ q^2 := by
      exact_mod_cast mt hp.dvd_of_dvd_pow ( by rw [ Nat.dvd_prime hq ] ; aesop );
    exact ⟨ Q, hQ.1, fun h => hq_sq_not_div_p <| by simpa [ hQ.2 ] using Int.dvd_of_emod_eq_zero <| hQ_mod.symm.trans <| Int.modEq_zero_iff_dvd.mpr h ⟩

/-
The p-adic valuation of T_{kq}(a)-1 is the same as T_k(a)-1 if q != p.
-/
theorem valuation_stable_under_coprime_factor (a : ℤ) (p : ℕ) (hp : p.Prime) (k : ℕ) (hk : k > 0) (q : ℕ) (hq : q.Prime) (hq_ne_p : q ≠ p) (h_div : (p : ℤ) ∣ (Chebyshev.T ℤ k).eval a - 1) :
  multiplicity (p : ℤ) ((Chebyshev.T ℤ (k * q)).eval a - 1) = multiplicity (p : ℤ) ((Chebyshev.T ℤ k).eval a - 1) := by
    unfold multiplicity; aesop;
    rw [ show ( Chebyshev.T ℤ ( k * q ) ) = ( Chebyshev.T ℤ q |> Polynomial.comp ) ( Chebyshev.T ℤ k ) by
          exact Polynomial.funext fun x => by simp +decide [ ← Chebyshev.T_mul ] ; ring;, Polynomial.eval_comp ];
    -- Since $p \mid y - 1$, we can write $T_q(y) - 1 = (y - 1)Q(y)$ where $Q(y)$ is not divisible by $p$.
    obtain ⟨Q, hQ⟩ : ∃ Q : Polynomial ℤ, Chebyshev.T ℤ q - 1 = (Polynomial.X - 1) * Q ∧ ¬(p : ℤ) ∣ Q.eval (Polynomial.eval a (Chebyshev.T ℤ k)) := by
      -- By the lemma, there exists a polynomial Q such that T_q(y) - 1 = (y - 1)Q and Q(1) is not divisible by p.
      obtain ⟨Q, hQ⟩ : ∃ Q : Polynomial ℤ, Chebyshev.T ℤ q - 1 = (Polynomial.X - 1) * Q ∧ ¬(p : ℤ) ∣ Q.eval 1 := by
        exact?;
      refine' ⟨ Q, hQ.1, _ ⟩;
      haveI := Fact.mk hp; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, Polynomial.eval_eq_sum_range ] ;
      simp_all +decide [ sub_eq_iff_eq_add ];
    -- Apply the multiplicity_mul lemma to conclude the equality of multiplicities.
    have h_multiplicity_mul : emultiplicity (p : ℤ) ((Polynomial.eval (Polynomial.eval a (Chebyshev.T ℤ k)) (Chebyshev.T ℤ q)) - 1) = emultiplicity (p : ℤ) ((Polynomial.eval a (Chebyshev.T ℤ k)) - 1) + emultiplicity (p : ℤ) (Q.eval (Polynomial.eval a (Chebyshev.T ℤ k))) := by
      rw [ ← emultiplicity_mul ] ; aesop;
      · replace left := congr_arg ( Polynomial.eval ( Polynomial.eval a ( Chebyshev.T ℤ k ) ) ) left ; aesop;
      · exact Nat.prime_iff_prime_int.mp hp;
    simp_all +decide [ emultiplicity_eq_zero.mpr ]

/-
If m is coprime to p, then the p-adic valuation of T_{km}(a)-1 is the same as T_k(a)-1.
-/
theorem valuation_stable_under_coprime_factor_iterated (a : ℤ) (p : ℕ) (hp : p.Prime) (k : ℕ) (hk : k > 0) (m : ℕ) (hm : m > 0) (h_coprime : Nat.Coprime m p) (h_div : (p : ℤ) ∣ (Chebyshev.T ℤ k).eval a - 1) :
  multiplicity (p : ℤ) ((Chebyshev.T ℤ (k * m)).eval a - 1) = multiplicity (p : ℤ) ((Chebyshev.T ℤ k).eval a - 1) := by
    -- By induction on the number of prime factors of $m$.
    have h_ind : ∀ m : ℕ, m > 0 → Nat.Coprime m p → multiplicity (p : ℤ) ((Chebyshev.T ℤ (k * m)).eval a - 1) = multiplicity (p : ℤ) ((Chebyshev.T ℤ k).eval a - 1) := by
      -- We prove this by induction on $m$.
      intro m hm h_coprime
      induction' m using Nat.strong_induction_on with m ih;
      -- Consider two cases: $m = 1$ or $m > 1$.
      by_cases hm1 : m = 1;
      · aesop;
      · -- Since $m \neq 1$, we can write $m = q * m'$ where $q$ is a prime factor of $m$ and $\gcd(m', p) = 1$.
        obtain ⟨q, m', hq, hm', h_coprime'⟩ : ∃ q m' : ℕ, Nat.Prime q ∧ m = q * m' ∧ Nat.Coprime m' p := by
          exact ⟨ Nat.minFac m, m / Nat.minFac m, Nat.minFac_prime hm1, by rw [ Nat.mul_div_cancel' ( Nat.minFac_dvd m ) ], h_coprime.coprime_dvd_left ( Nat.div_dvd_of_dvd ( Nat.minFac_dvd m ) ) ⟩;
        have h_val : multiplicity (p : ℤ) ((Chebyshev.T ℤ (k * q * m')).eval a - 1) = multiplicity (p : ℤ) ((Chebyshev.T ℤ (k * m')).eval a - 1) := by
          have h_val : multiplicity (p : ℤ) ((Chebyshev.T ℤ (k * m' * q)).eval a - 1) = multiplicity (p : ℤ) ((Chebyshev.T ℤ (k * m')).eval a - 1) := by
            have h_div : (p : ℤ) ∣ (Chebyshev.T ℤ (k * m')).eval a - 1 := by
              specialize ih m' ( by nlinarith [ hq.two_le ] ) ( Nat.pos_of_ne_zero ( by aesop_cat ) ) h_coprime' ; aesop;
              contrapose! ih;
              rw [ multiplicity_eq_zero.mpr ] <;> norm_num [ ih ];
              rw [ eq_comm, multiplicity_eq_zero ] ; aesop
            have h_val : multiplicity (p : ℤ) ((Chebyshev.T ℤ (k * m' * q)).eval a - 1) = multiplicity (p : ℤ) ((Chebyshev.T ℤ (k * m')).eval a - 1) := by
              have := valuation_stable_under_coprime_factor a p hp (k * m') (by
              exact Nat.mul_pos hk ( Nat.pos_of_ne_zero ( by aesop_cat ) )) q hq (by
              rintro rfl; simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ]) (by
              aesop)
              exact_mod_cast this;
            convert h_val using 1;
          simpa only [ mul_right_comm ] using h_val;
        simp_all +decide [ mul_assoc ];
        exact ih m' ( by nlinarith [ hq.two_le ] ) hm.2 h_coprime';
    exact h_ind m hm h_coprime

/-
If the p-adic valuation of T_n(a)-1 equals that of T_d(a)-1 where d|n, then p does not divide Omega_j(a) for any j dividing n but not d.
-/
theorem valuation_equality_implies_not_dvd_Omega (n d : ℕ) (hn : n > 0) (hd : d > 0) (h_dvd : d ∣ n) (a : ℤ) (ha : |a| > 1) (p : ℕ) (hp : p.Prime) (h_val : multiplicity (p : ℤ) ((Chebyshev.T ℤ n).eval a - 1) = multiplicity (p : ℤ) ((Chebyshev.T ℤ d).eval a - 1)) :
  ∀ j ∈ n.divisors, j ∉ d.divisors → ¬ (p : ℤ) ∣ (OmegaZ j).eval a := by
    -- Since $T_n(a) - 1 = \prod_{j \mid n} \Omega_j(a)^{\sigma_j}$ and $T_d(a) - 1 = \prod_{j \mid d} \Omega_j(a)^{\sigma_j}$, we can write:
    have h_prod : (Chebyshev.T ℤ n).eval a - 1 = ∏ j ∈ n.divisors, (OmegaZ j).eval a ^ (sigma j) ∧ (Chebyshev.T ℤ d).eval a - 1 = ∏ j ∈ d.divisors, (OmegaZ j).eval a ^ (sigma j) := by
      exact ⟨ by simpa [ mul_comm ] using Tn_sub_one_eq_prod_OmegaZ_eval n hn a, by simpa [ mul_comm ] using Tn_sub_one_eq_prod_OmegaZ_eval d hd a ⟩;
    -- Using the properties of multiplicities, we can split the valuations into the sum of the valuations of the individual factors.
    have h_split_val : multiplicity (p : ℤ) (∏ j ∈ n.divisors, (OmegaZ j).eval a ^ (sigma j)) = ∑ j ∈ n.divisors, multiplicity (p : ℤ) ((OmegaZ j).eval a) * (sigma j) ∧ multiplicity (p : ℤ) (∏ j ∈ d.divisors, (OmegaZ j).eval a ^ (sigma j)) = ∑ j ∈ d.divisors, multiplicity (p : ℤ) ((OmegaZ j).eval a) * (sigma j) := by
      have h_split_val : ∀ {S : Finset ℕ} {f : ℕ → ℤ}, (∀ j ∈ S, f j ≠ 0) → multiplicity (p : ℤ) (∏ j ∈ S, f j) = ∑ j ∈ S, multiplicity (p : ℤ) (f j) := by
        intros S f hf_nonzero
        induction' S using Finset.induction with j S hj ih;
        · norm_num [ multiplicity ];
          rw [ emultiplicity_eq_zero.mpr ] <;> norm_num;
          exact_mod_cast hp.not_dvd_one;
        · rw [ Finset.prod_insert hj, multiplicity_mul ] <;> simp_all +decide [ Finset.sum_insert hj ];
          · exact Nat.prime_iff_prime_int.mp hp;
          · exact Int.finiteMultiplicity_iff.mpr ⟨ mod_cast hp.ne_one, mul_ne_zero hf_nonzero.1 <| Finset.prod_ne_zero_iff.mpr fun x hx => hf_nonzero.2 x hx ⟩;
      -- Since $a$ is not equal to $2 \cos(2k\pi/j)$ for any $k$, each term in the product is non-zero.
      have h_nonzero : ∀ j ∈ n.divisors, (OmegaZ j).eval a ≠ 0 := by
        intros j hj_mem_divisors
        have h_eval_ne_zero : (Omega j).eval (a : ℝ) ≠ 0 := by
          unfold Omega;
          split_ifs <;> simp_all +decide [ Polynomial.eval_prod, Finset.prod_eq_zero_iff, sub_eq_zero ];
          · cases abs_cases a <;> linarith;
          · intro x hx_pos hx_le_half hx_coprime; intro H; have := Real.cos_le_one ( 2 * x * Real.pi / j ) ; norm_num [ H.symm ] at this;
            have : a ≥ -1 := Int.le_of_lt_add_one ( by rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ Real.neg_one_le_cos ( 2 * x * Real.pi / j ) ] ) ; ( have : a ≤ 1 := Int.le_of_lt_add_one ( by rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ Real.cos_le_one ( 2 * x * Real.pi / j ) ] ) ; interval_cases a <;> norm_num at *; );
        convert h_eval_ne_zero using 1;
        rw [ Omega_eq_map_OmegaZ ] ; norm_num [ Polynomial.eval_map ]
      have h_nonzero_d : ∀ j ∈ d.divisors, (OmegaZ j).eval a ≠ 0 := by
        exact fun j hj => h_nonzero j <| Nat.mem_divisors.mpr ⟨ dvd_trans ( Nat.dvd_of_mem_divisors hj ) h_dvd, by aesop ⟩;
      have h_split_val : ∀ j ∈ n.divisors, multiplicity (p : ℤ) ((OmegaZ j).eval a ^ (sigma j)) = multiplicity (p : ℤ) ((OmegaZ j).eval a) * (sigma j) := by
        intros j hj;
        have h_split_val : ∀ {x : ℤ}, x ≠ 0 → multiplicity (p : ℤ) (x ^ (sigma j)) = multiplicity (p : ℤ) x * (sigma j) := by
          intros x hx_nonzero
          have h_split_val : multiplicity (p : ℤ) (x ^ (sigma j)) = multiplicity (p : ℤ) x * (sigma j) := by
            have h_div : multiplicity (p : ℤ) (x ^ (sigma j)) = multiplicity (p : ℤ) x * (sigma j) := by
              have h_div : ∀ {x y : ℤ}, x ≠ 0 → y ≠ 0 → multiplicity (p : ℤ) (x * y) = multiplicity (p : ℤ) x + multiplicity (p : ℤ) y := by
                intros x y hx hy; exact (by
                haveI := Fact.mk hp; rw [ multiplicity_mul ] ; aesop;
                · exact Nat.prime_iff_prime_int.mp hp;
                · exact Int.finiteMultiplicity_iff.mpr ⟨ by aesop, by aesop ⟩)
              induction' sigma j with k hk;
              · grind;
              · rw [ pow_succ, h_div ( pow_ne_zero _ hx_nonzero ) hx_nonzero, hk, mul_add, mul_one ]
            exact h_div;
          exact h_split_val;
        exact h_split_val <| h_nonzero j hj;
      exact ⟨ by rw [ ‹∀ { S : Finset ℕ } { f : ℕ → ℤ }, ( ∀ j ∈ S, f j ≠ 0 ) → multiplicity ( p : ℤ ) ( ∏ j ∈ S, f j ) = ∑ j ∈ S, multiplicity ( p : ℤ ) ( f j ) › fun j hj => pow_ne_zero _ ( h_nonzero j hj ), Finset.sum_congr rfl h_split_val ], by rw [ ‹∀ { S : Finset ℕ } { f : ℕ → ℤ }, ( ∀ j ∈ S, f j ≠ 0 ) → multiplicity ( p : ℤ ) ( ∏ j ∈ S, f j ) = ∑ j ∈ S, multiplicity ( p : ℤ ) ( f j ) › fun j hj => pow_ne_zero _ ( h_nonzero_d j hj ), Finset.sum_congr rfl fun j hj => h_split_val j ( Nat.mem_divisors.mpr ⟨ dvd_trans ( Nat.dvd_of_mem_divisors hj ) h_dvd, by aesop ⟩ ) ] ⟩;
    -- Since the sums are equal and the terms for j not in d's divisors must be zero, we can conclude that for any j in n's divisors but not in d's divisors, the multiplicity of p in OmegaZ j is zero.
    have h_zero_multiplicity : ∀ j ∈ n.divisors, j ∉ d.divisors → multiplicity (p : ℤ) ((OmegaZ j).eval a) = 0 := by
      have h_zero_multiplicity : ∑ j ∈ n.divisors \ d.divisors, multiplicity (p : ℤ) ((OmegaZ j).eval a) * (sigma j) = 0 := by
        simp_all +decide [ ← Finset.sum_sdiff ( show d.divisors ⊆ n.divisors from fun x hx => Nat.mem_divisors.mpr ⟨ dvd_trans ( Nat.dvd_of_mem_divisors hx ) h_dvd, by aesop ⟩ ) ];
      simp_all +decide [ Finset.sum_eq_zero_iff_of_nonneg, Nat.zero_le ];
      intro j hj hn hj'; specialize h_zero_multiplicity j hj hn hj'; unfold sigma at h_zero_multiplicity; aesop;
    intro j hj₁ hj₂; specialize h_zero_multiplicity j hj₁ hj₂; simp_all +decide [ multiplicity_eq_zero ] ;

/-
If p divides Omega_n(a), then n = Che(a) * p^i.
-/
theorem Satz_1_part1 (n : ℕ) (a : ℤ) (hn : n > 1) (ha : |a| > 1) (p : ℕ) (hp : p.Prime) (h_dvd : (p : ℤ) ∣ (OmegaZ n).eval a) :
  ∃ i : ℕ, n = Che p a * p ^ i := by
    -- Let $k = \Che(a)$. By `ChebOrd`, $k \mid n$.
    set k := Che p a with hk
    have hk_div_n : k ∣ n := by
      apply (ChebOrd p hp a n (by linarith)).mp;
      -- By definition of $OmegaZ$, we know that $OmegaZ n$ divides $T_n(x) - 1$.
      have h_div : (OmegaZ n).eval a ∣ (Chebyshev.T ℤ n).eval a - 1 := by
        convert OmegaZ_dvd_Tn_sub_one n ( pos_of_gt hn ) a using 1;
      exact dvd_trans h_dvd h_div;
    -- Let $n = k \cdot p^i \cdot m'$ where $\gcd(m', p) = 1$.
    obtain ⟨i, m', hm'⟩ : ∃ i m' : ℕ, n = k * p ^ i * m' ∧ Nat.Coprime m' p := by
      -- Let $i$ be such that $p^i \mid n / k$ and $p^{i+1} \nmid n / k$.
      obtain ⟨i, hi⟩ : ∃ i : ℕ, p ^ i ∣ n / k ∧ ¬p ^ (i + 1) ∣ n / k := by
        exact ⟨ Nat.factorization ( n / k ) p, Nat.ordProj_dvd _ _, Nat.pow_succ_factorization_not_dvd ( Nat.ne_of_gt ( Nat.div_pos ( Nat.le_of_dvd hn.le hk_div_n ) ( Nat.pos_of_dvd_of_pos hk_div_n hn.le ) ) ) hp ⟩;
      cases' hi.1 with m' hm';
      exact ⟨ i, m', by nlinarith [ Nat.div_mul_cancel hk_div_n ], Nat.Coprime.symm <| hp.coprime_iff_not_dvd.mpr fun h => hi.2 <| hm'.symm ▸ Nat.mul_dvd_mul_left _ h ⟩;
    -- If $m' > 1$, then $n = k \cdot p^i \cdot m'$ would imply that $n$ is not divisible by $k \cdot p^i$, contradicting the stability of the p-adic valuation.
    by_contra hm'_gt_one
    have h_contra : multiplicity (p : ℤ) ((Chebyshev.T ℤ n).eval a - 1) = multiplicity (p : ℤ) ((Chebyshev.T ℤ (k * p ^ i)).eval a - 1) := by
      have := @valuation_stable_under_coprime_factor_iterated a p hp ( k * p ^ i ) ?_ m' ?_ ?_ ?_ <;> simp_all +decide [ mul_assoc, Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right ];
      · exact ⟨ Nat.pos_of_ne_zero ( hm'_gt_one 0 |>.2 ), pow_pos hp.pos _ ⟩;
      · exact Nat.pos_of_ne_zero ( by aesop_cat );
      · exact hm'.2;
      · have := ChebOrd p hp a ( Che p a * p ^ i ) ; aesop;
        exact this ( Nat.pos_of_ne_zero ( hm'_gt_one 0 |>.2 ) ) ( pow_pos hp.pos _ );
    -- By `valuation_equality_implies_not_dvd_Omega`, for any $j \mid n$ such that $j \nmid d$, $p \nmid \Omega_j(a)$.
    have h_not_dvd_Omega : ∀ j ∈ n.divisors, j ∉ (k * p ^ i).divisors → ¬ (p : ℤ) ∣ (OmegaZ j).eval a := by
      apply valuation_equality_implies_not_dvd_Omega;
      any_goals assumption;
      · linarith;
      · exact Nat.mul_pos ( Nat.pos_of_dvd_of_pos hk_div_n hn.le ) ( pow_pos hp.pos _ );
      · exact ⟨ m', by linarith ⟩;
      · exact_mod_cast h_contra;
    apply h_not_dvd_Omega n (Nat.mem_divisors.mpr ⟨dvd_refl n, by linarith⟩) (by
    simp +zetaDelta at *;
    intro h₁ h₂; specialize hm'_gt_one i; simp_all +decide [ Nat.not_dvd_of_pos_of_lt ] ;
    exact False.elim <| hm'_gt_one <| Nat.le_antisymm ( Nat.le_of_dvd ( Nat.pos_of_ne_zero <| by aesop ) h₁ ) ( Nat.le_of_dvd ( Nat.pos_of_ne_zero <| by aesop ) <| dvd_mul_right _ _ )) h_dvd

/-
If n = Che(a) * p^i with i > 0, then p is the largest prime factor of n.
-/
theorem Satz_1_part2 (n : ℕ) (a : ℤ) (hn : n > 1) (ha : |a| > 1) (p : ℕ) (hp : p.Prime) (h_dvd : (p : ℤ) ∣ (OmegaZ n).eval a) (i : ℕ) (hi : i > 0) (h_form : n = Che p a * p ^ i) :
  p = max_prime_divisor n := by
    -- Since $p$ is a prime factor of $n$ and any prime factor of $Che p a$ is less than or equal to $p$, $p$ must be the maximum prime divisor of $n$.
    have h_max_prime : ∀ q : ℕ, Nat.Prime q → q ∣ n → q ≤ p := by
      -- Any prime factor of $Che p a$ is less than or equal to $p$.
      have h_Che_le_p : ∀ q : ℕ, Nat.Prime q → q ∣ Che p a → q ≤ p := by
        intro q hq hq'; have := prop_Che p hp a; aesop;
        by_cases hp2 : p = 2 <;> aesop;
        · by_cases ha_even : Even a <;> aesop;
          exact Nat.le_of_dvd ( by decide ) hq';
        · exact Nat.le_trans ( Nat.le_of_dvd ( Nat.sub_pos_of_lt hp.one_lt ) ( Nat.dvd_trans hq' h ) ) ( Nat.sub_le_of_le_add <| by linarith );
        · -- If $q \mid p + 1$, then $q \leq p + 1$. Since $q$ is a prime divisor of $Che p a$ and $Che p a \mid p + 1$, $q$ cannot be $p + 1$ because $p + 1$ is even and greater than 2. Hence, $q \leq p$.
          by_cases hq_eq_p1 : q = p + 1;
          · cases Nat.Prime.eq_two_or_odd hp <;> cases Nat.Prime.eq_two_or_odd hq <;> simp_all +decide [ Nat.add_mod ];
          · exact Nat.le_of_lt_succ ( lt_of_le_of_ne ( Nat.le_of_dvd ( Nat.succ_pos _ ) ( dvd_trans hq' h_1 ) ) hq_eq_p1 );
      intro q hq hqn; rw [ h_form ] at hqn; rw [ Nat.Prime.dvd_mul hq ] at hqn; aesop;
      exact hq.dvd_of_dvd_pow h_1 |> Nat.le_of_dvd hp.pos;
    unfold max_prime_divisor; aesop;
    -- Since p is a prime factor of n and any other prime factor q of n must be less than or equal to p, p must be the maximum prime factor.
    have h_max_prime_factor : p ∈ (Che p a * p ^ i).primeFactors := by
      aesop;
      exact dvd_mul_of_dvd_right ( dvd_pow_self _ hi.ne' ) _;
    rw [ eq_comm ] ; rw [ Finset.max_eq_sup_coe ] ; aesop;
    rw [ show ( Che p a * p ^ i |> Nat.primeFactors |> Finset.sup ) WithBot.some = ↑p from le_antisymm ( Finset.sup_le fun q hq => WithBot.coe_le_coe.mpr ( h_max_prime q ( Nat.prime_of_mem_primeFactors hq ) ( Nat.dvd_of_mem_primeFactors hq ) ) ) ( Finset.le_sup ( f := WithBot.some ) <| Nat.mem_primeFactors.mpr ⟨ hp, left, by aesop_cat ⟩ ) ] ; aesop

/-
The second derivative of T_n evaluated at 1 is n^2(n^2-1)/3.
-/
theorem lemma_T_second_derivative_eval_one (n : ℕ) :
  (Polynomial.derivative (Polynomial.derivative (Chebyshev.T ℤ n))).eval 1 = (n ^ 2 * (n ^ 2 - 1)) / 3 := by
    rw [ eq_comm, Int.ediv_eq_of_eq_mul_left ] <;> induction' n using Nat.strong_induction_on with n ih;
    · grind;
    · -- For the inductive step, we use the recurrence relation $T_{n+2}(x) = 2x T_{n+1}(x) - T_n(x)$.
      have h_recurrence : ∀ n : ℕ, Chebyshev.T ℤ (n + 2) = 2 * Polynomial.X * Chebyshev.T ℤ (n + 1) - Chebyshev.T ℤ n := by
        exact?;
      rcases n with ( _ | _ | n ) <;> norm_num at *;
      have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; norm_num [ h_recurrence ] at * ; ring_nf at * ; aesop;
      -- By definition of Chebyshev polynomials, we know that $T_n'(1) = n^2$.
      have h_deriv : ∀ n : ℕ, (Polynomial.derivative (Chebyshev.T ℤ n)).eval 1 = n^2 := by
        exact?;
      have := h_deriv n; have := h_deriv ( n + 1 ) ; norm_num [ add_comm, add_left_comm, add_assoc ] at * ; linarith [ ih n ( by linarith ), ih ( n + 1 ) ( by linarith ) ] ;

/-
Explicit sum formula for Chebyshev polynomials: T_n(x) = sum_{k=0}^{n/2} binom(n, 2k) (x^2-1)^k x^{n-2k}.
-/
theorem lemma_T_explicit_sum (n : ℕ) :
  Chebyshev.T ℤ n = ∑ k ∈ Finset.range (n / 2 + 1), Polynomial.C ((Nat.choose n (2 * k)) : ℤ) * (Polynomial.X ^ 2 - 1) ^ k * Polynomial.X ^ (n - 2 * k) := by
    -- We'll use the fact that the sum is the expansion of $(x + \sqrt{x^2 - 1})^n + (x - \sqrt{x^2 - 1})^n$ divided by 2.
    have h_expansion : ∀ x : ℝ, x ≥ 1 → (Chebyshev.T ℝ n).eval x = ((x + Real.sqrt (x^2 - 1))^n + (x - Real.sqrt (x^2 - 1))^n) / 2 := by
      induction' n using Nat.strong_induction_on with n ih;
      rcases n with ( _ | _ | n ) <;> norm_num [ Chebyshev.T ];
      intro x hx; erw [ Chebyshev.T ] ; norm_num [ ih n ( by linarith ) x hx, ih ( n + 1 ) ( by linarith ) x hx ] ; ring;
      have := ih n ( by linarith ) x hx; have := ih ( n + 1 ) ( by linarith ) x hx; norm_num [ add_comm, pow_succ, Chebyshev.T ] at * ; ring_nf at * ; aesop;
      rw [ Real.sq_sqrt ( by nlinarith ) ] ; ring;
    -- Let's expand the right-hand side using the binomial theorem.
    have h_binom : ∀ x : ℝ, x ≥ 1 → ((x + Real.sqrt (x^2 - 1))^n + (x - Real.sqrt (x^2 - 1))^n) / 2 = ∑ k ∈ Finset.range (n / 2 + 1), (Nat.choose n (2 * k)) * (x^2 - 1)^k * x^(n - 2 * k) := by
      -- Let's expand the right-hand side using the binomial theorem for $(x + \sqrt{x^2 - 1})^n$ and $(x - \sqrt{x^2 - 1})^n$.
      have h_binom : ∀ x : ℝ, x ≥ 1 → ((x + Real.sqrt (x^2 - 1))^n + (x - Real.sqrt (x^2 - 1))^n) = ∑ k ∈ Finset.range (n + 1), Nat.choose n k * x^(n - k) * (Real.sqrt (x^2 - 1))^k + ∑ k ∈ Finset.range (n + 1), Nat.choose n k * x^(n - k) * (-Real.sqrt (x^2 - 1))^k := by
        exact fun x hx => congrArg₂ ( · + · ) ( by rw [ add_comm, add_pow ] ; ac_rfl ) ( by rw [ sub_eq_add_neg, add_comm, add_pow ] ; ac_rfl );
      -- Let's simplify the expression using the binomial theorem.
      intros x hx
      rw [h_binom x hx]
      have h_simplify : ∑ k ∈ Finset.range (n + 1), Nat.choose n k * x^(n - k) * (Real.sqrt (x^2 - 1))^k + ∑ k ∈ Finset.range (n + 1), Nat.choose n k * x^(n - k) * (-Real.sqrt (x^2 - 1))^k = ∑ k ∈ Finset.filter (fun k => k % 2 = 0) (Finset.range (n + 1)), Nat.choose n k * x^(n - k) * (x^2 - 1)^(k / 2) * 2 := by
        rw [ ← Finset.sum_add_distrib ] ; rw [ Finset.sum_filter ] ; refine' Finset.sum_congr rfl fun k hk => _ ; rcases Nat.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> norm_num [ pow_add, pow_mul ] ; ring;
        rw [ pow_mul', Real.sq_sqrt ( by nlinarith ) ];
      rw [ h_simplify, Finset.sum_div ];
      rw [ show Finset.filter ( fun k => k % 2 = 0 ) ( Finset.range ( n + 1 ) ) = Finset.image ( fun k => 2 * k ) ( Finset.range ( n / 2 + 1 ) ) from ?_, Finset.sum_image <| by norm_num ] ; norm_num [ mul_assoc, mul_comm, mul_left_comm ];
      · -- By simplifying each term in the sum, we can see that the division by 2 is redundant.
        apply Finset.sum_congr rfl
        intro k hk
        field_simp [mul_comm, mul_assoc, mul_left_comm];
      · ext ; aesop <;> try omega;
        exact ⟨ a / 2, by omega, by linarith [ Nat.mod_add_div a 2 ] ⟩;
    -- Since these two polynomials agree for all $x \geq 1$, they must be equal.
    have h_poly_eq : ∀ x : ℝ, x ≥ 1 → (Polynomial.eval x (Chebyshev.T ℝ n)) = (Polynomial.eval x (∑ k ∈ Finset.range (n / 2 + 1), Polynomial.C ((Nat.choose n (2 * k)) : ℝ) * (Polynomial.X ^ 2 - 1) ^ k * Polynomial.X ^ (n - 2 * k))) := by
      simp_all +decide [ Polynomial.eval_finset_sum ];
    have h_poly_eq : (Chebyshev.T ℝ n) = (∑ k ∈ Finset.range (n / 2 + 1), Polynomial.C ((Nat.choose n (2 * k)) : ℝ) * (Polynomial.X ^ 2 - 1) ^ k * Polynomial.X ^ (n - 2 * k)) := by
      exact Polynomial.eq_of_infinite_eval_eq _ _ ( Set.Infinite.mono h_poly_eq <| Set.Ici_infinite 1 );
    exact Polynomial.map_injective ( algebraMap ℤ ℝ ) Int.cast_injective <| by simpa [ Polynomial.map_sum, Polynomial.map_mul, Polynomial.map_pow, Polynomial.map_X, Polynomial.map_C ] using h_poly_eq;

/-
The coefficients of T_p(x+1) are divisible by p for 1 <= k < p.
-/
theorem lemma_Tp_shifted_coeffs_divisible_p (p : ℕ) (hp : p.Prime) (k : ℕ) (hk1 : 1 ≤ k) (hkp : k < p) :
  (p : ℤ) ∣ ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff k := by
    -- By the properties of binomial coefficients and the explicit formula for $T_p(x)$, we can show that the coefficient of $x^k$ in $T_p(x+1)$ is divisible by $p$ for $1 \leq k < p$.
    have h_coeff : ∀ k ∈ Finset.Ico 1 p, (p : ℤ) ∣ Polynomial.coeff (Polynomial.comp (Chebyshev.T ℤ p) (Polynomial.X + 1)) k := by
      intro k hk
      have h_binom : ∀ k ∈ Finset.Ico 1 p, (p : ℤ) ∣ Polynomial.coeff (Polynomial.comp (Chebyshev.T ℤ p) (Polynomial.X + 1)) k := by
        have h_explicit : Chebyshev.T ℤ p = ∑ k ∈ Finset.range (p / 2 + 1), Polynomial.C (Nat.choose p (2 * k) : ℤ) * (Polynomial.X ^ 2 - 1) ^ k * Polynomial.X ^ (p - 2 * k) := by
          -- Apply the explicit sum formula for Chebyshev polynomials with n = p.
          apply lemma_T_explicit_sum
        simp +zetaDelta at *;
        intro k hk1 hk2; rw [ h_explicit ] ; simp +decide [ Polynomial.comp, Polynomial.eval₂_finset_sum ] ;
        refine' Finset.dvd_sum fun i hi => _;
        by_cases hi' : 2 * i = 0 ∨ 2 * i = p <;> simp_all +decide [ Polynomial.coeff_C, Polynomial.coeff_X, mul_assoc, pow_add ];
        · aesop;
          · norm_num [ Polynomial.coeff_X_add_one_pow ];
            exact_mod_cast hp.dvd_choose_self ( by linarith ) ( by linarith );
          · simp_all +decide [ Nat.prime_mul_iff ];
            interval_cases k ; norm_num [ Polynomial.coeff_one, Polynomial.coeff_X, add_sq ];
        · exact dvd_mul_of_dvd_left ( mod_cast hp.dvd_choose_self ( by aesop ) ( by omega ) ) _
      exact h_binom k hk;
    -- Apply the hypothesis `h_coeff` with the given `k` and the fact that `k` is in the range `1` to `p-1`.
    apply h_coeff; exact Finset.mem_Ico.mpr ⟨hk1, hkp⟩

/-
The coefficient of x in T_p(x+1) is p^2.
-/
theorem lemma_Tp_shifted_coeff_one (p : ℕ) :
  ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 = (p : ℤ)^2 := by
    norm_num [ Polynomial.comp, Polynomial.eval₂_eq_sum_range ];
    -- The sum of the coefficients of $T_p(x)$ multiplied by $x$ is the derivative of $T_p(x)$ evaluated at $x=1$.
    have h_deriv : ∑ x ∈ Finset.range ((Chebyshev.T ℤ p).natDegree + 1), (Chebyshev.T ℤ p).coeff x * x = (Polynomial.derivative (Chebyshev.T ℤ p)).eval 1 := by
      norm_num [ Polynomial.derivative_eval ];
      rw [ Polynomial.sum_over_range ];
      norm_num;
    convert h_deriv using 1;
    · norm_num [ Polynomial.coeff_X_add_one_pow ];
    · exact?

/-
The coefficient of x^2 in T_p(x+1) is p^2(p^2-1)/6.
-/
theorem lemma_Tp_shifted_coeff_two (p : ℕ) (hp : p.Prime) (hp_odd : p ≠ 2) :
  ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 2 = (p : ℤ)^2 * ((p : ℤ)^2 - 1) / 6 := by
    -- The coefficient of $x^2$ in $T_p(x+1)$ is $T_p''(1)/2$.
    have h_coeff_x2 : ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 2 = (Polynomial.derivative (Polynomial.derivative (Chebyshev.T ℤ p))).eval 1 / 2 := by
      -- The coefficient of $x^2$ in $P(x) = T_p(x+1)$ is given by $P''(0)/2!$.
      have h_coeff_x2 : ∀ P : Polynomial ℤ, P.coeff 2 = (Polynomial.derivative (Polynomial.derivative P)).eval 0 / 2 := by
        simp +decide [ Polynomial.eval, Polynomial.coeff_derivative ];
      convert h_coeff_x2 _ using 2 ; norm_num [ Polynomial.derivative_comp ];
    -- Substitute the value of the second derivative from `lemma_T_second_derivative_eval_one`.
    have h_second_deriv : (Polynomial.derivative (Polynomial.derivative (Chebyshev.T ℤ p))).eval 1 = (p ^ 2 * (p ^ 2 - 1)) / 3 := by
      exact?;
    grind

/-
The p-adic valuation of the coefficient of x^2 in T_p(x+1) is 2 for p >= 5.
-/
theorem lemma_valuation_Tp_shifted_coeff_two_val (p : ℕ) (hp : p.Prime) (hp_ge_5 : p ≥ 5) :
  multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 2) = 2 := by
    -- Since $p$ divides $p^2$ and not $p^2-1$, the multiplicity of $p$ in $p^2(p^2-1)$ is $2$.
    have h_mult : multiplicity (p : ℤ) (p^2 * (p^2 - 1)) = 2 := by
      rw [ multiplicity_mul ];
      · -- Since $p$ is a prime, the multiplicity of $p$ in $p^2$ is $2$.
        have h_mult_p2 : multiplicity (p : ℤ) (p^2) = 2 := by
          norm_num [ multiplicity, hp.ne_zero, hp.ne_one ];
          rw [ emultiplicity_pow_self ] <;> aesop;
          exact absurd a ( mod_cast hp.not_isUnit );
        rw [ h_mult_p2, multiplicity_eq_zero.mpr ] <;> norm_num;
        rw [ dvd_sub_right ( dvd_pow_self _ two_ne_zero ) ] ; norm_cast ; exact Nat.Prime.not_dvd_one hp;
      · exact Nat.prime_iff_prime_int.mp hp;
      · norm_num [ Int.finiteMultiplicity_iff ];
        exact ⟨ hp.ne_one, hp.ne_zero, sub_ne_zero_of_ne <| by norm_cast; nlinarith ⟩;
    have h_div : (p^2 * (p^2 - 1) : ℤ) = 6 * (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 2) := by
      rw [ lemma_Tp_shifted_coeff_two ];
      · rw [ Int.mul_ediv_cancel' ];
        rw [ Int.dvd_iff_emod_eq_zero ] ; norm_num [ Int.sub_emod, Int.mul_emod, sq ] ; have := Int.emod_nonneg p ( by decide : ( 6 : ℤ ) ≠ 0 ) ; have := Int.emod_lt_of_pos p ( by decide : ( 6 : ℤ ) > 0 ) ; interval_cases ( p % 6 : ℤ ) <;> trivial;
      · assumption;
      · linarith;
    have h_not_div : ¬(p : ℤ) ∣ 6 := by
      norm_cast; intro H; have := Nat.le_of_dvd ( by decide ) H; interval_cases p <;> trivial;
    rw [ multiplicity ] at *;
    rw [ h_div, emultiplicity_mul ] at h_mult ; aesop;
    · rw [ emultiplicity_eq_zero.mpr ] at h_mult <;> aesop;
    · exact Nat.prime_iff_prime_int.mp hp

/-
For p >= 5, the valuation of the quadratic term in T_p(x+1) is strictly greater than the linear term.
-/
theorem lemma_valuation_Tp_shifted_term_two (p : ℕ) (hp : p.Prime) (hp_ge_5 : p ≥ 5) (x : ℤ) (hx_dvd : (p : ℤ) ∣ x) (hx_ne_0 : x ≠ 0) :
  multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 2 * x ^ 2) > multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x ^ 1) := by
    rw [ multiplicity_mul, multiplicity_mul ];
    · -- Apply the valuation properties to split the inequality into two parts.
      have h_val_part1 : multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 2) = 2 := by
        convert lemma_valuation_Tp_shifted_coeff_two_val p hp hp_ge_5 using 1
      have h_val_part2 : multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1) = 2 := by
        -- The coefficient of x^1 in T_p(x+1) is p^2.
        have h_coeff_one : ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 = (p : ℤ) ^ 2 := by
          exact?;
        rw [ h_coeff_one, multiplicity ];
        rw [ emultiplicity_pow_self ] <;> aesop_cat;
      simp [h_val_part1, h_val_part2];
      rw [ sq, multiplicity_mul ];
      · refine' lt_add_of_pos_right _ _;
        exact?;
      · exact Nat.prime_iff_prime_int.mp hp;
      · haveI := Fact.mk hp; rw [ Int.finiteMultiplicity_iff ] ; aesop;
    · exact Nat.prime_iff_prime_int.mp hp;
    · -- Since $p \neq 2$, we know that $p^2$ is not zero.
      have h_Tp1_ne_zero : ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 ≠ 0 := by
        rw [ lemma_Tp_shifted_coeff_one ] ; positivity;
      refine' Int.finiteMultiplicity_iff.mpr _;
      exact ⟨ by linarith [ abs_of_pos ( by linarith : 0 < ( p : ℤ ) ) ], mul_ne_zero h_Tp1_ne_zero ( pow_ne_zero 1 hx_ne_0 ) ⟩;
    · exact Nat.prime_iff_prime_int.mp hp;
    · refine' Int.finiteMultiplicity_iff.mpr _;
      aesop;
      have h_coeff_two : ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 2 = (p : ℤ)^2 * ((p : ℤ)^2 - 1) / 6 := by
        convert lemma_Tp_shifted_coeff_two p hp ( by aesop_cat ) using 1;
      exact absurd a ( by rw [ h_coeff_two ] ; exact ne_of_gt ( Int.le_ediv_of_mul_le ( by norm_num ) ( by nlinarith [ Nat.pow_le_pow_left hp_ge_5 2 ] ) ) )

theorem wniosek (n : ℕ) (a : ℤ) (hn : n > 1) (ha : |a| > 1) :
  (¬ ∃ p : ℕ, p.Prime ∧ n = Che p a ∧ ¬ p ∣ n) ↔
  (∃ p : ℕ, p.Prime ∧ p ∣ n ∧ ∃ k : ℕ, |(OmegaZ n).eval a| = p ^ k) := by
    -- Assume there's no prime p such that n = Che p a and p does not divide n.
    by_cases h : ∃ p : ℕ, p.Prime ∧ n = Che p a ∧ ¬p ∣ n;
    · bound;
      · aesop;
      · -- Applying the lemma if_T_then_Omega, we know that w_3 divides |eval a (OmegaZ (Che w a))|.
        have h_w3_div : (w_3 : ℤ) ∣ |eval a (OmegaZ (Che w a))| := by
          -- Applying the lemma if_T_then_Omega, we know that w_3 divides |eval a (OmegaZ (Che w a))| because w_3 is a primitive prime divisor of T_Che w a(a) - 1.
          have h_w3_div : (w_3 : ℤ) ∣ (eval a (OmegaZ (Che w a))) := by
            have h_primitive : is_primitive_prime_divisor_Chebyshev a (Che w a) w_3 := by
              constructor <;> aesop;
              · exact?;
              · -- By definition of Che, we know that Che w_3 a divides d.
                have h_che_div_d : Che w_3 a ∣ d := by
                  have h_che_div_d : (w_3 : ℤ) ∣ (eval a (Chebyshev.T ℤ d)) - 1 := by
                    bound;
                  exact?;
                linarith [ Nat.le_of_dvd a_1 h_che_div_d ]
            apply if_T_then_Omega;
            · linarith;
            · assumption;
          exact?;
        simp_all +decide [ Int.natCast_dvd ];
        exact absurd ( left_3.dvd_of_dvd_pow h_w3_div ) ( by intro h; have := Nat.prime_dvd_prime_iff_eq left_3 left_1; aesop );
    · -- If $V = |eval a (OmegaZ n)|$ is greater than 1, then any prime divisor $q$ of $V$ must be a prime divisor of $n$.
      have h_prime_divisors : ∀ q : ℕ, Nat.Prime q → q ∣ Int.natAbs ((OmegaZ n).eval a) → q ∣ n := by
        intros q hq hq_div
        obtain ⟨i, hi⟩ : ∃ i : ℕ, n = Che q a * q ^ i := by
          have := Satz_1_part1 n a hn ha q hq ( Int.natCast_dvd.mpr hq_div ) ; aesop;
        rcases i with ( _ | i ) <;> simp_all +decide [ Nat.Prime.dvd_mul ];
      -- If $V = |eval a (OmegaZ n)|$ is greater than 1, then all prime factors of $V$ must be equal to the maximum prime divisor of $n$.
      have h_all_prime_factors : ∀ q : ℕ, Nat.Prime q → q ∣ Int.natAbs ((OmegaZ n).eval a) → q = max_prime_divisor n := by
        intro q hq hq_div
        obtain ⟨i, hi⟩ : ∃ i : ℕ, n = Che q a * q ^ i := by
          convert Satz_1_part1 n a hn ha q hq ( Int.natCast_dvd.mpr hq_div ) using 1;
        by_cases hi_pos : i > 0;
        · apply_rules [ Satz_1_part2 ];
          exact Int.natCast_dvd.mpr hq_div;
        · -- If $i = 0$, then $n = Che q a$. By prop_Che, $q$ cannot be odd (as $Che q a$ is coprime to $q$ for odd $q$). So $q = 2$.
          have hq_eq_two : q = 2 := by
            have := prop_Che q hq a; aesop;
            by_cases hq_even : q = 2 <;> simp_all +decide [ Nat.coprime_iff_gcd_eq_one ];
            exact absurd ( Nat.dvd_gcd ( h_prime_divisors q hq hq_div ) ( dvd_refl q ) ) ( by aesop );
          have := prop_Che 2 Nat.prime_two a; aesop;
          cases' Int.even_or_odd a with h h <;> aesop;
          native_decide +revert;
      -- If $V = |eval a (OmegaZ n)|$ is greater than 1, then it must have at least one prime factor. Let's take that prime factor $q$.
      by_cases hV : Int.natAbs ((OmegaZ n).eval a) > 1;
      · obtain ⟨q, hq_prime, hq_div⟩ : ∃ q : ℕ, Nat.Prime q ∧ q ∣ Int.natAbs ((OmegaZ n).eval a) := by
          exact Nat.exists_prime_and_dvd hV.ne';
        have hV_power : ∃ k : ℕ, Int.natAbs ((OmegaZ n).eval a) = q ^ k := by
          have hV_power : ∀ r : ℕ, Nat.Prime r → r ∣ Int.natAbs ((OmegaZ n).eval a) → r = q := by
            exact fun r hr hr_div => h_all_prime_factors r hr hr_div ▸ h_all_prime_factors q hq_prime hq_div ▸ rfl;
          exact ⟨ Nat.primeFactorsList ( Int.natAbs ( Polynomial.eval a ( OmegaZ n ) ) ) |> List.count q, by nth_rw 1 [ ← Nat.prod_primeFactorsList ( by linarith : Int.natAbs ( Polynomial.eval a ( OmegaZ n ) ) ≠ 0 ) ] ; rw [ List.prod_eq_pow_single q ] ; aesop ⟩;
        exact iff_of_true h ⟨ q, hq_prime, h_prime_divisors q hq_prime hq_div, hV_power.choose, by simpa [ ← Int.natCast_inj ] using hV_power.choose_spec ⟩;
      · interval_cases _ : Int.natAbs ( Polynomial.eval a ( OmegaZ n ) ) <;> simp_all +decide;
        · exact absurd ( h_all_prime_factors 2 Nat.prime_two ) ( by linarith [ h_all_prime_factors 3 Nat.prime_three ] );
        · exact ⟨ Nat.minFac n, Nat.minFac_prime hn.ne', Nat.minFac_dvd n, 0, by norm_cast; rw [ Int.natAbs_eq_iff ] at *; aesop ⟩

/-
Definitions of the exception condition and the specific forms of OmegaZ for n=2, 3, 4, 6.
-/
def is_exception_fixed (n : ℕ) (a : ℤ) : Prop :=
  (a = 1 ∧ n > 1) ∨
  (a = 0 ∧ n ≠ 2 ∧ n ≠ 4) ∨
  (a = -1 ∧ n > 2) ∨
  (n = 1 ∧ (a = 0 ∨ a = 2)) ∨
  (n = 2 ∧ ∃ k : ℕ, k > 1 ∧ (a = (2 : ℤ)^(k - 1) - 1 ∨ a = -(2 : ℤ)^(k - 1) - 1)) ∨
  (n = 3 ∧ ∃ k : ℕ, k > 0 ∧ (2 * a = (3 : ℤ)^k - 1 ∨ 2 * a = -(3 : ℤ)^k - 1)) ∨
  (n = 4 ∧ ∃ k : ℕ, k > 0 ∧ (a = (2 : ℤ)^(k - 1) ∨ a = -(2 : ℤ)^(k - 1))) ∨
  (n = 6 ∧ ∃ k : ℕ, k > 0 ∧ (2 * a = (3 : ℤ)^k + 1 ∨ 2 * a = -(3 : ℤ)^k + 1))

lemma OmegaZ_two : OmegaZ 2 = 2 * Polynomial.X + 2 := by
  -- By definition of OmegaZ, we know that OmegaZ 2 is the polynomial with integer coefficients that corresponds to Omega 2.
  have h_OmegaZ_2 : OmegaZ 2 = 2 * Polynomial.X + 2 := by
    have h_Omega_2 : Omega 2 = 2 * Polynomial.X + 2 := by
      -- By definition of Omega, we know that Omega 2 = 2 * (X - cos(2 * 1 * π / 2)).
      simp [Omega];
      -- Since the set {1} only contains one element, which is 1, and 1 is odd, the product simplifies to the term for x=1.
      simp [Finset.prod_filter, Finset.prod_singleton];
      exact?
    -- By definition of OmegaZ, we know that OmegaZ 2 is the polynomial with integer coefficients that corresponds to Omega 2. Using the lemma Omega_eq_map_OmegaZ, we can conclude that OmegaZ 2 must be 2 * X + 2.
    have h_OmegaZ_2 : (OmegaZ 2).map (algebraMap ℤ ℝ) = 2 * Polynomial.X + 2 := by
      rw [ ← h_Omega_2, Omega_eq_map_OmegaZ ];
    exact Polynomial.map_injective ( algebraMap ℤ ℝ ) Int.cast_injective <| by simpa using h_OmegaZ_2;
  bound
lemma OmegaZ_three : OmegaZ 3 = 2 * Polynomial.X + 1 := by
  -- By definition of OmegaZ, we know that OmegaZ 3 is the polynomial with integer coefficients that corresponds to Omega 3.
  have h_OmegaZ_3 : OmegaZ 3 = 2 * Polynomial.X + 1 := by
    have h_Omega_3 : Omega 3 = 2 * Polynomial.X + 1 := by
      unfold Omega; norm_num [ Finset.prod_filter, Finset.prod_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ] ; ring;
      exact Polynomial.funext fun x => by norm_num [ ( by ring : Real.pi * ( 2 / 3 ) = Real.pi - Real.pi / 3 ) ] ; ring;
    convert h_Omega_3 using 1;
    bound;
    convert Polynomial.map_injective ( algebraMap ℤ ℝ ) Int.cast_injective _;
    convert a using 1;
    · exact?;
    · norm_num [ Polynomial.ext_iff ];
  exact h_OmegaZ_3
lemma OmegaZ_four : OmegaZ 4 = 2 * Polynomial.X := by
  unfold OmegaZ;
  -- Since the support of Omega 4 is {1}, the sum simplifies to the term for i=1.
  have h_support : (Omega 4).support = {1} := by
    unfold Omega;
    norm_num [ Finset.prod_filter, Finset.prod_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ];
    norm_num [ show 2 * Real.pi / 4 = Real.pi / 2 by ring ];
    ext ( _ | _ | n ) <;> simp +decide [ Polynomial.coeff_eq_zero_of_natDegree_lt ];
  have := Classical.choose_spec ( Omega_integral 4 1 );
  unfold Omega at * ; aesop;
  -- The coefficient of $X^1$ in the polynomial $\Omega_4$ is $2$.
  simp [Finset.prod_filter, Finset.prod_range_succ, Finset.prod_range_zero] at *;
  norm_num [ Finset.prod_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ] at *;
  norm_cast at *
lemma OmegaZ_six : OmegaZ 6 = 2 * Polynomial.X - 1 := by
  -- By definition of Omega, we know that Omega 6 = 2X - 1.
  have h_omega_6 : Omega 6 = 2 * Polynomial.X - 1 := by
    unfold Omega;
    norm_num [ Finset.prod_filter, Finset.prod_Ioc_succ_top ];
    rw [ show 2 * Real.pi / 6 = Real.pi / 3 by ring, Real.cos_pi_div_three ] ; exact Polynomial.funext fun x => by norm_num ; ring;
  -- Since $\Omega_6$ is equal to $2X - 1$ and has integer coefficients, $\OmegaZ_6$ must also be equal to $2X - 1$.
  have h_omegaZ_6 : (OmegaZ 6).map (algebraMap ℤ ℝ) = 2 * Polynomial.X - 1 := by
    rw [ ← h_omega_6, Omega_eq_map_OmegaZ ];
  exact Polynomial.map_injective ( algebraMap ℤ ℝ ) Int.cast_injective <| by simpa using h_omegaZ_6;

/-
If |a+1| = 2^k, then a = 2^k - 1 or a = -2^k - 1.
-/
lemma abs_add_one_eq_pow_two (a : ℤ) (k : ℕ) (h : |a + 1| = (2 : ℤ) ^ k) :
  a = (2 : ℤ) ^ k - 1 ∨ a = -(2 : ℤ) ^ k - 1 := by
    cases abs_cases ( a + 1 ) <;> [ left; right ] <;> linarith

/-
Corrected definition of exception and lemma for n=2.
-/
def is_exception_final (n : ℕ) (a : ℤ) : Prop :=
  (a = 1 ∧ n > 1) ∨
  (a = 0 ∧ n ≠ 2 ∧ n ≠ 4) ∨
  (a = -1 ∧ n > 2) ∨
  (n = 1 ∧ (a = 0 ∨ a = 2)) ∨
  (n = 2 ∧ ∃ k : ℕ, k > 0 ∧ (a = (2 : ℤ)^(k - 1) - 1 ∨ a = -(2 : ℤ)^(k - 1) - 1)) ∨
  (n = 3 ∧ ∃ k : ℕ, k > 0 ∧ (2 * a = (3 : ℤ)^k - 1 ∨ 2 * a = -(3 : ℤ)^k - 1)) ∨
  (n = 4 ∧ ∃ k : ℕ, k > 0 ∧ (a = (2 : ℤ)^(k - 1) ∨ a = -(2 : ℤ)^(k - 1))) ∨
  (n = 6 ∧ ∃ k : ℕ, k > 0 ∧ (2 * a = (3 : ℤ)^k + 1 ∨ 2 * a = -(3 : ℤ)^k + 1))

lemma prime_power_implies_exception_n2_final (a : ℤ) (ha : |a| > 1) (p : ℕ) (hp : p.Prime) (hpn : p ∣ 2) (k : ℕ) (h_eq : |(OmegaZ 2).eval a| = p ^ k) : is_exception_final 2 a := by
  rw [ Nat.dvd_prime ( by decide ) ] at hpn;
  unfold is_exception_final; aesop;
  -- Since $|2a + 2| = 2^k$, we have $2a + 2 = \pm 2^k$.
  have h_abs : 2 * a + 2 = 2^k ∨ 2 * a + 2 = -2^k := by
    exact eq_or_eq_neg_of_abs_eq ( by simpa [ show ( OmegaZ 2 : Polynomial ℤ ) = 2 * Polynomial.X + 2 by exact? ] using h_eq );
  rcases k with ( _ | k ) <;> norm_num [ pow_succ' ] at *;
  · omega;
  · -- In both cases, we can choose $k$ to be the same as in the equation.
    cases' h_abs with h_case1 h_case2;
    · exact Or.inr ⟨ k + 1, Nat.succ_pos _, Or.inl <| by norm_num; linarith ⟩;
    · exact Or.inr ⟨ k + 1, Nat.succ_pos _, Or.inr <| by norm_num [ pow_succ' ] at *; linarith ⟩

lemma prime_power_implies_exception_n3 (a : ℤ) (ha : |a| > 1) (p : ℕ) (hp : p.Prime) (hpn : p ∣ 3) (k : ℕ) (h_eq : |(OmegaZ 3).eval a| = p ^ k) : is_exception_final 3 a := by
  have := Nat.le_of_dvd ( by decide ) hpn; interval_cases p <;> norm_num at *;
  -- Since $|2a + 1| = 3^k$, we have $2a + 1 = \pm 3^k$.
  have h_cases : 2 * a + 1 = 3 ^ k ∨ 2 * a + 1 = -3 ^ k := by
    have h_cases : |2 * a + 1| = 3 ^ k := by
      convert h_eq using 1 ; norm_num [ OmegaZ_three ];
    exact eq_or_eq_neg_of_abs_eq h_cases;
  unfold is_exception_final; aesop;
  · exact Or.inr <| Or.inr <| Or.inr <| ⟨ k, Nat.pos_of_ne_zero <| by rintro rfl; cases abs_cases a <;> linarith, Or.inl <| by linarith ⟩;
  · exact Or.inr <| Or.inr <| Or.inr <| ⟨ k, Nat.pos_of_ne_zero <| by rintro rfl; cases abs_cases a <;> linarith, Or.inr <| by linarith ⟩

lemma prime_power_implies_exception_n4 (a : ℤ) (ha : |a| > 1) (p : ℕ) (hp : p.Prime) (hpn : p ∣ 4) (k : ℕ) (h_eq : |(OmegaZ 4).eval a| = p ^ k) : is_exception_final 4 a := by
  -- Since $|2a| = 2^k$, we have $|a| = 2^{k-1}$.
  have h_abs : |a| = 2 ^ (k - 1) := by
    -- Since $|2a| = 2 * |a|$, we can substitute this into the equation to get $2 * |a| = 2^k$.
    have h_abs_eq : 2 * |a| = 2 ^ k := by
      rw [ show OmegaZ 4 = 2 * Polynomial.X from ?_ ] at h_eq ; norm_num at h_eq ; aesop;
      · have := Nat.le_of_dvd ( by decide ) hpn; interval_cases p <;> norm_num at *;
      · -- By definition of OmegaZ, we know that OmegaZ 4 = 2 * X.
        apply OmegaZ_four;
    cases k <;> simp_all +decide [ pow_succ' ] ; linarith;
  -- Since $|a| = 2^{k-1}$ and $|a| > 1$, we have $a = 2^{k-1}$ or $a = -2^{k-1}$.
  have h_cases : a = 2 ^ (k - 1) ∨ a = -2 ^ (k - 1) := by
    -- Since $|a| = 2^{k-1}$, we have $a = 2^{k-1}$ or $a = -2^{k-1}$ by the definition of absolute value.
    apply eq_or_eq_neg_of_abs_eq h_abs;
  rcases k with ( _ | _ | k ) <;> simp_all +decide [ is_exception_final ];
  -- In both cases, we can find such a $k'$.
  right; right; use k + 2; norm_num; aesop

lemma prime_power_implies_exception_n6 (a : ℤ) (ha : |a| > 1) (p : ℕ) (hp : p.Prime) (hpn : p ∣ 6) (k : ℕ) (h_eq : |(OmegaZ 6).eval a| = p ^ k) : is_exception_final 6 a := by
  -- Since p divides 6, p must be 2 or 3. We consider both cases.
  by_cases hp2 : p = 2;
  · -- If $p=2$, then $|2a-1|=2^k$. We have $2a-1=\pm 2^k$.
    have h_cases : 2 * a - 1 = (2 : ℤ) ^ k ∨ 2 * a - 1 = -(2 : ℤ) ^ k := by
      -- Since $|2a - 1| = 2^k$, we have $2a - 1 = 2^k$ or $2a - 1 = -2^k$.
      have h_cases : |2 * a - 1| = 2 ^ k := by
        bound;
        convert h_eq using 1;
        rw [ show OmegaZ 6 = 2 * Polynomial.X - 1 from by exact? ] ; norm_num;
      -- Apply the definition of absolute value: if |x| = y, then x = y or x = -y.
      apply eq_or_eq_neg_of_abs_eq h_cases;
    rcases k with ( _ | _ | k ) <;> simp_all +decide [ pow_succ' ];
    · cases h_cases <;> cases abs_cases a <;> linarith;
    · omega;
    · omega;
  · -- Since p divides 6 and p is not 2, the only remaining possibility is p = 3.
    have hp3 : p = 3 := by
      have := Nat.le_of_dvd ( by decide ) hpn; interval_cases p <;> trivial;
    -- Since $|2a - 1| = 3^k$, we have $2a - 1 = 3^k$ or $2a - 1 = -3^k$.
    have h_cases : 2 * a - 1 = 3 ^ k ∨ 2 * a - 1 = -3 ^ k := by
      exact eq_or_eq_neg_of_abs_eq ( by simpa [ hp3, abs_mul, abs_two, OmegaZ_six ] using h_eq );
    unfold is_exception_final; aesop;
    · grind +ring;
    · grind

/-
Arithmetic inequality: 1 + kv > 2 + v for k >= 3, v >= 1.
-/
theorem arithmetic_ineq_valuation (k v : ℕ) (hk : k ≥ 3) (hv : v ≥ 1) : 1 + k * v > 2 + v := by
  nlinarith

/-
The p-adic valuation of the linear term of T_p(x+1) is 2 + v_p(x).
-/
theorem valuation_Tp_shifted_linear_term (p : ℕ) (hp : p.Prime) (x : ℤ) (hx : x ≠ 0) :
  multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x) = 2 + multiplicity (p : ℤ) x := by
    have h_val : multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1) = 2 := by
      have h_val : ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 = (p : ℤ)^2 := by
        exact?;
      aesop;
      rw [ multiplicity_pow_self ] ; aesop;
      exact mod_cast hp.not_isUnit;
    rw [ multiplicity_mul ] ; aesop;
    · exact Nat.prime_iff_prime_int.mp hp;
    · refine' Int.finiteMultiplicity_iff.mpr _;
      aesop

/-
If p divides n and n is non-zero, then the p-adic valuation of n is at least 1.
-/
theorem valuation_ge_one_of_dvd (p : ℕ) (hp : p.Prime) (n : ℤ) (h : (p : ℤ) ∣ n) (hn : n ≠ 0) : multiplicity (p : ℤ) n ≥ 1 := by
  contrapose! h;
  simp_all +decide [ multiplicity ];
  erw [ WithTop.untopD_eq_iff ] at h ; aesop;
  rw [ emultiplicity_eq_zero ] at h ; aesop

/-
The p-adic valuation of x^k is k times the p-adic valuation of x.
-/
theorem valuation_pow_int (p : ℕ) (hp : p.Prime) (x : ℤ) (k : ℕ) (hx : x ≠ 0) : multiplicity (p : ℤ) (x ^ k) = k * multiplicity (p : ℤ) x := by
  haveI := Fact.mk hp; simp +decide [ multiplicity, hx ] ;
  rw [ emultiplicity_pow ];
  · unfold emultiplicity; aesop;
    exact absurd ( h ( Nat.log p ( x.natAbs ) ) ) ( by simpa [ hx ] using Int.natCast_dvd.not.mpr ( Nat.not_dvd_of_pos_of_lt ( Int.natAbs_pos.mpr hx ) ( Nat.lt_pow_succ_log_self hp.one_lt _ ) ) );
  · exact Nat.prime_iff_prime_int.mp hp

/-
Checking PartENat and multiplicity types.
-/
#check PartENat
#check multiplicity

/-
The p-adic valuation of the linear term of T_p(x+1) is 2 + v_p(x).
-/
theorem valuation_Tp_shifted_linear (p : ℕ) (hp : p.Prime) (x : ℤ) (hx : x ≠ 0) :
  multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x) = 2 + multiplicity (p : ℤ) x := by
    have h_val_linear : multiplicity (p : ℤ) (p ^ 2 * x) = 2 + multiplicity (p : ℤ) x := by
      rw [ multiplicity_mul ];
      · haveI := Fact.mk hp; simp ( config := { decide := Bool.true } ) [ multiplicity ] ;
        rw [ emultiplicity_pow_self ] ; aesop;
        · aesop;
        · rw [ isUnit_iff_dvd_one ] ; exact mod_cast hp.not_dvd_one;
      · exact Nat.prime_iff_prime_int.mp hp;
      · exact Int.finiteMultiplicity_iff.mpr ⟨ mod_cast hp.ne_one, by aesop ⟩;
    have := lemma_Tp_shifted_coeff_one p; aesop;

/-
For p >= 5 and p|x, the valuation of the quadratic term of T_p(x+1) is strictly greater than the linear term.
-/
theorem valuation_Tp_shifted_quadratic (p : ℕ) (hp : p.Prime) (hp5 : p ≥ 5) (x : ℤ) (hx : (p : ℤ) ∣ x) (hx0 : x ≠ 0) :
  multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 2 * x ^ 2) > multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x) := by
    have := @lemma_valuation_Tp_shifted_term_two p hp hp5 x;
    aesop

/-
For p >= 5 and p|x, the valuation of the k-th term (3 <= k < p) in T_p(x+1) is strictly greater than the linear term.
-/
theorem valuation_Tp_shifted_higher_terms_lt_p (p : ℕ) (hp : p.Prime) (hp5 : p ≥ 5) (x : ℤ) (hx : (p : ℤ) ∣ x) (hx0 : x ≠ 0) (k : ℕ) (hk3 : 3 ≤ k) (hkp : k < p) :
  multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff k * x ^ k) > multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x) := by
    -- Apply the lemma that states the valuation of the k-th term is strictly greater than the linear term.
    have := lemma_Tp_shifted_coeffs_divisible_p p hp k (by linarith) (by linarith);
    -- The p-adic valuation of the k-th term is at least 1 + k * multiplicity(p, x).
    have h_val_k : multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff k * x ^ k) ≥ 1 + k * multiplicity (p : ℤ) x := by
      rw [ multiplicity_mul ];
      · have h_val_k : multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff k) ≥ 1 := by
          exact multiplicity_pos_of_dvd this |> fun h => h.ne' |> fun h' => Nat.pos_of_ne_zero h';
        rw [ valuation_pow_int ] <;> aesop;
      · exact Nat.prime_iff_prime_int.mp hp;
      · haveI := Fact.mk hp; erw [ Int.finiteMultiplicity_iff ] ; aesop;
        have := @lemma_T_explicit_sum p; simp_all +decide [ Polynomial.coeff_one, Polynomial.coeff_X, Polynomial.coeff_C, Finset.sum_range_succ' ] ;
        norm_num [ Polynomial.coeff_X_add_one_pow ] at a;
        norm_cast at a;
        norm_num [ add_sq, mul_assoc, Polynomial.coeff_X_add_one_pow ] at a;
        bound;
        norm_cast at a;
        rw [ add_eq_zero_iff_of_nonneg ] at a;
        · exact absurd a.2 ( Nat.cast_ne_zero.mpr ( Nat.ne_of_gt ( Nat.choose_pos ( by linarith ) ) ) );
        · refine' Finset.sum_nonneg fun _ _ => mul_nonneg ( Nat.cast_nonneg _ ) _;
          rw [ Polynomial.coeff_mul ];
          refine' Finset.sum_nonneg fun _ _ => mul_nonneg _ _ <;> norm_num [ Polynomial.coeff_X_add_one_pow ];
          rw [ add_pow ];
          norm_num [ ← pow_mul ];
          refine' Finset.sum_nonneg fun _ _ => mul_nonneg _ _ <;> norm_num [ Polynomial.coeff_mul ];
          refine' Finset.sum_nonneg fun _ _ => _ ; aesop;
          rw [ mul_pow ];
          rw [ Polynomial.coeff_mul, Finset.sum_eq_single ( 0, snd_1 ) ] <;> aesop;
          · norm_num [ Polynomial.coeff_zero_eq_eval_zero ];
          · rw [ Polynomial.coeff_eq_zero_of_natDegree_lt ] ; aesop;
            positivity;
        · positivity;
    -- Substitute the known valuations into the inequality.
    have h_subst : 1 + k * multiplicity (p : ℤ) x > 2 + multiplicity (p : ℤ) x := by
      have h_val_x : multiplicity (p : ℤ) x ≥ 1 := by
        exact?;
      nlinarith;
    exact lt_of_le_of_lt ( by rw [ valuation_Tp_shifted_linear p hp x hx0 ] ) ( h_subst.trans_le h_val_k )

/-
The leading coefficient of the n-th Chebyshev polynomial T_n (over integers) is 2^(n-1) for n >= 1.
-/
theorem lemma_leading_coeff_Tn_int (n : ℕ) (hn : n > 0) :
  (Chebyshev.T ℤ n).leadingCoeff = 2 ^ (n - 1) := by
    induction' n using Nat.strong_induction_on with n ih;
    rcases n with ( _ | _ | _ | n ) <;> simp_all +decide [ pow_succ' ];
    · erw [ Chebyshev.T_two ];
      erw [ Polynomial.leadingCoeff_sub_of_degree_lt ] <;> norm_num;
      · erw [ Polynomial.leadingCoeff_C ] ; norm_num;
      · erw [ Polynomial.degree_C ] <;> norm_num;
    · -- For the inductive step, we know that the leading coefficient of $T_{n+3}(x)$ is $2$ times the leading coefficient of $T_{n+2}(x)$.
      have h_leading_coeff_succ : Polynomial.leadingCoeff (Chebyshev.T ℤ (n + 3)) = 2 * Polynomial.leadingCoeff (Chebyshev.T ℤ (n + 2)) := by
        erw [ show ( Chebyshev.T ℤ ( n + 3 ) : Polynomial ℤ ) = 2 * Polynomial.X * Chebyshev.T ℤ ( n + 2 ) - Chebyshev.T ℤ ( n + 1 ) from ?_, Polynomial.leadingCoeff_sub_of_degree_lt ];
        · erw [ Polynomial.leadingCoeff_mul, Polynomial.leadingCoeff_mul, Polynomial.leadingCoeff_X, Polynomial.leadingCoeff_C ] ; norm_num;
        · erw [ Polynomial.degree_mul, Polynomial.degree_C_mul_X ] <;> norm_num;
          erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> norm_num;
          · erw [ Polynomial.degree_C ] <;> norm_num;
            rw [ Polynomial.degree_eq_natDegree ] <;> norm_cast <;> aesop;
            · linarith;
            · specialize ih ( n + 1 ) ; aesop;
              simpa using ih.symm;
          · erw [ Polynomial.degree_C ] <;> norm_num;
            -- By definition of Chebyshev polynomials, we know that their degrees are equal to their indices.
            have h_deg : ∀ n : ℕ, Polynomial.degree (Chebyshev.T ℤ n) = n := by
              intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Polynomial.degree_eq_natDegree ];
              erw [ show ( Chebyshev.T ℤ ( n + 2 ) ) = 2 * Polynomial.X * ( Chebyshev.T ℤ ( n + 1 ) ) - ( Chebyshev.T ℤ n ) from ?_, Polynomial.degree_sub_eq_left_of_degree_lt ] <;> norm_num [ ih ];
              · erw [ Polynomial.degree_C ] <;> norm_num;
                exact ih _ ( Nat.lt_succ_self _ ) ▸ by norm_cast; ring;
              · erw [ ih n ( by linarith ), ih ( n + 1 ) ( by linarith ) ] ; norm_num;
                erw [ Polynomial.degree_C ] <;> norm_cast ; linarith;
            exact h_deg n ▸ h_deg ( n + 1 ) ▸ by norm_cast; simp +arith +decide;
        · simp +zetaDelta at *;
          erw [ Chebyshev.T ] ; ring;
          norm_num [ add_comm, add_left_comm, add_assoc, Chebyshev.T ] ; ring;
      grind +ring

/-
For p >= 5 and p|x, the valuation of the p-th term in T_p(x+1) is strictly greater than the linear term.
-/
theorem valuation_Tp_shifted_term_p (p : ℕ) (hp : p.Prime) (hp5 : p ≥ 5) (x : ℤ) (hx : (p : ℤ) ∣ x) (hx0 : x ≠ 0) :
  multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff p * x ^ p) > multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x) := by
    -- The coefficient of x^p in T_p(x+1) is the leading coefficient of T_p, which is 2^(p-1).
    have h_coeff_p : ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff p = 2 ^ (p - 1) := by
      have h_coeff_p : ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff p = (Chebyshev.T ℤ p).leadingCoeff := by
        rw [ Polynomial.comp, Polynomial.eval₂_eq_sum_range ];
        norm_num [ Polynomial.coeff_X_add_one_pow ];
        rw [ Finset.sum_eq_single p ] <;> aesop;
        · rw [ Polynomial.leadingCoeff, Polynomial.natDegree_eq_of_degree_eq_some ];
          have h_deg : ∀ n : ℕ, Polynomial.degree (Chebyshev.T ℤ n) = n := by
            intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all ( config := { decide := Bool.true } ) [ Polynomial.degree_eq_natDegree ] ;
            erw [ Chebyshev.T ];
            erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> erw [ Polynomial.degree_mul, Polynomial.degree_mul, Polynomial.degree_C, Polynomial.degree_X ] <;> norm_num [ ih ];
            · erw [ ih _ <| Nat.lt_succ_self _ ] ; norm_cast ; ring;
            · erw [ ih n ( by linarith ), ih ( n + 1 ) ( by linarith ) ] ; norm_cast ; simp +arith +decide;
          exact h_deg p;
        · exact Or.inr <| Nat.choose_eq_zero_of_lt <| lt_of_le_of_ne ( by linarith [ show Polynomial.natDegree ( Chebyshev.T ℤ p ) ≤ p from by
                                                                                      have h_deg_Tp : ∀ n : ℕ, Polynomial.natDegree (Chebyshev.T ℤ n) ≤ n := by
                                                                                        intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all ( config := { decide := Bool.true } ) [ Chebyshev.T ] ;
                                                                                        erw [ Chebyshev.T ];
                                                                                        refine' le_trans ( Polynomial.natDegree_sub_le _ _ ) _ ; norm_num;
                                                                                        exact ⟨ le_trans ( Polynomial.natDegree_mul_le .. ) ( by norm_num; linarith! [ ih _ <| Nat.lt_succ_self _, ih _ <| Nat.lt_succ_of_lt <| Nat.lt_succ_self _ ] ), by linarith! [ ih _ <| Nat.lt_succ_self _, ih _ <| Nat.lt_succ_of_lt <| Nat.lt_succ_self _ ] ⟩;
                                                                                      exact h_deg_Tp p ] ) a_1;
        · rw [ Polynomial.coeff_eq_zero_of_natDegree_lt a ];
      rw [ h_coeff_p, lemma_leading_coeff_Tn_int ] ; norm_num [ hp.pos ];
    -- Since $p \mid x$, we have $v_p(x) \geq 1$. Also, $v_p(2^{p-1}) = 0$ because $p \geq 5$.
    have h_val_p_x_ge_1 : multiplicity (p : ℤ) x ≥ 1 := by
      exact multiplicity_pos_of_dvd hx
    have h_val_p_2_pow_p_minus_1 : multiplicity (p : ℤ) (2 ^ (p - 1)) = 0 := by
      exact multiplicity_eq_zero.mpr ( by exact_mod_cast mt ( hp.dvd_of_dvd_pow ) ( Nat.not_dvd_of_pos_of_lt ( by positivity ) ( by linarith ) ) );
    -- Substitute the known values into the inequality.
    have h_subst : multiplicity (p : ℤ) (2 ^ (p - 1) * x ^ p) = p * multiplicity (p : ℤ) x ∧ multiplicity (p : ℤ) ((p : ℤ) ^ 2 * x) = 2 + multiplicity (p : ℤ) x := by
      constructor;
      · have h_subst : multiplicity (p : ℤ) (2 ^ (p - 1) * x ^ p) = multiplicity (p : ℤ) (2 ^ (p - 1)) + multiplicity (p : ℤ) (x ^ p) := by
          rw [ multiplicity_mul ];
          · exact Nat.prime_iff_prime_int.mp hp;
          · exact Int.finiteMultiplicity_iff.mpr ⟨ by aesop_cat, by aesop_cat ⟩;
        rw [ h_subst, h_val_p_2_pow_p_minus_1, zero_add, valuation_pow_int ] ; aesop;
        positivity;
      · rw [ multiplicity_mul ] <;> norm_cast ; aesop;
        · norm_num [ multiplicity, hp.ne_one ];
          rw [ emultiplicity_pow_self ] <;> aesop;
        · exact Nat.prime_iff_prime_int.mp hp;
        · exact Int.finiteMultiplicity_iff.mpr ⟨ by norm_cast; linarith [ hp.two_le ], by aesop ⟩;
    have h_coeff1 : ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 = (p : ℤ) ^ 2 := by
      convert lemma_Tp_shifted_coeff_one p using 1;
    aesop;
    nlinarith

/-
For p >= 5 and p|x, the p-adic valuation of T_p(1+x)-1 is equal to v_p(x) + 2.
-/
theorem valuation_Tp_eval_increase (p : ℕ) (hp : p.Prime) (hp5 : p ≥ 5) (x : ℤ) (hx : (p : ℤ) ∣ x) (hx0 : x ≠ 0) :
  multiplicity (p : ℤ) ((Chebyshev.T ℤ p).eval (1 + x) - 1) = multiplicity (p : ℤ) x + 2 := by
    -- Write $T_p(1+x) - 1$ as a sum of terms $c_k x^k$.
    have hT_sum : ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).eval x - 1 = ∑ k ∈ Finset.range (p + 1), ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff k * x ^ k - 1 := by
      rw [ Polynomial.eval_eq_sum_range' ];
      erw [ Polynomial.natDegree_comp, Polynomial.natDegree_X_add_C, mul_one ];
      -- The degree of $T_p(x)$ is $p$.
      have h_deg : Polynomial.natDegree (Chebyshev.T ℤ p) = p := by
        have h_deg : ∀ n : ℕ, Polynomial.natDegree (Chebyshev.T ℤ n) = n := by
          intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp +arith +decide [ *, Polynomial.natDegree_add_eq_left_of_natDegree_lt, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] ;
          erw [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> erw [ Polynomial.natDegree_mul' ] <;> norm_num [ ih ];
          · exact ih _ ( Nat.lt_succ_self _ ) ▸ by ring;
          · specialize ih ( n + 1 ) ; aesop;
          · have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; norm_num at * ; linarith;
          · specialize ih ( n + 1 ) ; aesop;
        exact h_deg p;
      linarith;
    have hvaluation : multiplicity (p : ℤ) (∑ k ∈ Finset.Ico 1 (p + 1), ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff k * x ^ k) = multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x) := by
      have hvaluation : ∀ (s : Finset ℕ), 1 ∈ s → (∀ k ∈ s, k ≠ 1 → multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff k * x ^ k) > multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x)) → multiplicity (p : ℤ) (∑ k ∈ s, ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff k * x ^ k) = multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x) := by
        intros s hs1 hs_val
        have h_div : (p : ℤ) ^ multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x) ∣ ∑ k ∈ s, ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff k * x ^ k := by
          refine' Finset.dvd_sum fun k hk => _;
          by_cases hk1 : k = 1;
          · aesop;
          · exact dvd_trans ( pow_dvd_pow _ ( le_of_lt ( hs_val k hk hk1 ) ) ) ( by simp );
        have h_not_div : ¬((p : ℤ) ^ (multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x) + 1) ∣ ∑ k ∈ s, ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff k * x ^ k) := by
          have h_not_div : ¬((p : ℤ) ^ (multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x) + 1) ∣ ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x) := by
            rw [ multiplicity ];
            rw [ emultiplicity ];
            split_ifs <;> simp_all +decide [ FiniteMultiplicity ];
            · have := Nat.find_spec ‹_›;
              convert this using 1;
              erw [ WithTop.untopD_coe ] ; norm_cast;
            · rename_i h; specialize h ( Int.natAbs ( ( Chebyshev.T ℤ p |> Polynomial.comp <| Polynomial.X + 1 |> Polynomial.comp <| Polynomial.X ) |> Polynomial.coeff <| 1 ) * Int.natAbs x ) ; simp_all +decide [ ← Int.natCast_dvd_natCast ] ;
              have := Int.natAbs_dvd_natAbs.mpr h; simp_all +decide [ Int.natAbs_mul, Nat.Prime.pow_dvd_iff_le_factorization ] ;
              rw [ Nat.Prime.pow_dvd_iff_le_factorization ] at this <;> norm_num at *;
              · exact this.not_lt ( Nat.lt_succ_of_le ( Nat.le_of_lt ( Nat.factorization_lt _ ( by aesop ) ) ) );
              · assumption;
              · bound;
                have := lemma_Tp_shifted_coeff_one p; simp_all +decide [ Polynomial.coeff_one, Polynomial.coeff_X, add_mul ] ;
          have h_not_div : ∀ k ∈ s, k ≠ 1 → ((p : ℤ) ^ (multiplicity (p : ℤ) (((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff 1 * x) + 1)) ∣ ((Chebyshev.T ℤ p).comp (Polynomial.X + 1)).coeff k * x ^ k := by
            intro k hk hk'; specialize hs_val k hk hk'; rw [ multiplicity ] at hs_val; aesop;
            rw [ emultiplicity ] at hs_val ; aesop;
            erw [ WithTop.untopD_coe ] at hs_val ; aesop;
          rw [ Finset.sum_eq_add_sum_diff_singleton hs1 ];
          rw [ Int.dvd_add_left ( Finset.dvd_sum fun k hk => h_not_div k ( Finset.mem_sdiff.mp hk |>.1 ) ( by aesop ) ) ] ; aesop;
        rw [ multiplicity_eq_of_dvd_of_not_dvd ] <;> aesop;
      apply hvaluation; simp [Finset.mem_Ico];
      · linarith;
      · intros k hk hk_ne_one
        by_cases hk_p : k < p;
        · by_cases hk3 : 3 ≤ k;
          · convert valuation_Tp_shifted_higher_terms_lt_p p hp hp5 x hx hx0 k hk3 hk_p using 1;
          · interval_cases k <;> simp_all +decide only [multiplicity];
            · norm_num at hk;
            · convert valuation_Tp_shifted_quadratic p hp hp5 x hx hx0 using 1;
        · norm_num [ show k = p by linarith [ Finset.mem_Ico.mp hk ] ] at *;
          convert valuation_Tp_shifted_term_p p hp hp5 x hx hx0 using 1;
    simp_all +decide [ Finset.sum_Ico_eq_sub _ ];
    simp_all +decide [ Polynomial.coeff_zero_eq_eval_zero, add_comm ];
    convert valuation_Tp_shifted_linear p hp x hx0 using 1;
    · ac_rfl;
    · ring

/-
For p >= 5 and |a| > 1, if p divides n and p divides T_{n/p}(a)-1, then the p-adic valuation of T_n(a)-1 is exactly 2 greater than that of T_{n/p}(a)-1.
-/
theorem lemma_valuation_increase_ge_5 (p : ℕ) (hp : p.Prime) (hp5 : p ≥ 5) (n : ℕ) (a : ℤ) (hn : n > 0) (ha : |a| > 1) (h_dvd_n : p ∣ n) (h_dvd_val : (p : ℤ) ∣ (Chebyshev.T ℤ (n/p)).eval a - 1) :
  multiplicity (p : ℤ) ((Chebyshev.T ℤ n).eval a - 1) = multiplicity (p : ℤ) ((Chebyshev.T ℤ (n/p)).eval a - 1) + 2 := by
    have := @valuation_Tp_eval_increase p hp hp5;
    convert this ( ( Chebyshev.T ℤ ( n / p ) |> Polynomial.eval a ) - 1 ) h_dvd_val _ using 1;
    · rw [ show ( n : ℤ ) = p * ( n / p ) by rw [ mul_comm, Int.ediv_mul_cancel ( mod_cast h_dvd_n ) ] ] ; norm_num [ Chebyshev.T_mul ] ; ring;
      rw [ Int.mul_ediv_cancel_left _ ( Nat.cast_ne_zero.mpr hp.ne_zero ) ];
    · -- Since $|a| > 1$, we have $|T_{n/p}(a)| > 1$, thus $T_{n/p}(a) - 1 \neq 0$.
      have h_abs_Tn_div_p : |(Chebyshev.T ℤ (n / p)).eval a| > 1 := by
        -- By definition of Chebyshev polynomials, we know that $|T_n(x)| > 1$ for $|x| > 1$ and $n \geq 1$.
        have h_Tn_abs : ∀ n : ℕ, 1 ≤ n → ∀ x : ℤ, |x| > 1 → |(Chebyshev.T ℤ n).eval x| > 1 := by
          intro n hn x hx; induction hn <;> aesop;
          erw [ Chebyshev.T_add_one ] ; norm_num [ abs_mul, abs_sub_comm ] at *;
          -- By induction, we know that $|T_m(x)| > |T_{m-1}(x)|$ for $|x| > 1$.
          have h_ind : ∀ m : ℕ, 1 ≤ m → ∀ x : ℤ, |x| > 1 → |(Chebyshev.T ℤ m).eval x| > |(Chebyshev.T ℤ (m - 1)).eval x| := by
            intro m hm x hx; induction hm <;> aesop;
            erw [ Chebyshev.T_add_one ];
            norm_num [ two_mul, abs_mul ];
            cases abs_cases ( eval x ( Chebyshev.T ℤ m_2 ) ) <;> cases abs_cases ( ( x + x ) * eval x ( Chebyshev.T ℤ m_2 ) - eval x ( Chebyshev.T ℤ ( m_2 - 1 ) ) ) <;> cases abs_cases x <;> nlinarith [ abs_lt.mp a_ih_1 ];
          specialize h_ind m a_1 x hx ; norm_num [ abs_mul, abs_sub_comm ] at *;
          contrapose! h_ind;
          rw [ abs_le ] at h_ind;
          cases abs_cases ( eval x ( Chebyshev.T ℤ m ) ) <;> cases abs_cases ( eval x ( Chebyshev.T ℤ ( m - 1 ) ) ) <;> cases abs_cases x <;> push_cast [ * ] at * <;> nlinarith;
        convert h_Tn_abs ( n / p ) ( Nat.div_pos ( Nat.le_of_dvd hn h_dvd_n ) hp.pos ) a ha;
      cases abs_cases ( ( Chebyshev.T ℤ ( n / p ) |> Polynomial.eval a ) ) <;> linarith

#check is_exception_final

/-
For p >= 5 dividing n, if d divides n but not n/p, then sigma(d) = 2.
-/
def S_divisors (n p : ℕ) : Finset ℕ := (n.divisors).filter (λ d => ¬ d ∣ n/p)

theorem sigma_eq_two_on_S (n : ℕ) (p : ℕ) (hp : p.Prime) (hp5 : p ≥ 5) (h_intrinsic : p ∣ n) :
  ∀ d ∈ S_divisors n p, sigma d = 2 := by
    -- By definition of S_divisors, if d ∈ S_divisors n p, then d divides n but not n/p.
    intro d hd
    obtain ⟨hd_div_n, hd_not_div_np⟩ : d ∣ n ∧ ¬d ∣ n / p := by
      unfold S_divisors at hd; aesop;
    unfold sigma; aesop;
    exact hd_not_div_np ( Nat.Coprime.mul_dvd_of_dvd_of_dvd ( by { exact hp.coprime_iff_not_dvd.mpr fun h => by have := Nat.le_of_dvd ( by linarith ) h; interval_cases p } ) h_intrinsic hd_div_n )

/-
If p >= 5 divides n and p divides T_n(a)-1, then p divides T_{n/p}(a)-1.
-/
theorem p_dvd_Tn_div_p_ge_5 (n : ℕ) (a : ℤ) (p : ℕ) (hp : p.Prime) (hp5 : p ≥ 5) (h_dvd_n : p ∣ n) (h_dvd_Tn : (p : ℤ) ∣ (Chebyshev.T ℤ n).eval a - 1) :
  (p : ℤ) ∣ (Chebyshev.T ℤ (n/p)).eval a - 1 := by
    -- By `ChebOrd`, `p | T_n(a) - 1` implies `Che(p, a) | n`.
    have h_che_div_n : (Che p a : ℤ) ∣ n := by
      have := ChebOrd p hp a;
      specialize this n ; aesop;
      cases n <;> aesop;
      exact_mod_cast this;
    -- Since `p >= 5`, `Che(p, a)` is coprime to `p` (since `p >= 5`).
    have h_che_coprime_p : Int.gcd (Che p a : ℤ) p = 1 := by
      have := prop_Che p hp a; aesop;
    -- Since `Che(p, a)` is coprime to `p` and divides `n`, it must divide `n/p`.
    have h_che_div_np : (Che p a : ℤ) ∣ n / p := by
      cases h_dvd_n ; aesop;
      exact mul_dvd_mul_left _ ( Int.dvd_of_dvd_mul_right_of_gcd_one h_che_div_n h_che_coprime_p );
    have := ChebOrd p hp a;
    rcases eq_or_ne n 0 <;> aesop;
    exact this ( n / p ) ( Nat.div_pos ( Nat.le_of_dvd ( Nat.pos_of_ne_zero h ) h_dvd_n ) hp.pos ) |>.2 ( mod_cast h_che_div_np )

/-
For p dividing n, T_n(a)-1 factors into (T_{n/p}(a)-1) times the product of Omega_d(a)^sigma(d) for d in S_divisors(n,p).
-/
theorem Tn_sub_one_eq_Tn_div_p_sub_one_mul_prod (n : ℕ) (a : ℤ) (p : ℕ) (hp : p.Prime) (h_dvd_n : p ∣ n) (hn : n > 0) :
  (Chebyshev.T ℤ n).eval a - 1 = ((Chebyshev.T ℤ (n/p)).eval a - 1) * ∏ d ∈ S_divisors n p, (OmegaZ d).eval a ^ (sigma d) := by
    have := Tn_sub_one_eq_prod_OmegaZ_eval n hn a; aesop;
    rw [ show ( Nat.divisors n ) = Nat.divisors ( n / p ) ∪ S_divisors n p from ?_, Finset.prod_union ] <;> norm_num [ Finset.disjoint_left ];
    · have := Tn_sub_one_eq_prod_OmegaZ_eval ( n / p ) ( Nat.div_pos ( Nat.le_of_dvd hn h_dvd_n ) hp.pos ) a; aesop;
    · unfold S_divisors; aesop;
    · ext d; aesop;
      · by_cases h : p * d ∣ n <;> aesop;
        · exact Or.inl ⟨ hp.ne_zero, Nat.le_of_dvd hn ( dvd_of_mul_right_dvd h ) ⟩;
        · exact Finset.mem_filter.mpr ⟨ Nat.mem_divisors.mpr ⟨ left, right ⟩, fun h' => h <| Nat.mul_dvd_of_dvd_div h_dvd_n h' ⟩;
      · exact dvd_of_mul_left_dvd left;
      · exact Nat.dvd_of_mem_divisors ( Finset.mem_filter.mp h_1 |>.1 )

/-
The p-adic valuation of the product of Omega_d(a)^sigma(d) over S_divisors(n,p) is 2.
-/
theorem valuation_prod_S_eq_two (n : ℕ) (a : ℤ) (p : ℕ) (hp : p.Prime) (hp5 : p ≥ 5) (h_dvd_n : p ∣ n) (h_dvd_Tn : (p : ℤ) ∣ (Chebyshev.T ℤ n).eval a - 1) (hn : n > 0) (ha : |a| > 1) :
  multiplicity (p : ℤ) (∏ d ∈ S_divisors n p, (OmegaZ d).eval a ^ (sigma d)) = 2 := by
    -- By lemma_valuation_increase_ge_5, we have v_p(T_n - 1) = v_p(T_{n/p} - 1) + 2.
    have h_val_add : multiplicity (p : ℤ) ((Chebyshev.T ℤ n).eval a - 1) = multiplicity (p : ℤ) ((Chebyshev.T ℤ (n/p)).eval a - 1) + 2 := by
      apply_rules [ lemma_valuation_increase_ge_5 ];
      exact?;
    -- By Tn_sub_one_eq_Tn_div_p_sub_one_mul_prod, we have T_n - 1 = (T_{n/p} - 1) * Prod.
    have h_prod : (Chebyshev.T ℤ n).eval a - 1 = ((Chebyshev.T ℤ (n/p)).eval a - 1) * ∏ d ∈ S_divisors n p, (OmegaZ d).eval a ^ (sigma d) := by
      convert Tn_sub_one_eq_Tn_div_p_sub_one_mul_prod n a p hp h_dvd_n hn using 1;
    have h_val_prod : multiplicity (p : ℤ) ((Chebyshev.T ℤ n).eval a - 1) = multiplicity (p : ℤ) ((Chebyshev.T ℤ (n/p)).eval a - 1) + multiplicity (p : ℤ) (∏ d ∈ S_divisors n p, (OmegaZ d).eval a ^ (sigma d)) := by
      rw [ h_prod, multiplicity_mul ];
      · exact Nat.prime_iff_prime_int.mp hp;
      · contrapose! h_val_add; aesop;
    linarith!

/-
If n > 0, p > 1, and p divides n, then n is in S_divisors(n, p).
-/
theorem n_mem_S_divisors (n p : ℕ) (hn : n > 0) (hp : p > 1) (h_dvd : p ∣ n) : n ∈ S_divisors n p := by
  unfold S_divisors; aesop;
  nlinarith [ Nat.le_of_dvd hn a ]

/-
If p >= 5 divides n, then the p-adic valuation of Omega_n(a) is at most 1.
-/
theorem Satz_1_part3_ge_5 (n : ℕ) (a : ℤ) (hn : n > 1) (ha : |a| > 1) (p : ℕ) (hp : p.Prime) (hp5 : p ≥ 5) (h_intrinsic : p ∣ n) :
  multiplicity (p : ℤ) ((OmegaZ n).eval a) ≤ 1 := by
  by_cases h_dvd : (p : ℤ) ∣ (OmegaZ n).eval a
  · have h_dvd_Tn : (p : ℤ) ∣ (Chebyshev.T ℤ n).eval a - 1 := dvd_trans h_dvd (OmegaZ_dvd_Tn_sub_one n (by linarith) a)
    have h_val_prod := valuation_prod_S_eq_two n a p hp hp5 h_intrinsic h_dvd_Tn (by linarith) ha
    have h_sigma : ∀ d ∈ S_divisors n p, sigma d = 2 := sigma_eq_two_on_S n p hp hp5 h_intrinsic
    have h_n_mem : n ∈ S_divisors n p := n_mem_S_divisors n p (by linarith) (by linarith [hp.one_lt]) h_intrinsic
    rw [Finset.prod_congr rfl (fun d hd => by rw [h_sigma d hd])] at h_val_prod
    have h_sum_val : multiplicity (p : ℤ) (∏ d ∈ S_divisors n p, (OmegaZ d).eval a) = ∑ d ∈ S_divisors n p, multiplicity (p : ℤ) ((OmegaZ d).eval a) := by
      have h_sum_val : ∀ {s : Finset ℕ} {f : ℕ → ℤ}, (∀ d ∈ s, f d ≠ 0) → multiplicity (p : ℤ) (∏ d ∈ s, f d) = ∑ d ∈ s, multiplicity (p : ℤ) (f d) := by
        intros s f hf_nonzero; induction s using Finset.induction <;> aesop;
        · norm_num [ multiplicity ];
          rw [ emultiplicity_eq_zero.mpr ] <;> norm_num [ hp.ne_one, hp.ne_zero ];
          exact_mod_cast hp.not_dvd_one;
        · rw [ multiplicity_mul ] ; aesop;
          · exact Nat.prime_iff_prime_int.mp hp;
          · haveI := Fact.mk hp; simp_all ( config := { decide := Bool.true } ) [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, multiplicity ] ;
            rw [ Int.finiteMultiplicity_iff ];
            exact ⟨ by norm_cast; linarith [ hp.two_le ], mul_ne_zero left <| Finset.prod_ne_zero_iff.mpr fun x hx => right x hx ⟩;
      apply h_sum_val;
      intro d hd; contrapose! h_val_prod; simp_all ( config := { decide := Bool.true } ) [ Finset.prod_eq_zero hd ] ;
    have h_sum_val : multiplicity (p : ℤ) (∏ d ∈ S_divisors n p, (OmegaZ d).eval a ^ 2) = 2 * multiplicity (p : ℤ) (∏ d ∈ S_divisors n p, (OmegaZ d).eval a) := by
      have h_sum_val_eq_two : ∀ {x : ℤ}, x ≠ 0 → multiplicity (p : ℤ) (x ^ 2) = 2 * multiplicity (p : ℤ) x := by
        exact?;
      by_cases h : ∏ d ∈ S_divisors n p, eval a (OmegaZ d) = 0 <;> simp_all ( config := { decide := Bool.true } ) [ Finset.prod_pow ];
    linarith [ Finset.single_le_sum ( fun x _ => zero_le ( multiplicity ( p : ℤ ) ( eval a ( OmegaZ x ) ) ) ) h_n_mem ]
  · rw [multiplicity_eq_zero.mpr h_dvd]
    exact zero_le_one

/-
If m and a are odd, then the 2-adic valuation of T_m(a)-1 is equal to the 2-adic valuation of a-1.
-/
theorem lemma_valuation_Tm_sub_one_odd_m (m : ℕ) (a : ℤ) (hm : Odd m) (ha : Odd a) :
  multiplicity (2 : ℤ) ((Chebyshev.T ℤ m).eval a - 1) = multiplicity (2 : ℤ) (a - 1) := by
    have h_factor : ∃ Q : Polynomial ℤ, (Chebyshev.T ℤ m) - 1 = (Polynomial.X - 1) * Q ∧ Odd (Q.eval 1) := by
      have h_factor : ∃ Q : Polynomial ℤ, (Chebyshev.T ℤ m) - 1 = (Polynomial.X - 1) * Q := by
        exact Polynomial.dvd_iff_isRoot.mpr ( by aesop );
      cases' h_factor with Q hQ; use Q; aesop;
      replace hQ := congr_arg ( Polynomial.derivative ) hQ ; norm_num at hQ;
      replace hQ := congr_arg ( Polynomial.eval 1 ) hQ ; aesop;
      exact hQ ▸ by erw [ lemma_T_derivative_eval_one ] ; simp ( config := { decide := Bool.true } ) [ hm, parity_simps ] ;
    obtain ⟨ Q, hQ₁, hQ₂ ⟩ := h_factor; replace hQ₁ := congr_arg ( Polynomial.eval a ) hQ₁; aesop;
    -- Since $Q(a)$ is odd, $Q(a)$ is not divisible by $2$.
    have hQ_a_not_div_two : ¬(2 : ℤ) ∣ eval a Q := by
      have := Polynomial.sub_dvd_eval_sub a 1 Q; obtain ⟨ k, hk ⟩ := this; replace hk := congr_arg Even hk; simp_all ( config := { decide := Bool.true } ) [ ← even_iff_two_dvd, parity_simps ] ;
    by_cases h₂ : a - 1 = 0 <;> simp_all ( config := { decide := Bool.true } ) [ multiplicity ];
    rw [ emultiplicity_mul ];
    · simp_all ( config := { decide := Bool.true } ) [ emultiplicity_eq_zero.mpr ( show ¬ ( 2 : ℤ ) ∣ eval a Q from by rw [ Int.dvd_iff_emod_eq_zero ] ; aesop ) ];
    · norm_num

/-
For odd m, the 2-adic valuation of T_m(a)-1 equals the 2-adic valuation of a-1.
-/
theorem lemma_valuation_Tm_sub_one_odd_m_general (m : ℕ) (a : ℤ) (hm : Odd m) :
  multiplicity (2 : ℤ) ((Chebyshev.T ℤ m).eval a - 1) = multiplicity (2 : ℤ) (a - 1) := by
    obtain ⟨ k, rfl ⟩ : ∃ k, m = 2 * k + 1 := hm;
    -- Since $T_{2k+1}(x)$ is an odd function, we have $T_{2k+1}(a) \equiv a \pmod{2}$.
    have h_odd : (Chebyshev.T ℤ (2 * k + 1)).eval a % 2 = a % 2 := by
      induction k <;> simp_all +decide [ Nat.mul_succ, add_assoc ];
      erw [ Chebyshev.T ] ; aesop;
      norm_num [ Int.sub_emod, Int.mul_emod, a_1 ];
    -- Since $a \equiv 1 \pmod{2}$, we have $a - 1$ is even, and thus $v_2(a - 1) = v_2(a - 1)$.
    by_cases ha : a % 2 = 1;
    · convert lemma_valuation_Tm_sub_one_odd_m ( 2 * k + 1 ) a ( by simp +decide ) ( by rw [ Int.odd_iff ] ; exact ha ) using 1;
    · simp +zetaDelta at *;
      cases ha ; aesop;
      rw [ multiplicity_eq_zero.mpr, multiplicity_eq_zero.mpr ] <;> norm_num [ ← even_iff_two_dvd, parity_simps ];
      exact even_iff_two_dvd.mpr h_odd

/-
For odd m, T_m(a)-1 is the product of (a-1) and the squares of Omega_d(a) for divisors d > 1.
-/
theorem lemma_Tn_sub_one_prod_odd_m (m : ℕ) (hm : Odd m) (a : ℤ) :
  (Chebyshev.T ℤ m).eval a - 1 = (a - 1) * ∏ d ∈ (Nat.divisors m).filter (λ d => d > 1), ((OmegaZ d).eval a) ^ 2 := by
    -- Applying the general product formula `Tn_sub_one_eq_prod_OmegaZ_eval` to $m$.
    have h_Tm : (Chebyshev.T ℤ m).eval a - 1 = ∏ d ∈ m.divisors, (OmegaZ d).eval a ^ (sigma d) := by
      convert Tn_sub_one_eq_prod_OmegaZ_eval m ( Nat.pos_of_ne_zero <| by aesop ) a using 1;
    rw [ h_Tm, Finset.prod_eq_mul_prod_diff_singleton <| Nat.one_mem_divisors.mpr hm.pos.ne' ];
    unfold sigma; aesop;
    rw [ show OmegaZ 1 = Polynomial.X - 1 from ?_ ];
    · rw [ show m.divisors \ { 1 } = m.divisors.filter ( fun x => 1 < x ) from ?_, Finset.prod_congr rfl ] ; aesop;
      · aesop;
        grind;
      · ext ( _ | _ | x ) <;> aesop;
    · unfold OmegaZ; aesop;
      unfold Omega; norm_num [ Polynomial.coeff_one, Polynomial.coeff_X, Polynomial.coeff_C ] ;
      erw [ Finset.sum_subset ( show ( Polynomial.support ( Polynomial.X - 1 : Polynomial ℝ ) ) ⊆ { 0, 1 } from fun x hx => by erw [ Polynomial.mem_support_iff ] at hx; erw [ Polynomial.coeff_sub, Polynomial.coeff_X, Polynomial.coeff_one ] at hx; aesop ) ] <;> norm_num ; ring;
      · congr ; norm_cast ; have := Classical.choose_spec ( Omega_integral 1 0 ) ; aesop;
      · norm_num [ Polynomial.coeff_one ]

/-
For odd m, the polynomial T_m - 1 factors as (X-1) times the product of OmegaZ_d^2 for d > 1.
-/
theorem lemma_Tn_sub_one_prod_odd_m_poly (m : ℕ) (hm : Odd m) :
  Chebyshev.T ℤ m - 1 = (Polynomial.X - 1) * ∏ d ∈ (Nat.divisors m).filter (λ d => d > 1), (OmegaZ d) ^ 2 := by
    have := @lemma_Tn_sub_one_prod_odd_m m hm;
    refine' Polynomial.funext fun x => _;
    simpa [ Polynomial.eval_prod ] using this x

/-
The second Chebyshev polynomial is $2x^2 - 1$.
-/
lemma T2_eq : Chebyshev.T ℤ 2 = 2 * Polynomial.X^2 - 1 := by
  exact?

/-
The third Chebyshev polynomial is $4x^3 - 3x$.
-/
lemma T3_eq : Chebyshev.T ℤ 3 = 4 * Polynomial.X^3 - 3 * Polynomial.X := by
  -- Using the recurrence relation for Chebyshev polynomials, we have $T_3(x) = 2xT_2(x) - T_1(x)$.
  have h_recurrence : Chebyshev.T ℤ 3 = 2 * Polynomial.X * Chebyshev.T ℤ 2 - Chebyshev.T ℤ 1 := by
    -- Apply the recurrence relation for Chebyshev polynomials: $T_{n+2}(x) = 2xT_{n+1}(x) - T_n(x)$.
    have h_recurrence : ∀ n : ℕ, Chebyshev.T ℤ (n + 2) = 2 * Polynomial.X * Chebyshev.T ℤ (n + 1) - Chebyshev.T ℤ n := by
      exact?;
    exact h_recurrence 1;
  exact h_recurrence.trans ( by erw [ Chebyshev.T_one, Chebyshev.T_two ] ; ring )

/-
If $n$ is even and $n \ge 4$, then $\Omega_{2n}(x) = \Omega_n(T_2(x))$.
-/
lemma OmegaZ_recurrence_even (n : ℕ) (hn : Even n) (hn4 : n ≥ 4) : OmegaZ (2 * n) = (OmegaZ n).comp (Chebyshev.T ℤ 2) := by
  have := Omega_eq_map_OmegaZ ( 2 * n ) ; have := @Omega_eq_map_OmegaZ n; aesop;
  have h_eq : Omega (2 * n) = (Omega n).comp (Chebyshev.T ℝ 2) := by
    apply_rules [ omegas_prop_b_eq ];
    · decide +revert;
    · linarith;
    · grind;
    · intro p pp dp; have := Nat.le_of_dvd ( by decide ) dp; interval_cases p <;> simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ;
  simp_all +decide [ Polynomial.map_comp ];
  exact Polynomial.map_injective ( Int.castRingHom ℝ ) Int.cast_injective <| by simpa [ Polynomial.map_comp ] using this_1.symm;

/-
If $n$ is divisible by 3 and positive, then $\Omega_{3n}(x) = \Omega_n(T_3(x))$.
-/
lemma OmegaZ_recurrence_div3 (n : ℕ) (hn : 3 ∣ n) (hn0 : n > 0) : OmegaZ (3 * n) = (OmegaZ n).comp (Chebyshev.T ℤ 3) := by
  -- Apply the lemma omegas_prop_b_eq with m=3 and n=n, using the fact that 3 divides n.
  have h_apply_lemma : Omega (3 * n) = (Omega n).comp (Chebyshev.T ℝ 3) := by
    -- Apply the lemma `omegas_prop_b_eq` with `m = 3` and `n = n`.
    apply omegas_prop_b_eq 3 n (by decide) hn0;
    · exact Nat.le_of_dvd hn0 hn;
    · exact fun p pp dp => dvd_trans dp hn;
  -- By definition of `OmegaZ`, we have `OmegaZ (3 * n) = (Omega (3 * n)).map (algebraMap ℤ ℝ)` and `OmegaZ n = (Omega n).map (algebraMap ℤ ℝ)`.
  have h_map : (OmegaZ (3 * n)).map (algebraMap ℤ ℝ) = (Omega (3 * n)) ∧ (OmegaZ n).map (algebraMap ℤ ℝ) = (Omega n) := by
    exact ⟨ by rw [ ← Omega_eq_map_OmegaZ ], by rw [ ← Omega_eq_map_OmegaZ ] ⟩;
  refine' Polynomial.map_injective ( algebraMap ℤ ℝ ) Int.cast_injective _;
  simp_all +decide [ Polynomial.map_comp ]

/-
$\OmegaZ_8 = 4X^2-2$.
-/
lemma OmegaZ_eight : OmegaZ 8 = 4 * Polynomial.X^2 - 2 := by
  -- Calculate $\C_8(x)=\Omega_4(T_2(x))$.
  have hC8 : OmegaZ 8 = (OmegaZ 4).comp (Chebyshev.T ℤ 2) := by
    convert OmegaZ_recurrence_even 4 ( by decide ) ( by decide ) using 1;
  -- Substitute the known values of OmegaZ 4 and Chebyshev.T 2.
  rw [hC8, OmegaZ_four, T2_eq];
  simpa using by ring;

/-
For $k \ge 3$, $\Omega_{2^k}(a) \equiv 2 \pmod 4$.
-/
lemma OmegaZ_pow2_mod_4 (k : ℕ) (hk : k ≥ 3) (a : ℤ) : (OmegaZ (2^k)).eval a ≡ 2 [ZMOD 4] := by
  -- Prove by induction that for k ≥ 3, Omega_{2^k}(x) = Omega_8(T_{2^(k-3)}(x)).
  have h_recurrence : ∀ k ≥ 3, OmegaZ (2 ^ k) = (OmegaZ 8).comp (Chebyshev.T ℤ (2 ^ (k - 3))) := by
    -- We proceed by induction on $k$.
    intro k hk
    induction' hk with k ih;
    · norm_num [ Chebyshev.T ];
    · -- Applying the recurrence relation for OmegaZ, we have OmegaZ (2^(k+1)) = OmegaZ (2^k).comp (Chebyshev.T ℤ 2).
      have h_recurrence_step : OmegaZ (2 ^ (k + 1)) = (OmegaZ (2 ^ k)).comp (Chebyshev.T ℤ 2) := by
        convert OmegaZ_recurrence_even ( 2 ^ k ) _ _ using 1 <;> norm_num [ pow_succ' ];
        · exact even_iff_two_dvd.mpr ( dvd_pow_self _ ( by linarith [ Nat.succ_le_iff.mp ih ] ) );
        · exact le_trans ( by decide ) ( pow_le_pow_right₀ ( by decide ) ih );
      rcases k with ( _ | _ | _ | k ) <;> simp_all +decide [ pow_succ, mul_assoc ];
      norm_num [ Polynomial.comp_assoc, Chebyshev.T_mul ];
  -- Substitute the recurrence relation into the goal.
  rw [h_recurrence k hk];
  norm_num [ Int.ModEq, Int.mul_emod, Int.sub_emod, OmegaZ_eight ]

/-
Explicit formulas for $\Omega_9, \Omega_{18}, \Omega_{12}$.
-/
lemma OmegaZ_nine : OmegaZ 9 = 8 * Polynomial.X^3 - 6 * Polynomial.X + 1 := by
  have h_omega9 : OmegaZ 9 = (OmegaZ 3).comp (Chebyshev.T ℤ 3) := by
    convert OmegaZ_recurrence_div3 3 ( by decide ) ( by decide ) using 1;
  rw [ h_omega9 ] ; erw [ OmegaZ_three ] ; erw [ T3_eq ] ; norm_num ; ring;
lemma OmegaZ_eighteen : OmegaZ 18 = 8 * Polynomial.X^3 - 6 * Polynomial.X - 1 := by
  have h_omega_18 : OmegaZ 18 = (OmegaZ 6).comp (Chebyshev.T ℤ 3) := by
    rw [ show ( 18 : ℕ ) = 3 * 6 by norm_num, OmegaZ_recurrence_div3 ] <;> norm_num;
  rw [ h_omega_18, OmegaZ_six ];
  erw [ show Chebyshev.T ℤ 3 = 4 * Polynomial.X ^ 3 - 3 * Polynomial.X from T3_eq ] ; norm_num ; ring
lemma OmegaZ_twelve : OmegaZ 12 = 4 * Polynomial.X^2 - 3 := by
  apply Eq.symm; exact (OmegaZ_recurrence_even 6 (by decide) (by decide)) ▸ by
    rw [ show OmegaZ 6 = ( 2 * Polynomial.X - 1 ) from by
          exact? ] ; norm_num [ T2_eq ] ; ring;

/-
If $n$ is divisible by 3, then $\Omega_{n \cdot 3^k} = \Omega_n \circ T_{3^k}$.
-/
lemma OmegaZ_comp_pow3 (n : ℕ) (k : ℕ) (hn : 3 ∣ n) (hn0 : n > 0) : OmegaZ (n * 3^k) = (OmegaZ n).comp (Chebyshev.T ℤ (3^k)) := by
  -- We prove $\Omega_{n \cdot 3^k} = \Omega_n \circ T_{3^k}$ by induction on $k$.
  induction' k with k ih generalizing n;
  · norm_num [ Chebyshev.T ];
  · convert OmegaZ_recurrence_div3 ( n * 3 ^ k ) ( dvd_mul_of_dvd_left hn _ ) ( by positivity ) using 1;
    · ring;
    · rw [ ih n hn hn0 ] ; norm_num [ pow_succ, Chebyshev.T_mul ] ; ring;
      rw [ Polynomial.comp_assoc ]

/-
If $k \ge 2$ and $3 \mid \Omega_{3^k}(a)$, then $\Omega_{3^k}(a) \equiv 3 \pmod 9$.
-/
lemma OmegaZ_mod_9_pow3 (k : ℕ) (hk : k ≥ 2) (a : ℤ) (h_dvd : 3 ∣ (OmegaZ (3^k)).eval a) : (OmegaZ (3^k)).eval a ≡ 3 [ZMOD 9] := by
  -- We have $\Omega_{3^k}(a) = \Omega_9(T_{3^{k-2}}(a))$.
  have h_eq : (OmegaZ (3 ^ k)).eval a = (OmegaZ 9).eval ((Chebyshev.T ℤ (3 ^ (k - 2))).eval a) := by
    convert congr_arg ( Polynomial.eval a ) ( OmegaZ_comp_pow3 9 ( k - 2 ) ( by norm_num ) ( by norm_num ) ) using 1;
    · rw [ show 9 * 3 ^ ( k - 2 ) = 3 ^ k by rw [ show 3 ^ k = 3 ^ 2 * 3 ^ ( k - 2 ) by rw [ ← pow_add, Nat.add_sub_of_le hk ] ] ; ring ];
    · norm_num [ Polynomial.eval_comp ];
  -- Let $y = T_{3^{k-2}}(a)$. Then $\Omega_{3^k}(a) = 8y^3 - 6y + 1$.
  set y : ℤ := (Chebyshev.T ℤ (3 ^ (k - 2))).eval a
  have h_omega9 : (OmegaZ 9).eval y = 8 * y^3 - 6 * y + 1 := by
    have h_omega9 : OmegaZ 9 = 8 * Polynomial.X^3 - 6 * Polynomial.X + 1 := by
      exact?;
    aesop;
  -- If $3 \mid 8y^3 - 6y + 1$, then $y \equiv 1 \pmod 3$.
  have h_y_mod3 : y % 3 = 1 ∨ y % 3 = 2 := by
    have := Int.emod_nonneg y three_pos.ne'; ( have := Int.emod_lt_of_pos y three_pos; interval_cases _ : y % 3 <;> simp_all +decide [ ← Int.emod_def ] ; );
    rw [ Int.dvd_iff_emod_eq_zero ] at *; norm_num [ Int.add_emod, Int.sub_emod, Int.mul_emod, pow_three, ‹_› ] at h_dvd;
  rcases h_y_mod3 with ( h | h ) <;> rw [ h_eq, h_omega9 ] <;> rw [ ← Int.emod_add_mul_ediv y 3, h ] <;> ring_nf <;> norm_num [ Int.ModEq, Int.add_emod, Int.sub_emod, Int.mul_emod ];
  exact absurd ( h_dvd ) ( by erw [ h_eq, h_omega9 ] ; rw [ Int.dvd_iff_emod_eq_zero ] ; norm_num [ Int.add_emod, Int.sub_emod, Int.mul_emod, pow_three, h ] )

/-
If $k \ge 2$ and $3 \mid \Omega_{2 \cdot 3^k}(a)$, then $\Omega_{2 \cdot 3^k}(a) \equiv 6 \pmod 9$.
-/
lemma OmegaZ_mod_9_2_mul_pow3 (k : ℕ) (hk : k ≥ 2) (a : ℤ) (h_dvd : 3 ∣ (OmegaZ (2 * 3^k)).eval a) : (OmegaZ (2 * 3^k)).eval a ≡ 6 [ZMOD 9] := by
  -- Let $y = T_{3^{k-2}}(a)$. Then $\Omega_{2 \cdot 3^k}(a) = 8y^3 - 6y - 1$.
  set y := (Chebyshev.T ℤ (3 ^ (k - 2))).eval a
  have h_eval : (OmegaZ (2 * 3 ^ k)).eval a = 8 * y ^ 3 - 6 * y - 1 := by
    have h_eval : (OmegaZ (2 * 3 ^ k)) = (OmegaZ 18).comp (Chebyshev.T ℤ (3 ^ (k - 2))) := by
      convert OmegaZ_comp_pow3 18 ( k - 2 ) ( by norm_num ) ( by norm_num ) using 1;
      rcases k with ( _ | _ | k ) <;> simp_all +decide [ pow_succ, mul_assoc ];
      ring;
    rw [ h_eval, Polynomial.eval_comp, OmegaZ_eighteen ] ; norm_num ; ring;
  -- If $3 \mid 8y^3 - 6y - 1$, then $y \equiv -1 \pmod 3$.
  have hy_mod : y ≡ -1 [ZMOD 3] := by
    rw [ Int.dvd_iff_emod_eq_zero ] at *; rw [ h_eval ] at h_dvd; norm_num [ Int.ModEq, Int.add_emod, Int.sub_emod, Int.mul_emod, pow_three ] at * ; have := Int.emod_nonneg y three_pos.ne'; have := Int.emod_lt_of_pos y three_pos; interval_cases y % 3 <;> trivial;
  rw [ Int.ModEq ] at *; rw [ Int.dvd_iff_emod_eq_zero ] at *; norm_num [ Int.add_emod, Int.sub_emod, Int.mul_emod, pow_three ] at *; aesop;
  rw [ ← Int.emod_add_mul_ediv ( eval a ( Chebyshev.T ℤ ( 3 ^ ( k - 2 ) ) ) ) 3, hy_mod ] ; ring_nf; norm_num [ Int.add_emod, Int.sub_emod, Int.mul_emod ] ;

/-
If $3 \mid \Omega_{12 \cdot 3^k}(a)$, then $\Omega_{12 \cdot 3^k}(a) \equiv 6 \pmod 9$.
-/
lemma OmegaZ_mod_9_12_mul_pow3 (k : ℕ) (a : ℤ) (h_dvd : 3 ∣ (OmegaZ (12 * 3^k)).eval a) : (OmegaZ (12 * 3^k)).eval a ≡ 6 [ZMOD 9] := by
  -- By definition of $\Omega_{12 \cdot 3^k}$, we have $\Omega_{12 \cdot 3^k}(a) = \Omega_{12}(T_{3^k}(a))$.
  have h_comp : (OmegaZ (12 * 3^k)).eval a = (OmegaZ 12).eval ((Chebyshev.T ℤ (3^k)).eval a) := by
    have h_comp : OmegaZ (12 * 3^k) = (OmegaZ 12).comp (Chebyshev.T ℤ (3^k)) := by
      convert OmegaZ_comp_pow3 12 k _ _ using 1 <;> norm_num;
    aesop;
  -- By Lemma~\ref{lem:poly_def:OmegaZ_twelve}, $\Omega_{12}(x) = 4x^2 - 3$.
  have h_Omega12 : OmegaZ 12 = 4 * Polynomial.X^2 - 3 := by
    exact?;
  aesop;
  -- Since $3 \mid 4y^2$, we have $3 \mid y$.
  have h_div_y : 3 ∣ (Chebyshev.T ℤ (3^k)).eval a := by
    exact Int.Prime.dvd_pow' ( by norm_num ) ( show 3 ∣ ( eval a ( Chebyshev.T ℤ ( 3 ^ k ) ) ) ^ 2 by exact Int.dvd_of_emod_eq_zero <| by omega );
  rcases h_div_y with ⟨ m, hm ⟩ ; rw [ hm ] ; ring_nf; norm_num [ Int.ModEq, Int.add_emod, Int.sub_emod, Int.mul_emod ] ;

/-
For odd $n$, $T_n(a) = 1$ if and only if $a = 1$.
-/
lemma lemma_Tn_eq_one_iff_odd (n : ℕ) (hn : Odd n) (a : ℤ) : (Chebyshev.T ℤ n).eval a = 1 ↔ a = 1 := by
  have hTn_one_iff : ∀ {a : ℤ}, a > 1 → (Chebyshev.T ℤ n).eval a > 1 := by
    intro a ha
    have h_Tn_gt_one : ∀ x : ℝ, 1 < x → 1 < (Chebyshev.T ℝ n).eval x := by
      intros x hx; exact (by
      -- Since $x > 1$, we can write $x = \cosh(y)$ for some $y > 0$.
      obtain ⟨y, hy⟩ : ∃ y : ℝ, 0 < y ∧ x = Real.cosh y := by
        use Real.arsinh ( Real.sqrt ( x^2 - 1 ) ) ; aesop;
        · linarith [ le_abs_self x ];
        · rw [ Real.sq_sqrt ( by nlinarith ), add_sub_cancel, Real.sqrt_sq ( by linarith ) ];
      -- Using the definition of Chebyshev polynomials, we have $T_n(\cosh(y)) = \cosh(ny)$.
      have h_Tn_cosh : (Chebyshev.T ℝ n).eval (Real.cosh y) = Real.cosh (n * y) := by
        have h_Tn_cosh : ∀ n : ℕ, ∀ y : ℝ, (Chebyshev.T ℝ n).eval (Real.cosh y) = Real.cosh (n * y) := by
          intro n y; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Chebyshev.T, mul_assoc, Real.cosh_add ] ;
        exact h_Tn_cosh n y;
      aesop);
    specialize h_Tn_gt_one a ( mod_cast ha );
    -- By definition of $T$, we know that $T_n(a)$ is an integer.
    have h_Tn_int : ∀ n : ℕ, ∀ a : ℤ, (Chebyshev.T ℤ n).eval a = (Chebyshev.T ℝ n).eval (a : ℝ) := by
      intro n a; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all +decide [ Chebyshev.T ] ;
      erw [ Chebyshev.T ] ; aesop;
      erw [ Chebyshev.T ] ; aesop;
      have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; aesop;
    exact_mod_cast h_Tn_int n a |>.symm ▸ h_Tn_gt_one;
  have hTn_one_iff_neg : ∀ {a : ℤ}, a < -1 → (Chebyshev.T ℤ n).eval a < -1 := by
    intro a ha; specialize @hTn_one_iff ( -a ) ( by linarith ) ; aesop;
    have hTn_neg : ∀ x : ℤ, (Chebyshev.T ℤ n).eval (-x) = - (Chebyshev.T ℤ n).eval x := by
      intro x; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all ( config := { decide := Bool.true } ) [ Chebyshev.T ] ; ring;
      have hTn_neg : ∀ n : ℕ, (Chebyshev.T ℤ n).eval (-x) = (-1)^n * (Chebyshev.T ℤ n).eval x := by
        intro n; induction' n using Nat.strong_induction_on with n ih; rcases n with ( _ | _ | n ) <;> simp_all ( config := { decide := Bool.true } ) [ Chebyshev.T ] ; ring;
        have := ih n ( by linarith ) ; have := ih ( n + 1 ) ( by linarith ) ; simp_all ( config := { decide := Bool.true } ) [ add_comm, add_left_comm, pow_succ, Chebyshev.T ] ; ring;
      convert hTn_neg ( 2 + n ) using 1 ; ring;
      simp_all ( config := { decide := Bool.true } ) [ parity_simps ];
    linarith [ hTn_neg a ];
  cases lt_trichotomy a 1 <;> aesop;
  · by_cases ha : a < -1;
    · linarith [ hTn_one_iff_neg ha ];
    · interval_cases a <;> norm_num at *;
      · cases hn ; aesop;
      · rcases hn with ⟨ k, rfl ⟩ ; norm_num [ Chebyshev.T ] at a_1 ⊢;
        have h_eval_zero : ∀ k : ℕ, eval 0 (Chebyshev.T ℤ (2 * k + 1)) = 0 := by
          intro k; induction k <;> simp_all ( config := { decide := Bool.true } ) [ Nat.mul_succ, Chebyshev.T_add_two ] ;
          erw [ Chebyshev.T ] ; aesop;
        linarith [ h_eval_zero k ];
  · linarith [ hTn_one_iff h_2 ]

/-
For odd $n$ and $a \ne 1$, the 2-adic valuation of $\prod_{d|n, d>1} \Omega_d(a)^2$ is 0.
-/
lemma lemma_valuation_prod_OmegaZ_sq_eq_zero (n : ℕ) (hn : Odd n) (a : ℤ) (ha : a ≠ 1) :
  multiplicity (2 : ℤ) (∏ d ∈ (Nat.divisors n).filter (λ d => d > 1), ((OmegaZ d).eval a) ^ 2) = 0 := by
    -- By definition of $P$, we know that $T_n(a) - 1 = (a - 1)P$.
    have hP : (Chebyshev.T ℤ n).eval a - 1 = (a - 1) * ∏ d ∈ (Nat.divisors n).filter (fun d => d > 1), ((OmegaZ d).eval a) ^ 2 := by
      exact?;
    have hP_val : multiplicity (2 : ℤ) ((Chebyshev.T ℤ n).eval a - 1) = multiplicity (2 : ℤ) (a - 1) := by
      exact?;
    have hP_val : multiplicity (2 : ℤ) ((a - 1) * ∏ d ∈ (Nat.divisors n).filter (fun d => d > 1), ((OmegaZ d).eval a) ^ 2) = multiplicity (2 : ℤ) (a - 1) + multiplicity (2 : ℤ) (∏ d ∈ (Nat.divisors n).filter (fun d => d > 1), ((OmegaZ d).eval a) ^ 2) := by
      apply multiplicity_mul;
      · norm_num [ Int.prime_iff_natAbs_prime ];
      · have h_nonzero : (a - 1) * ∏ d ∈ (Nat.divisors n).filter (fun d => d > 1), ((OmegaZ d).eval a) ^ 2 ≠ 0 := by
          have := lemma_Tn_eq_one_iff_odd n hn a; simp_all +decide [ sub_eq_iff_eq_add ] ;
        exact?;
    aesop

/-
For odd $n > 1$, $\Omega_n(a) \ne 0$ for any integer $a$.
-/
lemma lemma_OmegaZ_ne_zero_of_odd (n : ℕ) (hn : Odd n) (hn1 : n > 1) (a : ℤ) : (OmegaZ n).eval a ≠ 0 := by
  bound;
  -- Since $\Omega_n(a) = 0$, we have $T_n(a) = 1$.
  have h_Tn_a : (Chebyshev.T ℤ n).eval a = 1 := by
    -- Since $\Omega_n(a) = 0$, we have $T_n(a) - 1 = 0$, thus $T_n(a) = 1$. Use this fact to conclude the proof.
    have h_Tn_a : ∏ d ∈ n.divisors, (OmegaZ d).eval a ^ (sigma d) = (Chebyshev.T ℤ n).eval a - 1 := by
      convert Tn_sub_one_eq_prod_OmegaZ_eval n ( by linarith ) a |> Eq.symm using 1;
    rw [ Finset.prod_eq_zero ( Nat.mem_divisors_self _ <| by linarith ) ] at h_Tn_a <;> aesop;
    · linarith;
    · exact absurd a_2 ( by unfold sigma; aesop );
  convert absurd ( lemma_Tn_eq_one_iff_odd n hn a ) ?_ using 1 ; aesop;
  -- Since $eval 1 (OmegaZ n) = 0$, we have $Omega_n(1) = 0$.
  have h_Omega_n_one : (Omega n).eval 1 = 0 := by
    convert a_1 using 1;
    rw [ Omega_eq_map_OmegaZ ];
    norm_num [ Polynomial.eval_map ];
  -- Since $Omega n$ is a product of terms of the form $X - C (2 * Real.cos (2 * k * Real.pi / n))$, and $1$ is not equal to any of these cosines, $Omega n$ cannot be zero at $X=1$.
  have h_Omega_n_one_ne_zero : ∀ k : ℕ, k ∈ Finset.filter (fun k => Nat.Coprime n k) (Finset.Icc 1 (n / 2)) → 1 ≠ 2 * Real.cos (2 * k * Real.pi / n) := by
    intro k hk
    by_contra h_contra
    have h_cos : Real.cos (2 * k * Real.pi / n) = 1 / 2 := by
      linarith;
    -- Since $\cos(2k\pi/n) = 1/2$, we have $2k\pi/n = \pm \pi/3 + 2m\pi$ for some integer $m$.
    obtain ⟨m, hm⟩ : ∃ m : ℤ, 2 * k * Real.pi / n = Real.pi / 3 + 2 * m * Real.pi ∨ 2 * k * Real.pi / n = -Real.pi / 3 + 2 * m * Real.pi := by
      rw [ ← Real.cos_pi_div_three, Real.cos_eq_cos_iff ] at h_cos;
      rcases h_cos with ⟨ m, hm | hm ⟩ <;> [ exact ⟨ -m, Or.inl <| by push_cast; linarith ⟩ ; exact ⟨ m, Or.inr <| by linarith ⟩ ];
    -- Dividing both sides by $\pi$, we get $6k = n + 6mn$ or $6k = -n + 6mn$.
    have h_div : 6 * k = n + 6 * m * n ∨ 6 * k = -n + 6 * m * n := by
      exact Or.imp ( fun h => by rw [ div_eq_iff ( by positivity ) ] at h; push_cast [ ← @Int.cast_inj ℝ ] ; nlinarith [ Real.pi_pos ] ) ( fun h => by rw [ div_eq_iff ( by positivity ) ] at h; push_cast [ ← @Int.cast_inj ℝ ] ; nlinarith [ Real.pi_pos ] ) hm;
    grind;
  unfold Omega at h_Omega_n_one; simp_all +decide [ Finset.prod_eq_zero_iff, sub_eq_iff_eq_add ] ;
  contrapose! h_Omega_n_one;
  split_ifs <;> simp_all +decide [ Polynomial.eval_prod, Finset.prod_eq_zero_iff, sub_eq_iff_eq_add ];
  intro k hk hk' hk''; specialize h_Omega_n_one_ne_zero k hk hk' hk''; contrapose! h_Omega_n_one_ne_zero; aesop;
  rw [ eq_comm, Real.cos_eq_one_iff ] at h_Omega_n_one_ne_zero ; aesop;
  -- Simplify the equation $w * (2 * π) = 2 * k * π / n$ to get $w * n = k$.
  have h_simplified : w * n = k := by
    exact_mod_cast ( by rw [ eq_div_iff ( by positivity ) ] at h_1; nlinarith [ Real.pi_pos ] : ( w : ℝ ) * n = k );
  exact absurd ( hk''.gcd_eq_one ▸ Nat.dvd_gcd ( dvd_refl n ) ( show n ∣ k from Int.natCast_dvd_natCast.mp ( h_simplified ▸ dvd_mul_left _ _ ) ) ) ( by aesop )

/-
For odd $n$ and $a \ne 1$, the product $\prod_{d|n, d>1} \Omega_d(a)^2$ is odd.
-/
lemma lemma_prod_Omega_sq_odd (n : ℕ) (hn : Odd n) (a : ℤ) (ha : a ≠ 1) :
  Odd (∏ d ∈ (Nat.divisors n).filter (λ d => d > 1), ((OmegaZ d).eval a) ^ 2) := by
    have := @lemma_valuation_prod_OmegaZ_sq_eq_zero n hn a ha; ( unfold multiplicity at this; aesop; );
    erw [ WithTop.untopD_eq_iff ] at this ; aesop;
    rw [ emultiplicity_eq_zero ] at this ; aesop;
    exact Int.odd_iff.mpr this

/-
If $\Omega_n(a) = 0$ for an integer $a$, then $n \in \{1, 2, 3, 4, 6\}$.
-/
lemma lemma_root_OmegaZ_int_implies_small_n (n : ℕ) (hn : n > 0) (a : ℤ) (h_root : (OmegaZ n).eval a = 0) :
  n = 1 ∨ n = 2 ∨ n = 3 ∨ n = 4 ∨ n = 6 := by
    by_contra h_contra;
    -- If $\Omega_n(a) = 0$ for an integer $a$, then $a = 2\cos(2k\pi/n)$ for some $k$ coprime to $n$.
    obtain ⟨k, hk⟩ : ∃ k : ℕ, k ∈ (Finset.filter (fun k => Nat.Coprime n k) (Finset.Ico 1 n)) ∧ a = 2 * Real.cos (2 * k * Real.pi / n) := by
      have h_root_def : (Omega n).eval (a : ℝ) = 0 := by
        have h_eq : (Omega n).eval (a : ℝ) = (OmegaZ n).eval a := by
          rw [ Omega_eq_map_OmegaZ ] ; norm_num [ Polynomial.eval_map ];
        aesop;
      unfold Omega at h_root_def;
      split_ifs at h_root_def <;> simp_all +decide [ Polynomial.eval_prod, Finset.prod_eq_zero_iff, sub_eq_iff_eq_add ];
      obtain ⟨ k, ⟨ ⟨ hk₁, hk₂ ⟩, hk₃ ⟩, hk₄ ⟩ := h_root_def; use k; aesop;
      · omega;
      · have : a ≤ 1 := Int.le_of_lt_add_one ( by rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ Real.cos_sq' ( 2 * k * Real.pi / n ) ] ) ; ( have : a ≥ -1 := Int.le_of_lt_add_one ( by rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ Real.cos_sq' ( 2 * k * Real.pi / n ) ] ) ; interval_cases a <;> norm_num at *; );
        · -- Since $\cos(2k\pi/n) = -1$, we have $2k\pi/n = (2m+1)\pi$ for some integer $m$.
          obtain ⟨ m, hm ⟩ : ∃ m : ℤ, 2 * k * Real.pi / n = (2 * m + 1) * Real.pi := by
            rw [ eq_comm, Real.cos_eq_neg_one_iff ] at hk₄ ; obtain ⟨ m, hm ⟩ := hk₄ ; exact ⟨ m, by linarith ⟩;
          -- Dividing both sides by $\pi$, we get $2k/n = 2m + 1$, which simplifies to $2k = n(2m + 1)$.
          have h_div : 2 * k = n * (2 * m + 1) := by
            exact_mod_cast ( by rw [ div_eq_iff ( by positivity ) ] at hm; nlinarith [ Real.pi_pos ] : ( 2 : ℝ ) * k = n * ( 2 * m + 1 ) );
          -- Since $n$ divides $2k$ and $n$ is coprime to $k$, it must divide $2$.
          have h_div_two : n ∣ 2 := by
            exact hk₃.dvd_of_dvd_mul_right <| by exact_mod_cast h_div.symm ▸ dvd_mul_right _ _;
          have := Nat.le_of_dvd ( by decide ) h_div_two; interval_cases n <;> trivial;
        · grind +ring;
        · rw [ eq_comm, Real.cos_eq_one_iff ] at hk₄ ; aesop;
          -- Simplify the equation $w * (2 * π) = 2 * k * π / n$ to get $w * n = k$.
          have h_simplified : w * n = k := by
            exact_mod_cast ( by rw [ eq_div_iff ( by positivity ) ] at h_1; nlinarith [ Real.pi_pos ] : ( w : ℝ ) * n = k );
          exact absurd ( hk₃.gcd_eq_one ▸ Nat.dvd_gcd ( dvd_refl _ ) ( show n ∣ k from Int.natCast_dvd_natCast.mp ( h_simplified ▸ dvd_mul_left _ _ ) ) ) ( by aesop );
    -- Since $a \in \mathbb{Z}$, $a \in \{-2, -1, 0, 1, 2\}$.
    have h_a_values : a = -2 ∨ a = -1 ∨ a = 0 ∨ a = 1 ∨ a = 2 := by
      have : a ≤ 2 := Int.le_of_lt_add_one ( by rw [ ← @Int.cast_lt ℝ ] ; norm_num; nlinarith [ Real.cos_sq' ( 2 * k * Real.pi / n ) ] ) ; ( have : a ≥ -2 := Int.le_of_lt_add_one ( by rw [ ← @Int.cast_lt ℝ ] ; norm_num; nlinarith [ Real.cos_sq' ( 2 * k * Real.pi / n ) ] ) ; interval_cases a <;> norm_num at *; );
    rcases h_a_values with ( rfl | rfl | rfl | rfl | rfl ) <;> norm_num at hk;
    · -- Since $\cos(2k\pi/n) = -1$, we have $2k\pi/n = (2m+1)\pi$ for some integer $m$, implying $n$ divides $2k$.
      have h_div : n ∣ 2 * k := by
        -- Since $\cos(2k\pi/n) = -1$, we have $2k\pi/n = (2m+1)\pi$ for some integer $m$, implying $n$ divides $2k$ by simplifying the equation.
        obtain ⟨m, hm⟩ : ∃ m : ℤ, 2 * k * Real.pi / n = (2 * m + 1) * Real.pi := by
          obtain ⟨ m, hm ⟩ := Real.cos_eq_cos_iff.mp ( show Real.cos ( 2 * k * Real.pi / n ) = Real.cos ( Real.pi ) by norm_num; linarith );
          rcases hm with ( hm | hm ) <;> [ exact ⟨ -m, by push_cast; linarith ⟩ ; exact ⟨ m - 1, by push_cast; linarith ⟩ ];
        exact Int.natCast_dvd_natCast.mp ⟨ 2 * m + 1, by rw [ ← @Int.cast_inj ℝ ] ; push_cast; nlinarith [ Real.pi_pos, mul_div_cancel₀ ( 2 * ( k : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ⟩;
      -- Since $n$ divides $2k$ and $\gcd(n, k) = 1$, it follows that $n$ divides $2$.
      have h_div_2 : n ∣ 2 := by
        exact hk.1.2.dvd_of_dvd_mul_right h_div;
      have := Nat.le_of_dvd ( by decide ) h_div_2; interval_cases n <;> trivial;
    · -- Since $\cos(2k\pi/n) = -1/2$, we have $2k\pi/n = 2\pi/3 + 2m\pi$ or $2k\pi/n = 4\pi/3 + 2m\pi$ for some integer $m$.
      have h_cos_eq : ∃ m : ℤ, 2 * k * Real.pi / n = 2 * Real.pi / 3 + 2 * m * Real.pi ∨ 2 * k * Real.pi / n = 4 * Real.pi / 3 + 2 * m * Real.pi := by
        obtain ⟨ m, hm ⟩ := Real.cos_eq_cos_iff.mp ( show Real.cos ( 2 * k * Real.pi / n ) = Real.cos ( Real.pi - Real.pi / 3 ) by norm_num; linarith );
        rcases hm with ( hm | hm ) <;> [ exact ⟨ -m, Or.inl <| by push_cast; linarith ⟩ ; exact ⟨ m - 1, Or.inr <| by push_cast; linarith ⟩ ];
      -- Simplify $2k\pi/n = 2\pi/3 + 2m\pi$ or $2k\pi/n = 4\pi/3 + 2m\pi$ to get $3k = n + 3mn$ or $3k = 2n + 3mn$.
      obtain ⟨m, hm⟩ := h_cos_eq;
      have h_simplified : 3 * k = n + 3 * m * n ∨ 3 * k = 2 * n + 3 * m * n := by
        exact Or.imp ( fun h => by rw [ div_eq_iff ( by positivity ) ] at h; push_cast [ ← @Int.cast_inj ℝ ] ; nlinarith [ Real.pi_pos ] ) ( fun h => by rw [ div_eq_iff ( by positivity ) ] at h; push_cast [ ← @Int.cast_inj ℝ ] ; nlinarith [ Real.pi_pos ] ) hm;
      -- Since $n$ is coprime to $k$, $n$ must divide $3$.
      have h_div : n ∣ 3 := by
        have h_div : n ∣ 3 * k := by
          exact Int.natCast_dvd_natCast.mp ( h_simplified.elim ( fun h => ⟨ 1 + 3 * m, by push_cast; linarith ⟩ ) fun h => ⟨ 2 + 3 * m, by push_cast; linarith ⟩ );
        exact hk.1.2.dvd_of_dvd_mul_right h_div;
      have := Nat.le_of_dvd ( by decide ) h_div; interval_cases n <;> trivial;
    · -- If $\cos(2k\pi/n) = 0$, then $2k\pi/n = \pi/2 + m\pi$ for some integer $m$, implying $4k = n(2m + 1)$.
      obtain ⟨m, hm⟩ : ∃ m : ℤ, 4 * k = n * (2 * m + 1) := by
        rw [ Real.cos_eq_zero_iff ] at hk;
        obtain ⟨ m, hm ⟩ := hk.2; exact ⟨ m, by rw [ ← @Int.cast_inj ℝ ] ; push_cast; nlinarith [ Real.pi_pos, mul_div_cancel₀ ( 2 * ( k : ℝ ) * Real.pi ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ⟩ ;
      -- Since $n$ is coprime to $k$, $n$ must divide $4$.
      have h_div : n ∣ 4 := by
        exact Int.natCast_dvd_natCast.mp ( Int.dvd_of_dvd_mul_left_of_gcd_one ( hm.symm ▸ dvd_mul_right _ _ ) ( by simpa [ Int.gcd_natCast_natCast ] using hk.1.2 ) );
      have := Nat.le_of_dvd ( by decide ) h_div; interval_cases n <;> simp_all +decide ;
    · -- If $1 = 2 \cos(2k\pi/n)$, then $\cos(2k\pi/n) = 1/2$, which implies $2k\pi/n = \pm \pi/3 + 2m\pi$ for some integer $m$.
      have h_cos_eq : ∃ m : ℤ, 2 * k * Real.pi / n = Real.pi / 3 + 2 * m * Real.pi ∨ 2 * k * Real.pi / n = -Real.pi / 3 + 2 * m * Real.pi := by
        obtain ⟨ m, hm ⟩ := Real.cos_eq_cos_iff.mp ( show Real.cos ( 2 * k * Real.pi / n ) = Real.cos ( Real.pi / 3 ) by norm_num; linarith );
        rcases hm with ( hm | hm ) <;> [ exact ⟨ -m, Or.inl <| by push_cast; linarith ⟩ ; exact ⟨ m, Or.inr <| by linarith ⟩ ];
      rcases h_cos_eq with ⟨ m, hm | hm ⟩ <;> rw [ div_eq_iff ( by positivity ) ] at hm;
      · -- Dividing both sides by $\pi$, we get $6k = n + 6mn$, which simplifies to $n(6m + 1) = 6k$.
        have h_div : n * (6 * m + 1) = 6 * k := by
          exact_mod_cast ( by nlinarith [ Real.pi_pos ] : ( n : ℝ ) * ( 6 * m + 1 ) = 6 * k );
        -- Since $n$ and $k$ are coprime, $n$ must divide $6$.
        have h_div_6 : n ∣ 6 := by
          exact hk.1.2.dvd_of_dvd_mul_right <| by exact_mod_cast h_div ▸ dvd_mul_right _ _;
        have := Nat.le_of_dvd ( by decide ) h_div_6; interval_cases n <;> norm_num at *;
      · -- Simplify $2k\pi = (-\pi/3 + 2m\pi)n$ to get $6k = -n + 6mn$, which implies $n$ divides $6k$.
        have h_div : n ∣ 6 * k := by
          exact Int.natCast_dvd_natCast.mp ⟨ -1 + m * 6, by push_cast [ ← @Int.cast_inj ℝ ] ; nlinarith [ Real.pi_pos ] ⟩;
        -- Since $n$ divides $6k$ and $n$ is coprime to $k$, it must divide $6$.
        have h_div_6 : n ∣ 6 := by
          exact hk.1.2.dvd_of_dvd_mul_right h_div;
        have := Nat.le_of_dvd ( by decide ) h_div_6; interval_cases n <;> norm_num at *;
    · -- If $\cos(2k\pi/n) = 1$, then $2k\pi/n = 2m\pi$ for some integer $m$, implying $k = mn$.
      obtain ⟨m, hm⟩ : ∃ m : ℤ, k = m * n := by
        rw [ Real.cos_eq_one_iff ] at hk ; aesop;
        exact ⟨ w, by rw [ ← @Int.cast_inj ℝ ] ; push_cast; rw [ eq_div_iff ( by positivity ) ] at h; nlinarith [ Real.pi_pos ] ⟩;
      nlinarith [ show m = 0 by nlinarith ]

/-
If a product of squares is odd, then each term is odd.
-/
lemma lemma_odd_of_odd_prod_sq {S : Finset ℕ} {f : ℕ → ℤ} (h : Odd (∏ k ∈ S, (f k)^2)) (k : ℕ) (hk : k ∈ S) : Odd (f k) := by
  simp_all +decide [ Finset.prod_eq_mul_prod_diff_singleton hk, parity_simps ];
  grind

/-
For odd $d > 1$, $\Omega_d(1)$ is odd.
-/
lemma OmegaZ_odd_at_one (d : ℕ) (hd : Odd d) (hd1 : d > 1) : Odd ((OmegaZ d).eval 1) := by
  -- Using the relation $T_d(x) - 1 = (x-1) \prod_{k|d, k>1} \Omega_k(x)^2$, we differentiate both sides at $x=1$.
  have h_diff : (Polynomial.derivative (Chebyshev.T ℤ d)).eval 1 = (∏ k ∈ (Nat.divisors d).filter (λ d => d > 1), ((OmegaZ k).eval 1) ^ 2) := by
    have h_diff : (Chebyshev.T ℤ d) - 1 = (Polynomial.X - 1) * ∏ k ∈ (Nat.divisors d).filter (λ d => d > 1), (OmegaZ k) ^ 2 := by
      -- Apply the lemma_Tn_sub_one_prod_odd_m_poly theorem with n = d.
      apply lemma_Tn_sub_one_prod_odd_m_poly d hd;
    replace h_diff := congr_arg ( Polynomial.derivative ) h_diff ; aesop;
    simp ( config := { decide := Bool.true } ) [ Polynomial.eval_prod ];
  -- Since $d$ is odd, $d^2$ is odd, implying the product is odd.
  have h_odd_prod : Odd (∏ k ∈ (Nat.divisors d).filter (λ d => d > 1), ((OmegaZ k).eval 1) ^ 2) := by
    have h_odd_prod : (Polynomial.derivative (Chebyshev.T ℤ d)).eval 1 = d^2 := by
      convert lemma_T_derivative_eval_one d;
    exact h_diff.symm ▸ h_odd_prod.symm ▸ mod_cast hd.pow;
  have h_odd_each : ∀ k ∈ (Nat.divisors d).filter (λ d => d > 1), Odd ((OmegaZ k).eval 1) := by
    intro k hk_mem; contrapose! h_odd_prod; simp_all ( config := { decide := Bool.true } ) [ Finset.prod_eq_mul_prod_diff_singleton hk_mem, parity_simps ] ;
  aesop

/-
For odd $d > 1$, $\Omega_d(y)$ is odd.
-/
lemma lemma_Omega_odd_of_odd_d (d : ℕ) (hd : Odd d) (hd1 : d > 1) (y : ℤ) : Odd ((OmegaZ d).eval y) := by
  by_cases hy : y = 1;
  · exact hy.symm ▸ OmegaZ_odd_at_one d hd hd1;
  · have := @lemma_odd_of_odd_prod_sq ( Nat.divisors d |> Finset.filter fun k => k > 1 ) ( fun k => ( OmegaZ k |> Polynomial.eval y ) ) ?_ d ; simp_all +decide;
    · exact this hd1.ne_bot;
    · have := @lemma_prod_Omega_sq_odd d hd y hy; aesop;

/-
For odd $d > 1$, $\Omega_d(y)$ is odd.
-/
lemma lemma_Omega_odd_of_odd_d_v2 (d : ℕ) (hd : Odd d) (hd1 : d > 1) (y : ℤ) : Odd ((OmegaZ d).eval y) := by
  exact?

/-
If $n > 1$, then $n$ is in the set of divisors of $n$ greater than 1.
-/
lemma lemma_self_mem_divisors_filter (n : ℕ) (hn : n > 1) : n ∈ (Nat.divisors n).filter (λ d => d > 1) := by
  aesop

/-
If $3 \mid n$ and $9 \mid \Omega_n(a)$, then $n=3$ or $n=6$.
-/
lemma Satz_1_part3_p_eq_3_corrected (n : ℕ) (a : ℤ) (hn : n > 1) (ha : |a| > 1) (h_dvd_n : 3 ∣ n) (h_dvd : (3 : ℤ)^2 ∣ (OmegaZ n).eval a) : n = 3 ∨ n = 6 := by
  by_contra h_contra;
  -- Apply Satz_1_part1 to obtain that n = Che(3, a) * 3^i.
  obtain ⟨i, hi⟩ : ∃ i : ℕ, n = Che 3 a * 3 ^ i := by
    apply Satz_1_part1;
    · bound;
    · assumption;
    · norm_num;
    · exact dvd_trans ( by norm_num ) h_dvd;
  -- Since $p=3$ is a primitive divisor related prime, $n = \Che(a) \cdot 3^i$.
  have h_Che : Che 3 a ∈ [1, 2, 4] := by
    unfold Che; aesop;
    refine' Classical.or_iff_not_imp_left.2 fun h => Classical.or_iff_not_imp_left.2 fun h' => le_antisymm _ _;
    · refine' Nat.sInf_le _;
      unfold Che at *; aesop;
      erw [ show ( Chebyshev.T ℤ 4 : Polynomial ℤ ) = 8 * Polynomial.X ^ 4 - 8 * Polynomial.X ^ 2 + 1 from by
              erw [ Chebyshev.T ];
              erw [ Chebyshev.T ] ; norm_num ; ring;
              erw [ Chebyshev.T ] ; norm_num ; ring ] ; norm_num ; ring_nf;
      rw [ Int.dvd_iff_emod_eq_zero ] ; norm_num [ Int.add_emod, Int.sub_emod, Int.mul_emod, pow_succ ];
      rw [ neg_eq_neg_one_mul, Int.mul_emod ] ; norm_num [ show a ^ 4 = a ^ 2 * a ^ 2 by ring, Int.mul_emod, sq ] ; have := Int.emod_nonneg a three_pos.ne'; have := Int.emod_lt_of_pos a three_pos; interval_cases a % 3 <;> trivial;
    · refine' le_csInf _ _ <;> norm_num;
      · use Che 3 a * 3 ^ i;
        aesop;
        · exact Nat.pos_of_ne_zero ( by aesop_cat );
        · have := Tn_sub_one_eq_prod_OmegaZ_eval ( Che 3 a * 3 ^ i ) ( by linarith ) a;
          simp_all +decide [ Finset.prod_eq_mul_prod_diff_singleton ( Nat.mem_divisors_self _ ( by linarith : ( Che 3 a * 3 ^ i ) ≠ 0 ) ) ];
          exact dvd_mul_of_dvd_left ( dvd_pow ( dvd_trans ( by norm_num ) h_dvd ) ( by unfold sigma; aesop ) ) _;
      · intro b hb hb'; contrapose! h'; interval_cases b <;> simp_all +decide ;
        · rw [ @IsLeast.csInf_eq ];
          refine' ⟨ _, fun m hm => _ ⟩ <;> aesop;
          · erw [ show Chebyshev.T ℤ 2 = 2 * Polynomial.X ^ 2 - 1 from T2_eq ] ; norm_num ; obtain ⟨ k, hk ⟩ := hb' ; exact ⟨ 2 * k * ( a + 1 ), by linear_combination' hk * 2 * ( a + 1 ) ⟩ ;
          · rcases m with ( _ | _ | m ) <;> simp_all +decide;
            exact h ( le_antisymm ( csInf_le ⟨ 0, fun m hm => by linarith [ hm.1 ] ⟩ ⟨ by norm_num, by simpa using hb' ⟩ ) ( le_csInf ⟨ 1, by norm_num, by simpa using hb' ⟩ fun m hm => by linarith [ hm.1 ] ) );
        · refine' le_antisymm _ _;
          · exact Nat.sInf_le ⟨ by norm_num, hb' ⟩;
          · refine' le_csInf _ _ <;> norm_num;
            · exact ⟨ 2, by norm_num, hb' ⟩;
            · intro b hb hb'; contrapose! h; interval_cases b ; simp_all +decide ;
              exact le_antisymm ( csInf_le ⟨ 0, fun m hm => hm.1.le ⟩ ⟨ by norm_num, by simpa using hb' ⟩ ) ( le_csInf ⟨ 1, by norm_num, by simpa using hb' ⟩ fun m hm => hm.1 );
        · refine' le_antisymm _ _;
          · refine' Nat.sInf_le ⟨ by norm_num, _ ⟩;
            erw [ show ( Chebyshev.T ℤ 2 : Polynomial ℤ ) = 2 * Polynomial.X ^ 2 - 1 from T2_eq ] ; norm_num;
            erw [ show ( Chebyshev.T ℤ 3 : Polynomial ℤ ) = 4 * Polynomial.X ^ 3 - 3 * Polynomial.X from T3_eq ] at hb' ; norm_num at hb' ; rw [ Int.dvd_iff_emod_eq_zero ] at * ; norm_num [ Int.add_emod, Int.sub_emod, Int.mul_emod, pow_three, pow_two ] at * ; have := Int.emod_nonneg a three_ne_zero ; have := Int.emod_lt_of_pos a three_pos ; interval_cases a % 3 <;> trivial;
          · refine' le_csInf _ _;
            · exact ⟨ 3, by norm_num, hb' ⟩;
            · intro m hm; contrapose! h; interval_cases m <;> simp_all +decide ;
              exact le_antisymm ( csInf_le ⟨ 0, fun m hm => by linarith [ hm.1 ] ⟩ ⟨ by norm_num, by simpa using hm ⟩ ) ( le_csInf ⟨ 1, by norm_num, by simpa using hm ⟩ fun m hm => by linarith [ hm.1 ] );
  rcases i with ( _ | _ | i ) <;> simp_all +decide [ Nat.pow_succ', mul_assoc ];
  · omega;
  · rcases h_Che with ( h | h ) <;> simp_all +decide;
    -- If $n = 12$, then $\Omega_{12}(a) \equiv 6 \pmod{9}$, which contradicts $9 \mid \Omega_{12}(a)$.
    have h_contra : (OmegaZ 12).eval a ≡ 6 [ZMOD 9] := by
      apply OmegaZ_mod_9_12_mul_pow3 0 a;
      exact dvd_trans ( by norm_num ) h_dvd;
    exact absurd ( Int.emod_eq_zero_of_dvd h_dvd ) ( by rw [ h_contra ] ; decide );
  · rcases h_Che with ( h | h | h ) <;> simp_all +decide [ Nat.primeFactors_mul ];
    · -- For $k \ge 2$, $\Omega_{3^k}(a) \equiv 3 \pmod 9$.
      have h_mod_9 : (OmegaZ (3 ^ (i + 2))).eval a ≡ 3 [ZMOD 9] := by
        apply OmegaZ_mod_9_pow3;
        · linarith;
        · ring_nf at * ; aesop;
          exact dvd_trans ( by norm_num ) h_dvd;
      rw [ Int.dvd_iff_emod_eq_zero ] at h_dvd; ring_nf at *; simp_all +decide [ Int.ModEq ] ;
    · -- Apply the lemma that states if $3 \mid \Omega_{2 \cdot 3^k}(a)$, then $\Omega_{2 \cdot 3^k}(a) \equiv 6 \pmod{9}$.
      have h_mod : (OmegaZ (2 * (3 * (3 * 3 ^ i)))).eval a ≡ 6 [ZMOD 9] := by
        convert OmegaZ_mod_9_2_mul_pow3 ( i + 2 ) ( by linarith ) a _ using 1;
        · ring;
        · grind;
      rw [ Int.dvd_iff_emod_eq_zero ] at h_dvd; simp_all +decide only [Int.ModEq] ;
    · -- Since $4 \cdot 3^{i+2} = 12 \cdot 3^{i+1}$, we can apply the lemma for $12 \cdot 3^k$.
      have h_lemma : (OmegaZ (12 * 3 ^ (i + 1))).eval a ≡ 6 [ZMOD 9] := by
        apply OmegaZ_mod_9_12_mul_pow3;
        grind;
      rw [ Int.dvd_iff_emod_eq_zero ] at *; ring_nf at *; simp_all +decide [ Int.ModEq ] ;

/-
If $n \ge 3$ is odd, then $\Omega_{2n}(a)$ is odd.
-/
lemma lemma_OmegaZ_odd_2 (n : ℕ) (hn : Odd n) (hn3 : n ≥ 3) (a : ℤ) : Odd ((OmegaZ (2 * n)).eval a) := by
  have := omega_odd_2 n hn ( by linarith ) ; aesop;
  · -- By definition of $OmegaZ$, we know that $OmegaZ (2 * n) = (OmegaZ n).comp (-Polynomial.X)$.
    have h_comp : OmegaZ (2 * n) = (OmegaZ n).comp (-Polynomial.X) := by
      apply Polynomial.map_injective ( algebraMap ℤ ℝ ) ( Int.cast_injective );
      simp_all +decide [ Omega_eq_map_OmegaZ ];
      norm_num [ Polynomial.map_comp ];
    have := lemma_Omega_odd_of_odd_d_v2 n hn ( by linarith ) ( -a ) ; aesop;
  · -- By definition of OmegaZ, we know that OmegaZ (2 * n) = -(OmegaZ n).comp (-X).
    have h_eq : OmegaZ (2 * n) = -(OmegaZ n).comp (-Polynomial.X) := by
      have h_eq : Omega (2 * n) = -(Omega n).comp (-Polynomial.X) := by
        exact h_1;
      have := Omega_eq_map_OmegaZ ( 2 * n ) ; have := Omega_eq_map_OmegaZ n; aesop;
      exact Polynomial.map_injective ( Int.castRingHom ℝ ) Int.cast_injective <| by simpa [ Polynomial.map_comp ] using h_eq;
    -- Since $n$ is odd and $n > 1$, $\OmegaZ_n(y)$ is odd for any integer $y$ (by `lemma_Omega_odd_of_odd_d_v2`).
    have h_odd : Odd ((OmegaZ n).eval (-a)) := by
      exact lemma_Omega_odd_of_odd_d_v2 n hn ( by linarith ) _;
    simp_all +decide [ Polynomial.eval_comp ]

/-
If $m$ is odd and $m > 1$, then $\Omega_{m \cdot 2^k}(a)$ is odd for any $k$.
-/
lemma lemma_OmegaZ_odd_of_odd_d_mul_pow2 (m k : ℕ) (hm : Odd m) (hm1 : m > 1) (a : ℤ) : Odd ((OmegaZ (m * 2^k)).eval a) := by
  -- Induction on $k$.
  induction' k with k ih generalizing a;
  · have := lemma_Omega_odd_of_odd_d_v2 m hm hm1 a; aesop;
  · by_cases hk : k = 0;
    · rcases hm with ⟨ c, rfl ⟩ ; simp_all ( config := { decide := Bool.true } ) [ parity_simps ] ;
      convert lemma_OmegaZ_odd_2 ( 2 * c + 1 ) ( by simp ( config := { decide := Bool.true } ) [ parity_simps ] ) ( by linarith ) a using 1;
      ac_rfl;
    · -- Since $m * 2^{k+1} = 2 * (m * 2^k)$ and $m$ is odd, we can apply the lemma OmegaZ_recurrence_even.
      have h_even : m * 2 ^ (k + 1) = 2 * (m * 2 ^ k) := by
        ring;
      rw [ h_even, OmegaZ_recurrence_even ] <;> aesop;
      · exact even_iff_two_dvd.mpr ( dvd_mul_of_dvd_right ( dvd_pow_self _ hk ) _ );
      · nlinarith [ Nat.pow_le_pow_right two_pos ( Nat.pos_of_ne_zero hk ) ]

/-
If $4 \mid \Omega_n(a)$, then $n$ is a power of 2.
-/
lemma lemma_n_pow2_of_four_dvd_OmegaZ (n : ℕ) (a : ℤ) (hn : n > 0) (h_dvd : 4 ∣ (OmegaZ n).eval a) : ∃ k, n = 2^k := by
  -- Let $n = 2^k \cdot m$ with $m$ odd.
  obtain ⟨k, m, rfl, hm⟩ : ∃ k m, n = 2 ^ k * m ∧ Odd m := by
    exact ⟨ Nat.factorization n 2, n / 2 ^ Nat.factorization n 2, by rw [ Nat.mul_div_cancel' ( Nat.ordProj_dvd _ _ ) ], by rw [ Nat.odd_iff ] ; exact Nat.mod_two_ne_zero.mp fun h => absurd ( Nat.dvd_of_mod_eq_zero h ) ( Nat.not_dvd_ordCompl ( by norm_num ) <| by aesop ) ⟩;
  -- If $m > 1$, then by `lemma_OmegaZ_odd_of_odd_d_mul_pow2`, $\Omega_{m \cdot 2^k}(a)$ is odd.
  by_cases hm_gt_one : m > 1;
  · have h_odd : Odd ((OmegaZ (2 ^ k * m)).eval a) := by
      convert lemma_OmegaZ_odd_of_odd_d_mul_pow2 m k hm hm_gt_one a using 1;
      rw [ mul_comm ];
    exact absurd ( even_iff_two_dvd.mpr ( dvd_trans ( by decide ) h_dvd ) ) ( by simpa using h_odd );
  · interval_cases m <;> aesop

/-
If $2 \mid n$ and $4 \mid \Omega_n(a)$, then $n=2$ or $n=4$.
-/
lemma Satz_1_part3_p_eq_2_corrected (n : ℕ) (a : ℤ) (hn : n > 1) (ha : |a| > 1) (h_dvd_n : 2 ∣ n) (h_dvd : (2 : ℤ)^2 ∣ (OmegaZ n).eval a) : n = 2 ∨ n = 4 := by
  by_cases h_pow2 : ∃ k, n = 2^k;
  · rcases h_pow2 with ⟨ k, rfl ⟩ ; rcases k with ( _ | _ | _ | k ) <;> simp_all +decide [ pow_succ' ] ;
    -- By `OmegaZ_pow2_mod_4`, $\Omega_{2^{k+3}}(a) \equiv 2 \pmod{4}$.
    have h_mod : (OmegaZ (2 * (2 * (2 * 2 ^ k)))).eval a ≡ 2 [ZMOD 4] := by
      convert OmegaZ_pow2_mod_4 ( 3 + k ) ( by linarith ) a using 1 ; ring;
    exact absurd ( Int.emod_eq_zero_of_dvd h_dvd ) ( by rw [ h_mod ] ; decide );
  · exact False.elim <| h_pow2 <| lemma_n_pow2_of_four_dvd_OmegaZ n a ( pos_of_gt hn ) h_dvd

/-
Corrected version of Satz 1 part 3: If $p \mid n$ and $p^2 \mid \Omega_n(a)$, then $p=2, n \in \{2,4\}$ or $p=3, n \in \{3,6\}$.
-/
theorem Satz_1_part3_corrected (n : ℕ) (a : ℤ) (hn : n > 1) (ha : |a| > 1) (p : ℕ) (hp : p.Prime) (h_dvd_n : p ∣ n) (h_dvd_sq : (p : ℤ)^2 ∣ (OmegaZ n).eval a) : (p = 2 ∧ (n = 2 ∨ n = 4)) ∨ (p = 3 ∧ (n = 3 ∨ n = 6)) := by
  by_cases hp5 : p ≥ 5;
  · have := Satz_1_part3_ge_5 n a hn ha p hp hp5 h_dvd_n; contrapose! this; aesop;
    obtain ⟨ k, hk ⟩ := h_dvd_sq; aesop;
    by_cases hk0 : k = 0;
    · have := lemma_root_OmegaZ_int_implies_small_n n ( pos_of_gt hn ) a; aesop;
      · linarith [ Nat.le_of_dvd ( by decide ) h_dvd_n ];
      · have := Nat.le_of_dvd ( by decide ) h_dvd_n; interval_cases p;
      · linarith [ Nat.le_of_dvd ( by decide ) h_dvd_n ];
      · have := Nat.le_of_dvd ( by decide ) h_dvd_n; interval_cases p <;> trivial;
    · rw [ multiplicity_mul ] <;> norm_num [ hk0, hp.ne_one, hp.ne_zero ];
      · refine' lt_add_of_lt_of_nonneg _ ( Nat.zero_le _ );
        norm_num [ multiplicity ];
        erw [ emultiplicity_pow_self ] <;> norm_num [ hp.ne_one, hp.ne_zero ];
        · decide +revert;
        · exact mod_cast hp.not_unit;
      · exact Nat.prime_iff_prime_int.mp hp;
      · exact Int.finiteMultiplicity_iff.mpr ⟨ by norm_cast; aesop_cat, by norm_cast; aesop_cat ⟩;
  · interval_cases p <;> simp_all ( config := { decide := Bool.true } );
    · exact?;
    · exact?

/-
For $n=2$, the exception condition is equivalent to $|\Omega_2(a)|$ being a power of a prime dividing 2.
-/
def is_prime_power_dividing_n (n : ℕ) (a : ℤ) : Prop :=
  ∃ p : ℕ, p.Prime ∧ p ∣ n ∧ ∃ k : ℕ, |(OmegaZ n).eval a| = p ^ k

lemma exception_iff_prime_power_n2 (a : ℤ) (ha : |a| > 1) :
  is_exception 2 a ↔ is_prime_power_dividing_n 2 a := by
    aesop;
    · cases a_1 <;> aesop;
      · use 2;
        norm_num [ OmegaZ_two ];
        exact ⟨ w, by rw [ abs_of_nonneg ] <;> cases w <;> norm_num [ pow_succ' ] at * <;> linarith [ pow_pos ( zero_lt_two' ℤ ) ‹_› ] ⟩;
      · use 2;
        erw [ OmegaZ_two ] ; norm_num [ Polynomial.eval_finset_sum ] ; ring ; aesop;
        exact ⟨ w - 1 + 1, by ring ⟩;
    · cases a_1 ; aesop;
      -- Apply the lemma prime_power_implies_exception_n2_final with the given parameters.
      apply (prime_power_implies_exception_n2_final a ha w left left_1 w_1 h)

/-
For $n=3$, the exception condition is equivalent to $|\Omega_3(a)|$ being a power of a prime dividing 3.
-/
lemma exception_iff_prime_power_n3 (a : ℤ) (ha : |a| > 1) :
  is_exception 3 a ↔ is_prime_power_dividing_n 3 a := by
    unfold is_exception is_prime_power_dividing_n; aesop;
    · use 3;
      rw [ show OmegaZ 3 = 2 * Polynomial.X + 1 from by exact? ] ; norm_num [ h ];
    · use 3;
      rw [ show OmegaZ 3 = 2 * Polynomial.X + 1 from by exact? ] ; aesop;
      norm_num;
    · -- Since $w \mid 3$, we have $w = 3$.
      have hw : w = 3 := by
        have := Nat.le_of_dvd ( by decide ) left_1; interval_cases w <;> trivial;
      -- Since $|2a + 1| = 3^{w_1}$, we have $2a + 1 = \pm 3^{w_1}$.
      have h_cases : 2 * a + 1 = 3 ^ w_1 ∨ 2 * a + 1 = -3 ^ w_1 := by
        have h_cases : |2 * a + 1| = 3 ^ w_1 := by
          convert h using 1 ; norm_num [ hw, OmegaZ_three ];
          norm_num [ hw ];
        exact eq_or_eq_neg_of_abs_eq h_cases;
      grind

/-
For $n=4$, the exception condition is equivalent to $|\Omega_4(a)|$ being a power of a prime dividing 4.
-/
lemma exception_iff_prime_power_n4 (a : ℤ) (ha : |a| > 1) :
  is_exception 4 a ↔ is_prime_power_dividing_n 4 a := by
    constructor <;> norm_num [ is_prime_power_dividing_n ];
    · unfold is_exception; aesop;
      · use 2, by norm_num, by norm_num, w - 1 + 1; norm_num [ OmegaZ_four, abs_mul ] ; ring;
      · -- Since $|OmegaZ 4.eval (-2^(w-1))| = 2 * 2^(w-1) = 2^w$, we can choose $p = 2$ and $k = w$.
        use 2, by norm_num, by norm_num, w
        simp [OmegaZ_four];
        rw [ ← pow_succ', Nat.sub_add_cancel left ];
    · intro p pp dp x hx; have := Nat.le_of_dvd ( by decide ) dp; interval_cases p <;> simp_all ( config := { decide := Bool.true } ) ;
      -- Since $|2a| = 2^x$, we have $|a| = 2^{x-1}$.
      have ha_eq : |a| = 2 ^ (x - 1) := by
        rw [ show OmegaZ 4 = 2 * Polynomial.X from by
              exact? ] at hx ; norm_num [ abs_mul ] at hx;
        cases x <;> norm_num [ pow_succ' ] at * <;> linarith;
      unfold is_exception; aesop;
      exact Or.inr <| Or.inr <| ⟨ x, Nat.pos_of_ne_zero <| by aesop_cat, eq_or_eq_neg_of_abs_eq ha_eq ⟩

/-
For $n=6$, the exception condition is equivalent to $|\Omega_6(a)|$ being a power of a prime dividing 6.
-/
lemma exception_iff_prime_power_n6 (a : ℤ) (ha : |a| > 1) :
  is_exception 6 a ↔ is_prime_power_dividing_n 6 a := by
    unfold is_exception is_prime_power_dividing_n at * ;
    rw [ show OmegaZ 6 = 2 * Polynomial.X - 1 from ?_ ] ; aesop;
    · exact ⟨ 3, by norm_num, by norm_num, w, by norm_cast ⟩;
    · exact ⟨ 3, by norm_num, by norm_num, w, by norm_num ⟩;
    · have := Nat.le_of_dvd ( by decide ) left_1; interval_cases w <;> norm_num at * ; aesop;
      · rcases w_1 with ( _ | _ | w_1 ) <;> norm_num [ pow_succ' ] at * <;> cases abs_cases ( 2 * a - 1 ) <;> first | omega | aesop;
      · rw [ abs_eq ] at h <;> aesop;
        · exact Or.inr <| Or.inr <| Or.inr <| ⟨ w_1, Nat.pos_of_ne_zero fun h => by subst h; norm_num at h_1; cases abs_cases a <;> linarith, Or.inl <| by linarith ⟩;
        · exact Or.inr <| Or.inr <| Or.inr <| ⟨ w_1, Nat.pos_of_ne_zero <| by rintro rfl; norm_num at h_2; cases abs_cases a <;> linarith, Or.inr <| by linarith ⟩;
    · exact?

/-
Corrected definition of the exceptional cases for Zsigmondy's Theorem analogue, excluding non-exceptions for n=2.
-/
def is_exception_satz2 (n : ℕ) (a : ℤ) : Prop :=
  (a = 1 ∧ n > 1) ∨
  (a = 0 ∧ n ≠ 2 ∧ n ≠ 4) ∨
  (a = -1 ∧ n > 2) ∨
  (n = 1 ∧ (a = 0 ∨ a = 2)) ∨
  (n = 2 ∧ ∃ k : ℕ, k > 1 ∧ (a = (2 : ℤ)^(k - 1) - 1 ∨ a = -(2 : ℤ)^(k - 1) - 1)) ∨
  (n = 3 ∧ ∃ k : ℕ, k > 0 ∧ (2 * a = (3 : ℤ)^k - 1 ∨ 2 * a = -(3 : ℤ)^k - 1)) ∨
  (n = 4 ∧ ∃ k : ℕ, k > 0 ∧ (a = (2 : ℤ)^(k - 1) ∨ a = -(2 : ℤ)^(k - 1))) ∨
  (n = 6 ∧ ∃ k : ℕ, k > 0 ∧ (2 * a = (3 : ℤ)^k + 1 ∨ 2 * a = -(3 : ℤ)^k + 1))

/-
For n >= 2 and |a| >= 2, |OmegaZ_n(a)| >= 2^(phi(n)/2).
-/
lemma OmegaZ_lower_bound (n : ℕ) (a : ℤ) (hn : n ≥ 2) (ha : |a| ≥ 2) :
  |(OmegaZ n).eval a| ≥ 2 ^ (Nat.totient n / 2) := by
    -- Let's unfold the definition of `OmegaZ` and use the properties of `Omega`.
    have h_omega_z : (OmegaZ n).eval a = (Omega n).eval (a : ℝ) := by
      rw [ Omega_eq_map_OmegaZ ] ; norm_num;
    -- We'll use that $|\Omega_n(a)| = |\Psi_{mod, n}(2a)|$.
    have h_psi_mod : |(OmegaZ n).eval a| = |(Psi_mod n).eval (2 * a : ℝ)| := by
      have := Omega_comp_half_eq_Psi_mod n ( by linarith ) ; replace := congr_arg ( Polynomial.eval ( 2 * a : ℝ ) ) this ; norm_num at * ; aesop;
    -- We'll use that $|\Psi_{mod, n}(2a)| = \prod_{k \in \text{good}(n)} |2a - 2\cos(2k\pi/n)|$.
    have h_psi_mod_prod : |(Psi_mod n).eval (2 * a : ℝ)| = ∏ k ∈ ((Finset.Ioc 0 (n / 2)).filter (fun k => Nat.Coprime n k)), |2 * a - 2 * Real.cos (2 * k * Real.pi / n)| := by
      unfold Psi_mod; aesop;
      norm_num [ Polynomial.eval_prod, Finset.abs_prod ];
    -- We'll use that $|2a - 2\cos(2k\pi/n)| \geq 2$ for all $k$.
    have h_cos_bound : ∀ k ∈ ((Finset.Ioc 0 (n / 2)).filter (fun k => Nat.Coprime n k)), |2 * a - 2 * Real.cos (2 * k * Real.pi / n)| ≥ 2 := by
      intro k hk;
      cases abs_cases ( 2 * a - 2 * Real.cos ( 2 * k * Real.pi / n ) ) <;> cases abs_cases ( a : ℝ ) <;> push_cast [ * ] at * <;> nlinarith [ Real.neg_one_le_cos ( 2 * k * Real.pi / n ), Real.cos_le_one ( 2 * k * Real.pi / n ), show ( |a| : ℝ ) ≥ 2 by exact_mod_cast ha ];
    have h_card : Finset.card ((Finset.Ioc 0 (n / 2)).filter (fun k => Nat.Coprime n k)) ≥ Nat.totient n / 2 := by
      -- The set of integers $k$ in the range $1$ to $n/2$ that are coprime to $n$ is exactly the set of integers $k$ in the range $1$ to $n$ that are coprime to $n$ and less than or equal to $n/2$.
      have h_set_eq : ((Finset.Ioc 0 (n / 2)).filter (fun k => Nat.Coprime n k)) ∪ Finset.image (fun k => n - k) ((Finset.Ioc 0 (n / 2)).filter (fun k => Nat.Coprime n k)) ⊇ Finset.filter (fun k => Nat.Coprime n k) (Finset.Ico 1 n) := by
        intro k hk; aesop;
        by_cases hk : k ≤ n / 2 <;> [ exact Or.inl ⟨ ⟨ left, hk ⟩, right ⟩ ; exact Or.inr ⟨ n - k, ⟨ ⟨ Nat.sub_pos_of_lt right_1, Nat.sub_le_of_le_add <| by linarith [ Nat.div_add_mod n 2, Nat.mod_lt n two_pos ] ⟩, by simpa [ right_1.le ] using right ⟩, Nat.sub_sub_self right_1.le ⟩ ];
      have h_card_eq : Finset.card (Finset.filter (fun k => Nat.Coprime n k) (Finset.Ico 1 n)) = Nat.totient n := by
        congr 1 with x ; simp +decide [ Nat.coprime_comm ];
        exact fun _ _ => Nat.pos_of_ne_zero ( by aesop );
      have := Finset.card_mono h_set_eq; simp_all +decide [ Finset.card_image_of_injOn ] ;
      exact Nat.div_le_of_le_mul <| by linarith [ show Finset.card ( Finset.image ( fun k => n - k ) ( Finset.filter ( fun k => Nat.Coprime n k ) ( Finset.Ioc 0 ( n / 2 ) ) ) ) ≤ Finset.card ( Finset.filter ( fun k => Nat.Coprime n k ) ( Finset.Ioc 0 ( n / 2 ) ) ) from Finset.card_image_le, show Finset.card ( Finset.filter ( fun k => Nat.Coprime n k ) ( Finset.Ioc 0 ( n / 2 ) ) ∪ Finset.image ( fun k => n - k ) ( Finset.filter ( fun k => Nat.Coprime n k ) ( Finset.Ioc 0 ( n / 2 ) ) ) ) ≤ Finset.card ( Finset.filter ( fun k => Nat.Coprime n k ) ( Finset.Ioc 0 ( n / 2 ) ) ) + Finset.card ( Finset.filter ( fun k => Nat.Coprime n k ) ( Finset.Ioc 0 ( n / 2 ) ) ) from Finset.card_union_le _ _ |> le_trans <| add_le_add_left ( Finset.card_image_le ) _ ] ;
    -- Using the bounds on the cardinality and the cosine terms, we can conclude the proof.
    have h_final_bound : ∏ k ∈ ((Finset.Ioc 0 (n / 2)).filter (fun k => Nat.Coprime n k)), |2 * a - 2 * Real.cos (2 * k * Real.pi / n)| ≥ 2 ^ (Nat.totient n / 2) := by
      exact le_trans ( by simpa using pow_le_pow_right₀ ( by norm_num ) h_card ) ( Finset.prod_le_prod ( fun _ _ => by norm_num ) h_cos_bound );
    norm_num [ ← @Int.cast_le ℝ ] at * ; linarith

/-
If |OmegaZ_n(a)| = p^k with p|n and n not in {2,3,4,6}, then k=1.
-/
lemma prime_power_exponent_eq_one (n : ℕ) (a : ℤ) (hn : n > 1) (ha : |a| > 1) (p : ℕ) (hp : p.Prime) (h_dvd_n : p ∣ n) (k : ℕ) (h_eq : |(OmegaZ n).eval a| = p ^ k) (h_not_exc : n ≠ 2 ∧ n ≠ 3 ∧ n ≠ 4 ∧ n ≠ 6) : k = 1 := by
  by_cases hk : k ≥ 2;
  · have := Satz_1_part3_corrected n a hn ha p hp h_dvd_n ( by exact dvd_trans ( pow_dvd_pow _ hk ) ( by rw [ ← h_eq ] ; exact by norm_num ) ) ; aesop;
  · interval_cases k <;> simp_all +decide;
    have := OmegaZ_lower_bound n a hn ha;
    exact this.not_lt ( h_eq.symm ▸ one_lt_pow₀ one_lt_two ( Nat.ne_of_gt ( Nat.div_pos ( Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop ) ) ( even_iff_two_dvd.mp ( Nat.totient_even <| by omega ) ) ) zero_lt_two ) ) )

/-
For |a| > 1, |OmegaZ_5(a)| > 5.
-/
lemma OmegaZ_gt_max_prime_divisor_5 (a : ℤ) (ha : |a| > 1) :
  |(OmegaZ 5).eval a| > (5 : ℕ).primeFactors.max.getD 1 := by
    rw [ show ( Nat.primeFactors 5 : Finset ℕ ) = { 5 } by native_decide ] ; norm_num [ Option.getD ];
    -- We have $\OmegaZ_5(a) = 4a^2 + 2a - 1$.
    have h_OmegaZ_5 : (OmegaZ 5).eval a = 4 * a^2 + 2 * a - 1 := by
      unfold OmegaZ;
      have h_OmegaZ_5 : Omega 5 = 4 * Polynomial.X ^ 2 + 2 * Polynomial.X - 1 := by
        unfold Omega;
        norm_num [ Finset.prod_filter, Finset.prod_Ioc_succ_top ];
        refine' Polynomial.funext fun x => _ ; norm_num ; ring;
        rw [ show Real.pi * ( 4 / 5 ) = Real.pi - Real.pi * ( 1 / 5 ) by ring, Real.cos_pi_sub ] ; ring ; norm_num [ mul_div ] ; ring;
        rw [ show Real.pi * ( 2 / 5 ) = 2 * ( Real.pi / 5 ) by ring, Real.cos_two_mul ] ; ring ; norm_num [ mul_div ] ; ring;
        norm_num [ pow_three ] ; ring;
      aesop;
      rw [ show ( 4 * X ^ 2 + 2 * X - 1 : Polynomial ℝ ).support = { 0, 1, 2 } from ?_ ] ; norm_num [ Polynomial.coeff_one, Polynomial.coeff_X, Polynomial.coeff_C ] ; ring;
      · norm_num [ Polynomial.coeff_one, Polynomial.coeff_X ] at * ; norm_cast at * ; aesop ; ring;
      · ext ( _ | _ | _ | k ) <;> simp +arith +decide [ Polynomial.coeff_eq_zero_of_natDegree_lt ];
    cases abs_cases a <;> cases abs_cases ( 4 * a ^ 2 + 2 * a - 1 ) <;> push_cast [ * ] at * <;> nlinarith

/-
For |a| > 1, |OmegaZ_10(a)| > 5.
-/
lemma OmegaZ_gt_max_prime_divisor_10 (a : ℤ) (ha : |a| > 1) :
  |(OmegaZ 10).eval a| > (10 : ℕ).primeFactors.max.getD 1 := by
    erw [ show OmegaZ 10 = 4 * Polynomial.X ^ 2 - 2 * Polynomial.X - 1 from ?_ ];
    · norm_num +zetaDelta at *;
      erw [ show ( Nat.primeFactors 10 : Finset ℕ ) = { 2, 5 } by native_decide ] ; norm_num [ Option.getD ] ; cases abs_cases a <;> cases abs_cases ( 4 * a ^ 2 - 2 * a - 1 ) <;> nlinarith;
    · unfold OmegaZ;
      -- By definition of OmegaZ, we know that OmegaZ 10 is the polynomial with coefficients chosen such that when evaluated at a, it gives the same result as Omega 10.
      have h_OmegaZ_10 : OmegaZ 10 = 4 * Polynomial.X^2 - 2 * Polynomial.X - 1 := by
        have h_Omega_10 : Omega 10 = 4 * Polynomial.X^2 - 2 * Polynomial.X - 1 := by
          unfold Omega; norm_num [ Chebyshev.T ] ; ring;
          rw [ show ( Finset.filter ( fun x => Nat.Coprime 10 x ) ( Finset.Ioc 0 5 ) ) = { 1, 3 } by decide ] ; norm_num ; ring;
          rw [ show Real.pi * ( 3 / 5 ) = Real.pi - 2 * ( Real.pi * ( 1 / 5 ) ) by ring, Real.cos_pi_sub, Real.cos_two_mul ] ; ring;
          -- Substitute the known value of $\cos(\pi/5)$ into the expression.
          have h_cos : Real.cos (Real.pi * (1 / 5)) = (1 + Real.sqrt 5) / 4 := by
            field_simp;
            have := Real.cos_three_mul ( Real.pi / 5 ) ; rw [ show 3 * ( Real.pi / 5 ) = Real.pi - 2 * ( Real.pi / 5 ) by ring, Real.cos_pi_sub, Real.cos_two_mul ] at this ; ring_nf at * ; norm_num at *;
            exact eq_add_of_sub_eq' ( by rw [ eq_comm, Real.sqrt_eq_iff_mul_self_eq ] <;> nlinarith [ show 0 < Real.cos ( Real.pi * ( 1 / 5 ) ) from Real.cos_pos_of_mem_Ioo ⟨ by linarith [ Real.pi_pos ], by linarith [ Real.pi_pos ] ⟩ ] );
          rw [ h_cos ] ; ring;
          exact Polynomial.funext fun x => by norm_num; ring ; norm_num ; ring;
        unfold OmegaZ; aesop;
        erw [ show ( 4 * Polynomial.X ^ 2 - 2 * Polynomial.X - 1 : Polynomial ℝ ).support = { 0, 1, 2 } from ?_ ] ; norm_num [ Finset.sum_range_succ', Polynomial.coeff_one, Polynomial.coeff_X ] ; ring;
        · have := Classical.choose_spec ( Omega_integral 10 0 ) ; have := Classical.choose_spec ( Omega_integral 10 1 ) ; have := Classical.choose_spec ( Omega_integral 10 2 ) ; norm_num at * ; aesop;
          norm_num [ Polynomial.coeff_one, Polynomial.coeff_X ] at * ; ring_nf at * ; aesop;
          norm_cast at * ; aesop;
          ring;
        · ext ( _ | _ | _ | n ) <;> norm_num [ Polynomial.coeff_one, Polynomial.coeff_X, Polynomial.coeff_C ];
      exact h_OmegaZ_10

/-
For n >= 5, n not in {5, 6, 10}, 2^(phi(n)/2) > max_prime_divisor(n).
-/
lemma totient_bound_prime (n : ℕ) (hn : n ≥ 5) (hn6 : n ≠ 6) (hn5 : n ≠ 5) (hn10 : n ≠ 10) :
  2 ^ (Nat.totient n / 2) > n.primeFactors.max.getD 1 := by
    unfold Option.getD; aesop;
    · have := Finset.mem_of_max heq; aesop;
      by_cases hx : x ≤ 31;
      · interval_cases x <;> norm_num at *;
        all_goals contrapose! heq;
        all_goals intro H; have := Nat.totient_even ( by linarith : n ≥ 3 ) ; simp_all +decide [ Nat.totient_prime, parity_simps ] ;
        all_goals have := Nat.totient_dvd_of_dvd left_1; simp_all +decide [ Nat.totient_prime ] ;
        all_goals have : φ n / 2 ≤ 5 := Nat.le_of_not_lt fun h => by linarith [ Nat.pow_le_pow_right two_pos h ] ; ; interval_cases _ : φ n / 2 <;> simp_all +decide only ;
        any_goals omega;
        all_goals obtain ⟨ k, hk ⟩ := this; simp_all +decide [ Nat.even_iff ] ;
        all_goals rcases k with ( _ | _ | k ) <;> simp_all +arith +decide;
        · have := Nat.totient_eq_prod_factorization ( by linarith : n ≠ 0 ) ; simp_all +decide [ Nat.primeFactors_mul ] ;
          -- Since $n$ is even and its prime factors are all 2, we have $n = 2^k$ for some $k$.
          obtain ⟨k, rfl⟩ : ∃ k, n = 2 ^ k := by
            have h_prime_factors : n.primeFactors ⊆ {2} := by
              intro p hp; have := Finset.le_max_of_eq hp H; aesop;
              interval_cases p <;> trivial;
            rw [ ← Nat.factorization_prod_pow_eq_self right ] ; rw [ Finsupp.prod ] ; aesop;
          rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.totient_prime_pow ];
          simp_all +decide [ pow_succ' ];
        · omega;
        · have := Nat.totient_eq_prod_factorization ( by linarith : n ≠ 0 ) ; simp_all +decide [ Nat.primeFactors_mul ] ;
          have h_prime_factors : n.primeFactors ⊆ {2, 3} := by
            intro p hp; have := Finset.le_max_of_eq hp H; aesop;
            interval_cases p <;> trivial;
          -- Since $n$ is divisible by 3 and its prime factors are only 2 and 3, we can write $n = 2^a * 3^b$ for some $a, b \geq 0$.
          obtain ⟨a, b, ha, hb⟩ : ∃ a b : ℕ, n = 2^a * 3^b := by
            rw [ ← Nat.factorization_prod_pow_eq_self right ];
            rw [ Finsupp.prod_of_support_subset _ h_prime_factors ] <;> aesop;
          rcases a with ( _ | _ | a ) <;> rcases b with ( _ | _ | b ) <;> simp_all +decide [ Nat.totient_mul, Nat.totient_prime_pow ];
          · simp_all +decide [ Nat.pow_succ' ];
          · simp_all +decide [ Nat.totient_prime ];
          · nlinarith [ Nat.pow_le_pow_right ( show 1 ≤ 2 by norm_num ) ( show a + 1 ≥ 1 by norm_num ), Nat.pow_le_pow_right ( show 1 ≤ 3 by norm_num ) ( show b + 1 ≥ 1 by norm_num ) ];
        · have := Nat.totient_eq_prod_factorization ( by linarith : n ≠ 0 ) ; simp_all +decide [ Nat.primeFactors_mul ] ;
          have h_prime_factors : n.primeFactors ⊆ {2, 5} := by
            intro p hp; have := Finset.le_max_of_eq hp H; aesop;
            interval_cases p <;> norm_num at *;
            exact absurd ( this_1 ▸ Nat.totient_dvd_of_dvd ( Nat.lcm_dvd right_1 left_1 ) ) ( by decide );
          -- Since $n$ is divisible by $5$ and its prime factors are a subset of $\{2, 5\}$, we can write $n$ as $2^a \cdot 5^b$ for some $a, b \geq 0$.
          obtain ⟨a, b, ha, hb⟩ : ∃ a b : ℕ, n = 2^a * 5^b := by
            rw [ ← Nat.factorization_prod_pow_eq_self right ];
            rw [ Finsupp.prod_of_support_subset _ h_prime_factors ] <;> aesop;
          rcases a with ( _ | _ | a ) <;> rcases b with ( _ | _ | b ) <;> norm_num [ Nat.totient_mul, Nat.totient_prime_pow ] at *;
          · simp_all +decide [ Nat.Prime.dvd_iff_one_le_factorization ];
          · norm_num [ Nat.totient_prime ] at this;
          · nlinarith [ pow_le_pow_right₀ ( show 1 ≤ 2 by norm_num ) ( show a + 1 ≥ 1 by norm_num ), pow_le_pow_right₀ ( show 1 ≤ 5 by norm_num ) ( show b + 1 ≥ 1 by norm_num ) ];
        · omega;
      · -- Since $x$ is a prime factor of $n$ and $x > 31$, we have $\phi(n) \geq x - 1$.
        have h_phi_ge_x_minus_1 : Nat.totient n ≥ x - 1 := by
          have := Nat.totient_dvd_of_dvd left_1;
          exact Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop ) ) ( by simpa [ Nat.totient_prime left ] using this );
        refine' lt_of_lt_of_le _ ( Nat.pow_le_pow_right ( by decide ) ( Nat.div_le_div_right h_phi_ge_x_minus_1 ) );
        rcases Nat.even_or_odd' x with ⟨ c, rfl | rfl ⟩ <;> norm_num at *;
        · simp_all +decide [ Nat.prime_mul_iff ];
        · exact Nat.le_induction ( by norm_num ) ( fun k hk ih => by rw [ pow_succ' ] ; linarith [ Nat.Prime.one_lt left ] ) c ( show c ≥ 16 by linarith );
    · -- Since $n \geq 5$, we can use the fact that $\phi(n)$ is even for $n > 2$.
      have h_phi_even : ∀ n ≥ 3, Even (Nat.totient n) := by
        exact fun n hn => Nat.totient_even hn;
      exact Nat.le_of_dvd ( Nat.pos_of_ne_zero ( by aesop ) ) ( even_iff_two_dvd.mp ( h_phi_even n ( by linarith ) ) )

/-
Definition of the exceptional cases for Zsigmondy's Theorem analogue.
-/
def is_exception_Satz2 (n : ℕ) (a : ℤ) : Prop :=
  (a = 1 ∧ n > 1) ∨
  (a = 0 ∧ n ≠ 2 ∧ n ≠ 4) ∨
  (a = -1 ∧ n > 2) ∨
  (n = 1 ∧ (a = 0 ∨ a = 2)) ∨
  (n = 2 ∧ ∃ k : ℕ, k > 1 ∧ (a = (2 : ℤ)^(k - 1) - 1 ∨ a = -(2 : ℤ)^(k - 1) - 1)) ∨
  (n = 3 ∧ ∃ k : ℕ, k > 0 ∧ (2 * a = (3 : ℤ)^k - 1 ∨ 2 * a = -(3 : ℤ)^k - 1)) ∨
  (n = 4 ∧ ∃ k : ℕ, k > 0 ∧ (a = (2 : ℤ)^(k - 1) ∨ a = -(2 : ℤ)^(k - 1))) ∨
  (n = 6 ∧ ∃ k : ℕ, k > 0 ∧ (2 * a = (3 : ℤ)^k + 1 ∨ 2 * a = -(3 : ℤ)^k + 1))

/-
For |a| > 1 and n >= 5 (n != 6), a primitive prime divisor always exists.
-/
lemma lemma_primitive_exists_of_large_n (n : ℕ) (a : ℤ) (ha : |a| > 1) (hn : n ≥ 5) (hn6 : n ≠ 6) :
  ∃ p : ℕ, is_primitive_prime_divisor_Chebyshev a n p := by
    -- We use the corollary `wniosek`. A primitive prime divisor exists unless there exists a prime $p|n$ and $k$ such that $|\Omega_n(a)| = p^k$.
    by_contra h_no_primitive_prime_divisor
    obtain ⟨p, hp⟩ : ∃ p : ℕ, p.Prime ∧ p ∣ n ∧ |(OmegaZ n).eval a| = p := by
      have h_prime_power : ∃ p : ℕ, p.Prime ∧ p ∣ n ∧ ∃ k : ℕ, |(OmegaZ n).eval a| = p ^ k := by
        have := wniosek n a ( by linarith ) ha;
        apply this.mp;
        unfold Che; aesop;
        have := Nat.sInf_mem ( show { m : ℕ | 0 < m ∧ ( x : ℤ ) ∣ eval a ( Chebyshev.T ℤ m ) - 1 }.Nonempty from by exact Nat.nonempty_of_pos_sInf <| pos_of_gt hn ) ; aesop;
        unfold is_primitive_prime_divisor_Chebyshev at h_no_primitive_prime_divisor; aesop;
        exact absurd ( h_no_primitive_prime_divisor x a_1 right ) ( by rintro ⟨ k, hk₁, hk₂, hk₃ ⟩ ; exact hk₂.not_le ( Nat.sInf_le ⟨ hk₁, hk₃ ⟩ ) );
      obtain ⟨ p, hp₁, hp₂, k, hk ⟩ := h_prime_power;
      have := prime_power_exponent_eq_one n a ( by linarith ) ha p hp₁ hp₂ k hk ( by omega ) ; aesop;
    -- If $n=5$, then $p=5$. But $|\Omega_5(a)| > 5$ by `OmegaZ_gt_max_prime_divisor_5`. Contradiction.
    by_cases hn5 : n = 5;
    · have := OmegaZ_gt_max_prime_divisor_5 a ha; simp_all +decide ;
      have := Nat.le_of_dvd ( by decide ) hp.2.1; interval_cases p <;> contradiction;
    · -- If $n=10$, then $p \in \{2, 5\}$. But $|\Omega_{10}(a)| > 5 \ge p$ by `OmegaZ_gt_max_prime_divisor_10`. Contradiction.
      by_cases hn10 : n = 10;
      · -- If $n=10$, then $p \in \{2, 5\}$. But $|\Omega_{10}(a)| > 5 \ge p$ by `OmegaZ_gt_max_prime_divisor_10`. Contradiction.
        have h_contra : |(OmegaZ 10).eval a| > 5 := by
          convert OmegaZ_gt_max_prime_divisor_10 a ha using 1;
          native_decide +revert;
        bound;
        have := Nat.le_of_dvd ( by decide ) left_1; interval_cases p <;> norm_num at * <;> linarith;
      · -- Since $n \notin \{5, 10\}$, we have $2^{\phi(n)/2} > \max_{q|n} q \ge p$ by `totient_bound_prime`.
        have h_totient_bound : 2 ^ (Nat.totient n / 2) > p := by
          have := @totient_bound_prime n hn hn6 hn5 hn10;
          refine' lt_of_le_of_lt _ this;
          have := Finset.le_max ( Nat.mem_primeFactors.mpr ⟨ hp.1, hp.2.1, by linarith ⟩ ) ; aesop;
          cases h : Finset.max n.primeFactors <;> aesop;
        -- Since $|OmegaZ_n(a)| \ge 2^{\phi(n)/2}$ by `OmegaZ_lower_bound`, we have $|OmegaZ_n(a)| > p$.
        have h_OmegaZ_lower_bound : |(OmegaZ n).eval a| ≥ 2 ^ (Nat.totient n / 2) := by
          apply OmegaZ_lower_bound n a (by linarith) (by linarith);
        linarith!

/-
For |a| <= 1, a primitive prime divisor exists iff (n, a) is not an exception.
-/
lemma lemma_primitive_iff_not_exception_small_a (n : ℕ) (a : ℤ) (hn : n > 0) (ha : |a| ≤ 1) :
  (∃ p : ℕ, is_primitive_prime_divisor_Chebyshev a n p) ↔ ¬ is_exception_Satz2 n a := by
    by_cases h : a = 1 ∨ a = 0 ∨ a = -1;
    · rcases h with ( rfl | rfl | rfl );
      · unfold is_exception_Satz2 is_primitive_prime_divisor_Chebyshev; aesop;
        any_goals linarith [ right 1 zero_lt_one ];
        · exists 3;
        · linarith;
      · aesop;
        · cases a <;> aesop;
          any_goals linarith [ pow_pos ( by decide : 0 < 3 ) w_1 ];
          any_goals linarith [ pow_le_pow_right₀ ( by decide : 1 ≤ 2 ) ( Nat.le_sub_one_of_lt left_1 ), pow_le_pow_right₀ ( by decide : 1 ≤ 3 ) left_1 ];
          · rcases n with ( _ | _ | _ | _ | _ | n ) <;> simp_all +decide [ is_primitive_prime_divisor_Chebyshev ];
            · norm_cast at h; aesop;
            · norm_num [ show ( Chebyshev.T ℤ 3 ) = 4 * Polynomial.X ^ 3 - 3 * Polynomial.X from T3_eq ] at h;
              norm_cast at h; aesop;
            · have := h.2.2 4 ( by norm_num ) ( by linarith ) ; norm_num [ Chebyshev.T ] at this;
              erw [ show ( Chebyshev.T ℤ 4 : Polynomial ℤ ) = 8 * Polynomial.X ^ 4 - 8 * Polynomial.X ^ 2 + 1 by { exact Polynomial.funext fun x => by { have := Chebyshev.T_add_two ℤ 2; have := Chebyshev.T_add_two ℤ 1; have := Chebyshev.T_add_two ℤ 0; norm_num at * ; { ring_nf at * ; aesop } } } ] at this ; norm_num at this;
          · cases h ; aesop;
            norm_cast at *; aesop;
        · rcases n with ( _ | _ | _ | _ | _ | n ) <;> simp_all +decide [ is_exception_Satz2 ];
          · exists 2;
            constructor <;> norm_num;
            aesop;
            · erw [ Chebyshev.T ] ; norm_num;
            · interval_cases d ; norm_num [ Chebyshev.T ];
          · refine' ⟨ 3, _, _, _ ⟩ <;> norm_num;
            · erw [ Chebyshev.T ] ; norm_num;
              erw [ Chebyshev.T ] ; norm_num;
            · intro d hd hd'; interval_cases d <;> norm_num [ Chebyshev.T ] ;
              · erw [ Chebyshev.T_two ] ; norm_num [ Polynomial.eval_mul, Polynomial.eval_X, Polynomial.eval_C ];
              · erw [ Chebyshev.T ] ; norm_num [ Polynomial.eval_X, Polynomial.eval_one, Polynomial.eval_add, Polynomial.eval_mul ] ;
      · unfold is_primitive_prime_divisor_Chebyshev is_exception_Satz2; aesop;
        any_goals linarith [ pow_pos ( by decide : 0 < 2 ) ( x - 1 ), pow_pos ( by decide : 0 < 3 ) x ];
        · contrapose! right;
          use 2;
          aesop;
          rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> norm_num [ Int.negOnePow_add ] at *;
          · norm_num [ Int.negOnePow_even ];
          · norm_cast at *; have := Nat.le_of_dvd ( by decide ) left_1; interval_cases w <;> trivial;
        · linarith [ Nat.pow_le_pow_right ( show 1 ≤ 3 by decide ) a_1 ];
        · rcases x with ( _ | _ | _ | x ) <;> norm_num [ pow_succ' ] at *;
          · norm_num [ Int.negOnePow ] at *;
            exact right 2 ( by norm_num ) ( by norm_num ) ( by norm_num );
          · linarith [ Nat.one_le_pow x 2 zero_lt_two ];
        · rcases x with ( _ | _ | x ) <;> norm_num [ pow_succ' ] at *;
          · have := right 2 ( by decide ) ( by decide ) ; norm_num [ Int.negOnePow_succ ] at *;
            exact?;
          · omega;
        · interval_cases n <;> simp_all ( config := { decide := Bool.true } );
          · exact ⟨ 2, Nat.prime_two, by norm_num, fun d hd => ne_of_gt hd ⟩;
          · specialize left_1 2 ; norm_num at left_1;
            exact ⟨ 3, by decide, by decide, by intros; interval_cases ( ‹_› : ℕ ) ; decide ⟩;
    · cases abs_le.mp ha ; omega

/-
For n=1 and |a| > 1, a primitive prime divisor exists iff a != 2.
-/
lemma lemma_primitive_iff_not_exception_n1 (a : ℤ) (ha : |a| > 1) :
  (∃ p : ℕ, is_primitive_prime_divisor_Chebyshev a 1 p) ↔ ¬ is_exception_Satz2 1 a := by
    unfold is_primitive_prime_divisor_Chebyshev is_exception_Satz2; aesop;
    · norm_cast at *; aesop;
    · -- Since $|a| > 1$ and $a \neq 2$, we have $a - 1 \neq 0$ and $a - 1 \neq \pm 1$.
      have h_ne_zero : a - 1 ≠ 0 ∧ a - 1 ≠ 1 ∧ a - 1 ≠ -1 := by
        bound;
        · cases abs_cases a <;> linarith;
        · grind;
        · grind;
      exact ⟨ Nat.minFac ( Int.natAbs ( a - 1 ) ), Nat.minFac_prime ( mt Int.natAbs_eq_iff.mp <| by aesop ), Int.natCast_dvd.mpr <| Nat.minFac_dvd _, fun d hd => Nat.ne_of_gt hd ⟩

/-
The exception condition for n=2 is equivalent to |a+1| being a power of 2 with exponent >= 1.
-/
lemma exception_n2_iff_abs_add_one_pow2 (a : ℤ) :
  is_exception_Satz2 2 a ↔ ∃ k : ℕ, k > 1 ∧ Int.natAbs (a + 1) = 2 ^ (k - 1) := by
    unfold is_exception_Satz2; aesop;
    · exists 2;
    · exact ⟨ w, left, rfl ⟩;
    · exact ⟨ w, left, rfl ⟩;
    · cases abs_cases ( a + 1 ) <;> [ exact Or.inr ⟨ w, left, Or.inl <| by linarith ⟩ ; exact Or.inr ⟨ w, left, Or.inr <| by linarith ⟩ ]

/-
2 is a primitive prime divisor of T_2(a)-1 iff a is even.
-/
lemma two_is_primitive_n2_iff_even (a : ℤ) :
  is_primitive_prime_divisor_Chebyshev a 2 2 ↔ Even a := by
    unfold is_primitive_prime_divisor_Chebyshev; aesop;
    · specialize right 1 ; simp_all +decide [ even_iff_two_dvd, Int.add_emod, Int.sub_emod, Int.mul_emod ];
      grind;
    · norm_num;
    · erw [ Chebyshev.T_two ] ; obtain ⟨ k, rfl ⟩ := even_iff_two_dvd.mp a_1 ; norm_num [ Int.add_emod, Int.sub_emod, Int.mul_emod ];
      exact ⟨ 2 * k ^ 2 * 2 - 1, by ring ⟩;
    · interval_cases d ; obtain ⟨ k, rfl ⟩ := a_1 ; norm_num [ ← even_iff_two_dvd, parity_simps ];
      grind

/-
If |a+1| is a power of 2 with exponent >= 1, then a is odd.
-/
lemma odd_of_abs_add_one_pow2_gt_one (a : ℤ) (k : ℕ) (hk : k > 1) (h : Int.natAbs (a + 1) = 2 ^ (k - 1)) : Odd a := by
  replace h := congr_arg Even h ; rcases k with ( _ | _ | k ) <;> simp_all +decide [ parity_simps ]

lemma lemma_primitive_iff_not_exception_n2 (a : ℤ) (ha : |a| > 1) :
  (∃ p : ℕ, is_primitive_prime_divisor_Chebyshev a 2 p) ↔ ¬ is_exception_Satz2 2 a := by
    -- Apply the lemma is_exception_Satz2 2 a
    apply Iff.intro;
    · unfold is_exception_Satz2; aesop;
      · cases h;
        erw [ Chebyshev.T_two ] at * ; aesop;
        have := right 1 Nat.one_pos ( by norm_num ) ; norm_num [ Chebyshev.T ] at this;
        haveI := Fact.mk left; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, sub_eq_iff_eq_add ] ;
        -- From the equation $2 * (2^{x-1} - 1)^2 = 2$, we can divide both sides by 2 to get $(2^{x-1} - 1)^2 = 1$.
        have h_sq : (2 ^ (x - 1) - 1 : ZMod w) ^ 2 = 1 := by
          norm_num +zetaDelta at *;
          by_cases h : ( 2 : ZMod w ) = 0 <;> simp_all +decide [ sub_eq_iff_eq_add ];
        simp_all +decide [ sub_eq_iff_eq_add ];
      · rcases h with ⟨ hw₁, hw₂, hw₃ ⟩;
        specialize hw₃ 1 ; simp_all +decide [ Chebyshev.T ];
        erw [ Chebyshev.T_two ] at hw₂ ; norm_num at hw₂;
        haveI := Fact.mk hw₁; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
        by_cases h₂ : (2 : ZMod w) = 0;
        · rcases x with ( _ | _ | x ) <;> simp_all +decide [ pow_succ' ];
        · by_cases h₃ : (2 : ZMod w) ^ (x - 1) = 0;
          · exact absurd h₃ ( pow_ne_zero _ h₂ );
          · grind;
    · -- For $n = 2$, we need to show that the conditions for the existence of a primitive prime divisor are equivalent to the absence of the exception. We consider two cases: $a$ is even and $a$ is odd.
      intro h_not_exception
      by_cases h_even : Even a;
      · use 2;
        constructor <;> norm_num;
        erw [ Chebyshev.T ] ; norm_num [ h_even, Int.add_emod, Int.sub_emod, Int.mul_emod ];
        exact ⟨ by exact ⟨ a * a - 1, by ring ⟩, fun d hd hd' => by interval_cases d ; norm_num; exact by rw [ Int.even_iff ] at *; omega ⟩;
      · -- Since $a$ is odd, we can use the fact that $|a + 1|$ is even and greater than 2 to find a primitive prime divisor.
        have h_exists_prime : ∃ p : ℕ, Nat.Prime p ∧ p ∣ Int.natAbs (a + 1) ∧ ¬(p ∣ Int.natAbs (a - 1)) := by
          -- Since $a$ is odd, $a + 1$ is even, and $a - 1$ is even. Therefore, there exists a prime $p$ such that $p \mid a + 1$ and $p \neq 2$.
          obtain ⟨p, hp_prime, hp_div⟩ : ∃ p : ℕ, Nat.Prime p ∧ p ∣ Int.natAbs (a + 1) ∧ p ≠ 2 := by
            contrapose! h_not_exception;
            -- If $|a + 1|$ is a power of 2, then $a + 1 = \pm 2^k$ for some $k$.
            obtain ⟨k, hk⟩ : ∃ k : ℕ, Int.natAbs (a + 1) = 2 ^ k := by
              rw [ ← Nat.prod_primeFactorsList ( show Int.natAbs ( a + 1 ) ≠ 0 from by cases abs_cases ( a + 1 ) <;> cases abs_cases a <;> linarith ) ] ; rw [ List.prod_eq_pow_single 2 ] ; aesop;
              exact fun x hx₁ hx₂ => False.elim <| hx₁ <| h_not_exception x ( Nat.prime_of_mem_primeFactorsList hx₂ ) <| Nat.dvd_of_mem_primeFactorsList hx₂;
            rcases k with ( _ | k ) <;> simp_all +decide [ pow_succ' ];
            · rw [ Int.natAbs_eq_iff ] at hk ; aesop;
              norm_num [ show a = -2 by linarith ] at *;
            · unfold is_exception_Satz2; aesop;
              rw [ Int.natAbs_eq_iff ] at hk ; aesop;
              · exact Or.inr ⟨ k + 2, by linarith, Or.inl <| by norm_num [ pow_succ' ] at *; linarith ⟩;
              · exact Or.inr ⟨ k + 2, by linarith, Or.inr <| by norm_num [ pow_succ' ] ; linarith ⟩;
          refine' ⟨ p, hp_prime, hp_div.1, _ ⟩;
          intro h; have := Int.natAbs_dvd_natAbs.mpr ( Int.dvd_sub ( Int.natCast_dvd.mpr hp_div.1 ) ( Int.natCast_dvd.mpr h ) ) ; simp_all +decide [ ← even_iff_two_dvd, parity_simps ] ;
          have := Nat.le_of_dvd ( by decide ) this; interval_cases p <;> simp_all +decide ;
        obtain ⟨ p, hp_prime, hp_div_a1, hp_not_div_a3 ⟩ := h_exists_prime; use p; unfold is_primitive_prime_divisor_Chebyshev; aesop;
        · simp_all +decide [ ← Int.natCast_dvd_natCast, Chebyshev.T_two ];
          convert hp_div_a1.mul_left ( 2 * a - 2 ) using 1 ; ring;
        · interval_cases d ; simp_all +decide [ ← Int.natCast_dvd_natCast ]

/-
The exception condition for n=3 is equivalent to |2a+1| being a power of 3 (exponent >= 0).
-/
lemma exception_n3_iff_abs_two_mul_add_one_pow3_corrected (a : ℤ) :
  is_exception_Satz2 3 a ↔ ∃ k : ℕ, Int.natAbs (2 * a + 1) = 3 ^ k := by
    unfold is_exception_Satz2; aesop;
    · exists 1;
    · exists 0;
    · exists 0;
    · grind

lemma lemma_primitive_iff_not_exception_n3 (a : ℤ) (ha : |a| > 1) :
  (∃ p : ℕ, is_primitive_prime_divisor_Chebyshev a 3 p) ↔ ¬ is_exception_Satz2 3 a := by
    unfold is_exception_Satz2; aesop;
    · cases' h with h1 h2;
      -- Since $w$ is a prime divisor of $T_3(a) - 1$, and $T_3(a) = 4a^3 - 3a$, we have $w \mid 4a^3 - 3a - 1$.
      have h_div : (w : ℤ) ∣ 4 * a^3 - 3 * a - 1 := by
        erw [ show ( Chebyshev.T ℤ 3 ) = 4 * Polynomial.X ^ 3 - 3 * Polynomial.X from by simpa using T3_eq ] at h2 ; aesop;
      -- Since $w$ is a prime divisor of $4a^3 - 3a - 1$, and $4a^3 - 3a - 1 = (a - 1)(2a + 1)^2$, we have $w \mid (a - 1)$ or $w \mid (2a + 1)$.
      have h_div_cases : (w : ℤ) ∣ (a - 1) ∨ (w : ℤ) ∣ (2 * a + 1) := by
        have h_div_cases : (w : ℤ) ∣ (a - 1) * (2 * a + 1) ^ 2 := by
          convert h_div using 1 ; ring;
        exact Int.Prime.dvd_mul' h1 h_div_cases |> Or.imp id fun h => Int.Prime.dvd_pow' h1 h;
      rcases h_div_cases with h | h <;> have := h2.2 1 Nat.one_pos ( by decide ) <;> simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ];
      haveI := Fact.mk h1; norm_num at h;
      erw [ ZMod.natCast_eq_zero_iff ] at h ; have := Nat.le_of_dvd ( by positivity ) h.1 ; interval_cases w <;> simp_all +decide;
      grind;
    · rcases h with ⟨ hw_prime, hw_div, hw_not_div ⟩;
      erw [ show ( Chebyshev.T ℤ 3 : Polynomial ℤ ) = 4 * Polynomial.X ^ 3 - 3 * Polynomial.X by exact T3_eq ] at hw_div ; norm_num at hw_div;
      contrapose! hw_not_div;
      use 1; norm_num;
      have h_factor : (w : ℤ) ∣ (a - 1) * (2 * a + 1) ^ 2 := by
        convert hw_div using 1 ; ring;
      haveI := Fact.mk hw_prime; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
      grind +ring;
    · -- By Zsigmondy's theorem, there exists a prime $p$ that divides $2a + 1$ but does not divide $a - 1$.
      obtain ⟨p, hp⟩ : ∃ p : ℕ, Nat.Prime p ∧ p ∣ Int.natAbs (2 * a + 1) ∧ ¬(p ∣ Int.natAbs (a - 1)) := by
        have h_zsigmondy : ∃ p : ℕ, Nat.Prime p ∧ p ∣ Int.natAbs (2 * a + 1) ∧ p ≠ 3 := by
          by_cases h_pow3 : ∃ k : ℕ, Int.natAbs (2 * a + 1) = 3 ^ k;
          · grind;
          · contrapose! h_pow3;
            rw [ ← Nat.prod_primeFactorsList ( show Int.natAbs ( 2 * a + 1 ) ≠ 0 from by norm_num; cases abs_cases a <;> omega ) ] ; rw [ List.prod_eq_pow_single 3 ] ; aesop;
            intro x hx hx'; specialize h_pow3 x ( Nat.prime_of_mem_primeFactorsList hx' ) ( Nat.dvd_of_mem_primeFactorsList hx' ) ; aesop;
        obtain ⟨ p, hp₁, hp₂, hp₃ ⟩ := h_zsigmondy; use p; simp_all +decide [ ← Int.natCast_dvd_natCast ] ;
        intro h; have := Int.dvd_sub hp₂ ( h.mul_left 2 ) ; ring_nf at *; norm_cast at *; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ;
      use p; unfold is_primitive_prime_divisor_Chebyshev; aesop;
      · rw [ show ( Chebyshev.T ℤ 3 : Polynomial ℤ ) = 4 * Polynomial.X ^ 3 - 3 * Polynomial.X from T3_eq ] ; norm_num ; ring_nf;
        rw [ ← Int.natCast_dvd ] at *;
        convert left_4.mul_left ( a ^ 2 * 2 - a - 1 ) using 1 ; ring;
      · interval_cases d <;> simp_all +decide [ ← Int.natCast_dvd_natCast ];
        erw [ Chebyshev.T_two ] at a_3 ; ring_nf at * ; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ];
        grind

/-
The exception condition for n=4 is equivalent to |a| being a power of 2 (exponent >= 0).
-/
lemma exception_n4_iff_abs_pow2 (a : ℤ) :
  is_exception_Satz2 4 a ↔ ∃ k : ℕ, k > 0 ∧ Int.natAbs a = 2 ^ (k - 1) := by
    constructor <;> intro h <;> unfold is_exception_Satz2 at * <;> aesop;
    · exists 1;
    · exists 1;
    · exact ⟨ w, left, rfl ⟩;
    · exact ⟨ w, left, rfl ⟩;
    · exact Or.inr <| Or.inr <| ⟨ w, left, eq_or_eq_neg_of_abs_eq <| by simpa [ ← Int.natCast_inj ] using right ⟩

/-
2 is never a primitive prime divisor of T_4(a)-1.
-/
lemma lemma_two_not_primitive_n4 (a : ℤ) :
  ¬ is_primitive_prime_divisor_Chebyshev a 4 2 := by
    bound;
    -- By definition of is_primitive_prime_divisor_Chebyshev, we know that 2 divides T_4(a)-1 but does not divide T_d(a)-1 for d < 4.
    obtain ⟨h_dvd, h_not_dvd⟩ := a_1;
    exact h_not_dvd.2 2 ( by decide ) ( by decide ) ( by erw [ show ( Chebyshev.T ℤ 2 ) = 2 * Polynomial.X ^ 2 - 1 from T2_eq ] ; norm_num; ring_nf; norm_num [ ← even_iff_two_dvd, parity_simps ] )

lemma lemma_primitive_iff_not_exception_n4 (a : ℤ) (ha : |a| > 1) :
  (∃ p : ℕ, is_primitive_prime_divisor_Chebyshev a 4 p) ↔ ¬ is_exception_Satz2 4 a := by
    rw [ exception_n4_iff_abs_pow2 ];
    constructor;
    · rintro ⟨ p, hp₁, hp₂ ⟩ ⟨ k, hk₀, hk ⟩;
      -- Since $p$ is a primitive prime divisor of $T_4(a) - 1$, we have $p \mid 2a$.
      have hp_div_2a : (p : ℤ) ∣ 2 * a := by
        have hp_div_2a : (p : ℤ) ∣ (OmegaZ 4).eval a := by
          have := if_T_then_Omega a 4 (by linarith) p
          exact this ⟨ hp₁, hp₂.1, hp₂.2 ⟩;
        convert hp_div_2a using 1 ; norm_num [ OmegaZ_four ];
      -- Since $p$ is a primitive prime divisor of $T_4(a) - 1$, we have $p \mid 2$ or $p \mid a$.
      by_cases hp_div_2 : (p : ℤ) ∣ 2;
      · norm_cast at hp_div_2; have := Nat.le_of_dvd ( by decide ) hp_div_2; interval_cases p <;> norm_num at *;
        have := hp₂.2 2 ( by decide ) ( by decide ) ; norm_num [ Chebyshev.T ] at this;
        erw [ Chebyshev.T ] at this ; norm_num [ pow_succ, Int.add_emod, Int.sub_emod, Int.mul_emod ] at this;
      · -- Since $p$ is a primitive prime divisor of $T_4(a) - 1$, we have $p \mid a$.
        have hp_div_a : (p : ℤ) ∣ a := by
          exact Or.resolve_left ( Int.Prime.dvd_mul' hp₁ hp_div_2a ) hp_div_2;
        exact absurd ( Int.natAbs_dvd_natAbs.mpr hp_div_a ) ( by rw [ hk ] ; exact mt ( fun h => Nat.Prime.dvd_of_dvd_pow hp₁ h ) ( by simpa using fun h => hp_div_2 <| Int.natCast_dvd.mpr h ) );
    · contrapose!;
      intro h;
      -- By definition of `wniosek`, we know that if `p` is a primitive prime divisor of `T_4(a)-1`, then `|OmegaZ_4(a)|` is a power of `p`.
      obtain ⟨p, hp_prime, hp_dvd, hp_not_dvd⟩ : ∃ p : ℕ, p.Prime ∧ p ∣ 4 ∧ ∃ k : ℕ, |(OmegaZ 4).eval a| = p ^ k := by
        have := @wniosek 4 a ?_ ?_ <;> simp_all +decide [ is_exception_Satz2 ];
        refine' this.mp _;
        unfold Che; aesop;
        have := Nat.sInf_mem ( show { m : ℕ | 0 < m ∧ ( x : ℤ ) ∣ eval a ( Chebyshev.T ℤ m ) - 1 }.Nonempty from Nat.nonempty_of_pos_sInf <| a_2.symm ▸ by decide ) ; aesop;
        rw [ eq_comm ] at a_2 ; aesop;
        contrapose! h;
        use x;
        constructor;
        · assumption;
        · exact ⟨ right, fun d hd₁ hd₂ => fun hd₃ => not_lt_of_ge ( a_2 ▸ Nat.sInf_le ⟨ hd₁, hd₃ ⟩ ) hd₂ ⟩;
      have := Nat.le_of_dvd ( by decide ) hp_dvd; interval_cases p <;> norm_num at *;
      obtain ⟨ k, hk ⟩ := hp_not_dvd;
      rw [ abs_eq ( by positivity ) ] at hk;
      rcases hk with ( hk | hk ) <;> rw [ show OmegaZ 4 = 2 * Polynomial.X from OmegaZ_four ] at hk <;> norm_num at hk;
      · rcases k with ( _ | k ) <;> simp_all +decide [ pow_succ' ];
        · grind;
        · exact ⟨ k + 1, Nat.succ_pos _, rfl ⟩;
      · rcases k with ( _ | k ) <;> norm_num [ pow_succ' ] at *;
        · omega;
        · exact ⟨ k + 1, Nat.succ_pos _, by cases abs_cases a <;> norm_num <;> linarith [ pow_pos ( zero_lt_two' ℤ ) k ] ⟩

/-
The exception condition for n=6 is equivalent to |2a-1| being a power of 3 (exponent >= 0).
-/
lemma exception_n6_iff_abs_two_mul_sub_one_pow3 (a : ℤ) :
  is_exception_Satz2 6 a ↔ ∃ k : ℕ, Int.natAbs (2 * a - 1) = 3 ^ k := by
    unfold is_exception_Satz2; aesop;
    · exists 0;
    · exists 0;
    · exists 1;
    · grind

/-
2 is never a primitive prime divisor of T_6(a)-1.
-/
lemma lemma_two_not_primitive_n6 (a : ℤ) :
  ¬ is_primitive_prime_divisor_Chebyshev a 6 2 := by
    unfold is_primitive_prime_divisor_Chebyshev; aesop;
    use 2;
    erw [ Chebyshev.T_two ] ; norm_num [ ← even_iff_two_dvd, parity_simps ]

/-
3 is never a primitive prime divisor of T_6(a)-1.
-/
lemma lemma_three_not_primitive_n6 (a : ℤ) :
  ¬ is_primitive_prime_divisor_Chebyshev a 6 3 := by
    unfold is_primitive_prime_divisor_Chebyshev; aesop;
    -- Consider $x = 2$.
    use 2; norm_num;
    erw [ Chebyshev.T ] at *;
    erw [ Chebyshev.T ] at * ; aesop;
    erw [ Chebyshev.T ] at * ; aesop;
    erw [ Chebyshev.T ] at * ; aesop;
    erw [ Chebyshev.T ] at * ; aesop;
    erw [ Chebyshev.T ] at * ; aesop;
    rw [ Int.dvd_iff_emod_eq_zero ] at *; norm_num [ Int.add_emod, Int.sub_emod, Int.mul_emod ] at *; have := Int.emod_nonneg a three_pos.ne'; have := Int.emod_lt_of_pos a three_pos; interval_cases a % 3 <;> trivial;

lemma lemma_primitive_iff_not_exception_n6 (a : ℤ) (ha : |a| > 1) :
  (∃ p : ℕ, is_primitive_prime_divisor_Chebyshev a 6 p) ↔ ¬ is_exception_Satz2 6 a := by
    aesop;
    · -- Since $w$ is a primitive prime divisor of $T_6(a)-1$, it must be that $w \neq 2$ and $w \neq 3$.
      have h_not_2_3 : w ≠ 2 ∧ w ≠ 3 := by
        exact ⟨ by rintro rfl; exact absurd ( lemma_two_not_primitive_n6 a ) ( by tauto ), by rintro rfl; exact absurd ( lemma_three_not_primitive_n6 a ) ( by tauto ) ⟩;
      -- Since $w$ is a primitive prime divisor of $T_6(a)-1$, it must be that $w \mid \Omega_6(a)$.
      have h_div_Omega6 : (w : ℤ) ∣ (OmegaZ 6).eval a := by
        apply if_T_then_Omega;
        · norm_num;
        · assumption;
      -- Since $w$ is a primitive prime divisor of $T_6(a)-1$, it must be that $w \mid \Omega_6(a)$ and $w \nmid \Omega_d(a)$ for any $d \mid 6$ with $d \neq 6$.
      have h_div_Omega6 : (w : ℤ) ∣ (2 * a - 1) := by
        exact h_div_Omega6.trans ( by erw [ OmegaZ_six ] ; norm_num );
      -- Since $|2a-1|$ is a power of 3, we have $w \mid 3^k$ for some $k$.
      obtain ⟨k, hk⟩ : ∃ k : ℕ, (w : ℤ) ∣ 3 ^ k := by
        cases a_1 <;> aesop;
      norm_cast at hk; have := h.1; ( have := Nat.Prime.dvd_of_dvd_pow this hk; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ; );
    · apply Classical.byContradiction
      intro h_no_primitive_prime_divisor_n6;
      -- Apply `wniosek` for $n=6$.
      have h_wniosek : ∃ p : ℕ, p.Prime ∧ p ∣ 6 ∧ ∃ k : ℕ, |(OmegaZ 6).eval a| = p ^ k := by
        have := wniosek 6 a ( by norm_num ) ha;
        refine' this.mp _;
        unfold Che; norm_num;
        intro p hp h; contrapose! h_no_primitive_prime_divisor_n6; use p; unfold is_primitive_prime_divisor_Chebyshev; aesop;
        · exact ( Nat.sInf_mem ( show { m : ℕ | 0 < m ∧ ( p : ℤ ) ∣ eval a ( Chebyshev.T ℤ m ) - 1 }.Nonempty from by contrapose! h_no_primitive_prime_divisor_n6; aesop ) ) |>.2;
        · exact a_3.not_le ( Nat.sInf_le ⟨ a_2, a_4 ⟩ );
      obtain ⟨ p, hp_prime, hp_div, k, hk ⟩ := h_wniosek;
      have := Nat.le_of_dvd ( by decide ) hp_div; interval_cases p <;> norm_num at *;
      · -- Since $|2a-1| = 2^k$, we have $2a-1 = \pm 2^k$.
        have h_cases : 2 * a - 1 = 2 ^ k ∨ 2 * a - 1 = -2 ^ k := by
          exact eq_or_eq_neg_of_abs_eq ( by erw [ OmegaZ_six ] at hk; norm_num at hk; linarith );
        rcases k with ( _ | k ) <;> norm_num [ pow_succ' ] at *;
        · cases h_cases <;> cases abs_cases a <;> linarith;
        · omega;
      · apply a_1;
        unfold is_exception_Satz2; aesop;
        -- Since $|2a - 1| = 3^k$, we have $2a - 1 = \pm 3^k$.
        have h_cases : 2 * a - 1 = 3 ^ k ∨ 2 * a - 1 = -3 ^ k := by
          exact eq_or_eq_neg_of_abs_eq ( by simpa [ OmegaZ_six ] using hk );
        grind

/-
Theorem 2: There exists a prime number p such that n = Che(a) (i.e., p is a primitive prime divisor of T_n(a)-1) if and only if (n, a) is not one of the exceptional cases listed.
-/
theorem Satz_2 (n : ℕ) (a : ℤ) (hn : n > 0) :
  (∃ p : ℕ, is_primitive_prime_divisor_Chebyshev a n p) ↔ ¬ is_exception_Satz2 n a := by
    -- We split the proof into cases based on the magnitude of $a$ and the value of $n$.
    by_cases ha : |a| > 1;
    · by_cases h_case : n ∈ ({1, 2, 3, 4, 6} : Finset ℕ);
      · aesop;
        all_goals have := lemma_primitive_iff_not_exception_n1 a ha; have := lemma_primitive_iff_not_exception_n2 a ha; have := lemma_primitive_iff_not_exception_n3 a ha; have := lemma_primitive_iff_not_exception_n4 a ha; have := lemma_primitive_iff_not_exception_n6 a ha; aesop;
      · have := lemma_primitive_exists_of_large_n n a ha ( show n ≥ 5 by contrapose! h_case; interval_cases n <;> trivial ) ( show n ≠ 6 by aesop ) ; aesop;
        cases a_1 <;> aesop;
    · -- Apply the lemma that states the equivalence between the existence of a primitive prime divisor and the non-exceptionality when |a| ≤ 1.
      apply lemma_primitive_iff_not_exception_small_a n a hn (le_of_not_gt ha)